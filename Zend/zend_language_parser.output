

Terminals which are not used:

   "end of file"
   T_CHARACTER
   T_BAD_CHARACTER
   "comment (T_COMMENT)"
   "doc comment (T_DOC_COMMENT)"
   "open tag (T_OPEN_TAG)"
   "open tag with echo (T_OPEN_TAG_WITH_ECHO)"
   "close tag (T_CLOSE_TAG)"
   "whitespace (T_WHITESPACE)"


Conflict in state 120 between rule 507 and token "or (T_LOGICAL_OR)" resolved as shift.
Conflict in state 120 between rule 507 and token "xor (T_LOGICAL_XOR)" resolved as shift.
Conflict in state 120 between rule 507 and token "and (T_LOGICAL_AND)" resolved as shift.
Conflict in state 120 between rule 507 and token '?' resolved as shift.
Conflict in state 120 between rule 507 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 120 between rule 507 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 120 between rule 507 and token '|' resolved as shift.
Conflict in state 120 between rule 507 and token '^' resolved as shift.
Conflict in state 120 between rule 507 and token '&' resolved as shift.
Conflict in state 120 between rule 507 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 120 between rule 507 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 120 between rule 507 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 120 between rule 507 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 120 between rule 507 and token '<' resolved as shift.
Conflict in state 120 between rule 507 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 120 between rule 507 and token '>' resolved as shift.
Conflict in state 120 between rule 507 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 120 between rule 507 and token "<< (T_SL)" resolved as shift.
Conflict in state 120 between rule 507 and token ">> (T_SR)" resolved as shift.
Conflict in state 120 between rule 507 and token '+' resolved as shift.
Conflict in state 120 between rule 507 and token '-' resolved as shift.
Conflict in state 120 between rule 507 and token '.' resolved as shift.
Conflict in state 120 between rule 507 and token '*' resolved as shift.
Conflict in state 120 between rule 507 and token '/' resolved as shift.
Conflict in state 120 between rule 507 and token '%' resolved as shift.
Conflict in state 120 between rule 507 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 121 between rule 508 and token "or (T_LOGICAL_OR)" resolved as shift.
Conflict in state 121 between rule 508 and token "xor (T_LOGICAL_XOR)" resolved as shift.
Conflict in state 121 between rule 508 and token "and (T_LOGICAL_AND)" resolved as shift.
Conflict in state 121 between rule 508 and token '?' resolved as shift.
Conflict in state 121 between rule 508 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 121 between rule 508 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 121 between rule 508 and token '|' resolved as shift.
Conflict in state 121 between rule 508 and token '^' resolved as shift.
Conflict in state 121 between rule 508 and token '&' resolved as shift.
Conflict in state 121 between rule 508 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 121 between rule 508 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 121 between rule 508 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 121 between rule 508 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 121 between rule 508 and token '<' resolved as shift.
Conflict in state 121 between rule 508 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 121 between rule 508 and token '>' resolved as shift.
Conflict in state 121 between rule 508 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 121 between rule 508 and token "<< (T_SL)" resolved as shift.
Conflict in state 121 between rule 508 and token ">> (T_SR)" resolved as shift.
Conflict in state 121 between rule 508 and token '+' resolved as shift.
Conflict in state 121 between rule 508 and token '-' resolved as shift.
Conflict in state 121 between rule 508 and token '.' resolved as shift.
Conflict in state 121 between rule 508 and token '*' resolved as shift.
Conflict in state 121 between rule 508 and token '/' resolved as shift.
Conflict in state 121 between rule 508 and token '%' resolved as shift.
Conflict in state 121 between rule 508 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 123 between rule 510 and token "or (T_LOGICAL_OR)" resolved as shift.
Conflict in state 123 between rule 510 and token "xor (T_LOGICAL_XOR)" resolved as shift.
Conflict in state 123 between rule 510 and token "and (T_LOGICAL_AND)" resolved as shift.
Conflict in state 123 between rule 510 and token '?' resolved as shift.
Conflict in state 123 between rule 510 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 123 between rule 510 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 123 between rule 510 and token '|' resolved as shift.
Conflict in state 123 between rule 510 and token '^' resolved as shift.
Conflict in state 123 between rule 510 and token '&' resolved as shift.
Conflict in state 123 between rule 510 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 123 between rule 510 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 123 between rule 510 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 123 between rule 510 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 123 between rule 510 and token '<' resolved as shift.
Conflict in state 123 between rule 510 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 123 between rule 510 and token '>' resolved as shift.
Conflict in state 123 between rule 510 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 123 between rule 510 and token "<< (T_SL)" resolved as shift.
Conflict in state 123 between rule 510 and token ">> (T_SR)" resolved as shift.
Conflict in state 123 between rule 510 and token '+' resolved as shift.
Conflict in state 123 between rule 510 and token '-' resolved as shift.
Conflict in state 123 between rule 510 and token '.' resolved as shift.
Conflict in state 123 between rule 510 and token '*' resolved as shift.
Conflict in state 123 between rule 510 and token '/' resolved as shift.
Conflict in state 123 between rule 510 and token '%' resolved as shift.
Conflict in state 123 between rule 510 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 124 between rule 511 and token "or (T_LOGICAL_OR)" resolved as shift.
Conflict in state 124 between rule 511 and token "xor (T_LOGICAL_XOR)" resolved as shift.
Conflict in state 124 between rule 511 and token "and (T_LOGICAL_AND)" resolved as shift.
Conflict in state 124 between rule 511 and token '?' resolved as shift.
Conflict in state 124 between rule 511 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 124 between rule 511 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 124 between rule 511 and token '|' resolved as shift.
Conflict in state 124 between rule 511 and token '^' resolved as shift.
Conflict in state 124 between rule 511 and token '&' resolved as shift.
Conflict in state 124 between rule 511 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 124 between rule 511 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 124 between rule 511 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 124 between rule 511 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 124 between rule 511 and token '<' resolved as shift.
Conflict in state 124 between rule 511 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 124 between rule 511 and token '>' resolved as shift.
Conflict in state 124 between rule 511 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 124 between rule 511 and token "<< (T_SL)" resolved as shift.
Conflict in state 124 between rule 511 and token ">> (T_SR)" resolved as shift.
Conflict in state 124 between rule 511 and token '+' resolved as shift.
Conflict in state 124 between rule 511 and token '-' resolved as shift.
Conflict in state 124 between rule 511 and token '.' resolved as shift.
Conflict in state 124 between rule 511 and token '*' resolved as shift.
Conflict in state 124 between rule 511 and token '/' resolved as shift.
Conflict in state 124 between rule 511 and token '%' resolved as shift.
Conflict in state 124 between rule 511 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 125 between rule 332 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 125 between rule 332 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 125 between rule 332 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 125 between rule 332 and token '?' resolved as shift.
Conflict in state 125 between rule 332 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 125 between rule 332 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 125 between rule 332 and token '|' resolved as shift.
Conflict in state 125 between rule 332 and token '^' resolved as shift.
Conflict in state 125 between rule 332 and token '&' resolved as shift.
Conflict in state 125 between rule 332 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 125 between rule 332 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 125 between rule 332 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 125 between rule 332 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 125 between rule 332 and token '<' resolved as shift.
Conflict in state 125 between rule 332 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 125 between rule 332 and token '>' resolved as shift.
Conflict in state 125 between rule 332 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 125 between rule 332 and token "<< (T_SL)" resolved as shift.
Conflict in state 125 between rule 332 and token ">> (T_SR)" resolved as shift.
Conflict in state 125 between rule 332 and token '+' resolved as shift.
Conflict in state 125 between rule 332 and token '-' resolved as shift.
Conflict in state 125 between rule 332 and token '.' resolved as shift.
Conflict in state 125 between rule 332 and token '*' resolved as shift.
Conflict in state 125 between rule 332 and token '/' resolved as shift.
Conflict in state 125 between rule 332 and token '%' resolved as shift.
Conflict in state 125 between rule 332 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 126 between rule 295 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 126 between rule 295 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 126 between rule 295 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 126 between rule 295 and token '?' resolved as reduce.
Conflict in state 126 between rule 295 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 126 between rule 295 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 126 between rule 295 and token '|' resolved as reduce.
Conflict in state 126 between rule 295 and token '^' resolved as reduce.
Conflict in state 126 between rule 295 and token '&' resolved as reduce.
Conflict in state 126 between rule 295 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 126 between rule 295 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 126 between rule 295 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 126 between rule 295 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 126 between rule 295 and token '<' resolved as reduce.
Conflict in state 126 between rule 295 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 126 between rule 295 and token '>' resolved as reduce.
Conflict in state 126 between rule 295 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 126 between rule 295 and token "<< (T_SL)" resolved as reduce.
Conflict in state 126 between rule 295 and token ">> (T_SR)" resolved as reduce.
Conflict in state 126 between rule 295 and token '+' resolved as reduce.
Conflict in state 126 between rule 295 and token '-' resolved as reduce.
Conflict in state 126 between rule 295 and token '.' resolved as reduce.
Conflict in state 126 between rule 295 and token '*' resolved as reduce.
Conflict in state 126 between rule 295 and token '/' resolved as reduce.
Conflict in state 126 between rule 295 and token '%' resolved as reduce.
Conflict in state 126 between rule 295 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 127 between rule 296 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 127 between rule 296 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 127 between rule 296 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 127 between rule 296 and token '?' resolved as reduce.
Conflict in state 127 between rule 296 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 127 between rule 296 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 127 between rule 296 and token '|' resolved as reduce.
Conflict in state 127 between rule 296 and token '^' resolved as reduce.
Conflict in state 127 between rule 296 and token '&' resolved as reduce.
Conflict in state 127 between rule 296 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 127 between rule 296 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 127 between rule 296 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 127 between rule 296 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 127 between rule 296 and token '<' resolved as reduce.
Conflict in state 127 between rule 296 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 127 between rule 296 and token '>' resolved as reduce.
Conflict in state 127 between rule 296 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 127 between rule 296 and token "<< (T_SL)" resolved as reduce.
Conflict in state 127 between rule 296 and token ">> (T_SR)" resolved as reduce.
Conflict in state 127 between rule 296 and token '+' resolved as reduce.
Conflict in state 127 between rule 296 and token '-' resolved as reduce.
Conflict in state 127 between rule 296 and token '.' resolved as reduce.
Conflict in state 127 between rule 296 and token '*' resolved as reduce.
Conflict in state 127 between rule 296 and token '/' resolved as reduce.
Conflict in state 127 between rule 296 and token '%' resolved as reduce.
Conflict in state 127 between rule 296 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 128 between rule 297 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 128 between rule 297 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 128 between rule 297 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 128 between rule 297 and token '?' resolved as reduce.
Conflict in state 128 between rule 297 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 128 between rule 297 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 128 between rule 297 and token '|' resolved as reduce.
Conflict in state 128 between rule 297 and token '^' resolved as reduce.
Conflict in state 128 between rule 297 and token '&' resolved as reduce.
Conflict in state 128 between rule 297 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 128 between rule 297 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 128 between rule 297 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 128 between rule 297 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 128 between rule 297 and token '<' resolved as reduce.
Conflict in state 128 between rule 297 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 128 between rule 297 and token '>' resolved as reduce.
Conflict in state 128 between rule 297 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 128 between rule 297 and token "<< (T_SL)" resolved as reduce.
Conflict in state 128 between rule 297 and token ">> (T_SR)" resolved as reduce.
Conflict in state 128 between rule 297 and token '+' resolved as reduce.
Conflict in state 128 between rule 297 and token '-' resolved as reduce.
Conflict in state 128 between rule 297 and token '.' resolved as reduce.
Conflict in state 128 between rule 297 and token '*' resolved as reduce.
Conflict in state 128 between rule 297 and token '/' resolved as reduce.
Conflict in state 128 between rule 297 and token '%' resolved as reduce.
Conflict in state 128 between rule 297 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 129 between rule 298 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 129 between rule 298 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 129 between rule 298 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 129 between rule 298 and token '?' resolved as reduce.
Conflict in state 129 between rule 298 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 129 between rule 298 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 129 between rule 298 and token '|' resolved as reduce.
Conflict in state 129 between rule 298 and token '^' resolved as reduce.
Conflict in state 129 between rule 298 and token '&' resolved as reduce.
Conflict in state 129 between rule 298 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 129 between rule 298 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 129 between rule 298 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 129 between rule 298 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 129 between rule 298 and token '<' resolved as reduce.
Conflict in state 129 between rule 298 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 129 between rule 298 and token '>' resolved as reduce.
Conflict in state 129 between rule 298 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 129 between rule 298 and token "<< (T_SL)" resolved as reduce.
Conflict in state 129 between rule 298 and token ">> (T_SR)" resolved as reduce.
Conflict in state 129 between rule 298 and token '+' resolved as reduce.
Conflict in state 129 between rule 298 and token '-' resolved as reduce.
Conflict in state 129 between rule 298 and token '.' resolved as reduce.
Conflict in state 129 between rule 298 and token '*' resolved as reduce.
Conflict in state 129 between rule 298 and token '/' resolved as reduce.
Conflict in state 129 between rule 298 and token '%' resolved as reduce.
Conflict in state 129 between rule 298 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 139 between rule 318 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 139 between rule 318 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 139 between rule 318 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 139 between rule 318 and token '?' resolved as reduce.
Conflict in state 139 between rule 318 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 139 between rule 318 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 139 between rule 318 and token '|' resolved as reduce.
Conflict in state 139 between rule 318 and token '^' resolved as reduce.
Conflict in state 139 between rule 318 and token '&' resolved as reduce.
Conflict in state 139 between rule 318 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 139 between rule 318 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 139 between rule 318 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 139 between rule 318 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 139 between rule 318 and token '<' resolved as reduce.
Conflict in state 139 between rule 318 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 139 between rule 318 and token '>' resolved as reduce.
Conflict in state 139 between rule 318 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 139 between rule 318 and token "<< (T_SL)" resolved as reduce.
Conflict in state 139 between rule 318 and token ">> (T_SR)" resolved as reduce.
Conflict in state 139 between rule 318 and token '+' resolved as reduce.
Conflict in state 139 between rule 318 and token '-' resolved as reduce.
Conflict in state 139 between rule 318 and token '.' resolved as reduce.
Conflict in state 139 between rule 318 and token '*' resolved as reduce.
Conflict in state 139 between rule 318 and token '/' resolved as reduce.
Conflict in state 139 between rule 318 and token '%' resolved as reduce.
Conflict in state 139 between rule 318 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 140 between rule 319 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 140 between rule 319 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 140 between rule 319 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 140 between rule 319 and token '?' resolved as reduce.
Conflict in state 140 between rule 319 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 140 between rule 319 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 140 between rule 319 and token '|' resolved as reduce.
Conflict in state 140 between rule 319 and token '^' resolved as reduce.
Conflict in state 140 between rule 319 and token '&' resolved as reduce.
Conflict in state 140 between rule 319 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 140 between rule 319 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 140 between rule 319 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 140 between rule 319 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 140 between rule 319 and token '<' resolved as reduce.
Conflict in state 140 between rule 319 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 140 between rule 319 and token '>' resolved as reduce.
Conflict in state 140 between rule 319 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 140 between rule 319 and token "<< (T_SL)" resolved as reduce.
Conflict in state 140 between rule 319 and token ">> (T_SR)" resolved as reduce.
Conflict in state 140 between rule 319 and token '+' resolved as reduce.
Conflict in state 140 between rule 319 and token '-' resolved as reduce.
Conflict in state 140 between rule 319 and token '.' resolved as reduce.
Conflict in state 140 between rule 319 and token '*' resolved as reduce.
Conflict in state 140 between rule 319 and token '/' resolved as reduce.
Conflict in state 140 between rule 319 and token '%' resolved as reduce.
Conflict in state 140 between rule 319 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 141 between rule 320 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 141 between rule 320 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 141 between rule 320 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 141 between rule 320 and token '?' resolved as reduce.
Conflict in state 141 between rule 320 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 141 between rule 320 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 141 between rule 320 and token '|' resolved as reduce.
Conflict in state 141 between rule 320 and token '^' resolved as reduce.
Conflict in state 141 between rule 320 and token '&' resolved as reduce.
Conflict in state 141 between rule 320 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 141 between rule 320 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 141 between rule 320 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 141 between rule 320 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 141 between rule 320 and token '<' resolved as reduce.
Conflict in state 141 between rule 320 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 141 between rule 320 and token '>' resolved as reduce.
Conflict in state 141 between rule 320 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 141 between rule 320 and token "<< (T_SL)" resolved as reduce.
Conflict in state 141 between rule 320 and token ">> (T_SR)" resolved as reduce.
Conflict in state 141 between rule 320 and token '+' resolved as reduce.
Conflict in state 141 between rule 320 and token '-' resolved as reduce.
Conflict in state 141 between rule 320 and token '.' resolved as reduce.
Conflict in state 141 between rule 320 and token '*' resolved as reduce.
Conflict in state 141 between rule 320 and token '/' resolved as reduce.
Conflict in state 141 between rule 320 and token '%' resolved as reduce.
Conflict in state 141 between rule 320 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 142 between rule 321 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 142 between rule 321 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 142 between rule 321 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 142 between rule 321 and token '?' resolved as reduce.
Conflict in state 142 between rule 321 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 142 between rule 321 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 142 between rule 321 and token '|' resolved as reduce.
Conflict in state 142 between rule 321 and token '^' resolved as reduce.
Conflict in state 142 between rule 321 and token '&' resolved as reduce.
Conflict in state 142 between rule 321 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 142 between rule 321 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 142 between rule 321 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 142 between rule 321 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 142 between rule 321 and token '<' resolved as reduce.
Conflict in state 142 between rule 321 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 142 between rule 321 and token '>' resolved as reduce.
Conflict in state 142 between rule 321 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 142 between rule 321 and token "<< (T_SL)" resolved as reduce.
Conflict in state 142 between rule 321 and token ">> (T_SR)" resolved as reduce.
Conflict in state 142 between rule 321 and token '+' resolved as reduce.
Conflict in state 142 between rule 321 and token '-' resolved as reduce.
Conflict in state 142 between rule 321 and token '.' resolved as reduce.
Conflict in state 142 between rule 321 and token '*' resolved as reduce.
Conflict in state 142 between rule 321 and token '/' resolved as reduce.
Conflict in state 142 between rule 321 and token '%' resolved as reduce.
Conflict in state 142 between rule 321 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 143 between rule 322 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 143 between rule 322 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 143 between rule 322 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 143 between rule 322 and token '?' resolved as reduce.
Conflict in state 143 between rule 322 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 143 between rule 322 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 143 between rule 322 and token '|' resolved as reduce.
Conflict in state 143 between rule 322 and token '^' resolved as reduce.
Conflict in state 143 between rule 322 and token '&' resolved as reduce.
Conflict in state 143 between rule 322 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 143 between rule 322 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 143 between rule 322 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 143 between rule 322 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 143 between rule 322 and token '<' resolved as reduce.
Conflict in state 143 between rule 322 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 143 between rule 322 and token '>' resolved as reduce.
Conflict in state 143 between rule 322 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 143 between rule 322 and token "<< (T_SL)" resolved as reduce.
Conflict in state 143 between rule 322 and token ">> (T_SR)" resolved as reduce.
Conflict in state 143 between rule 322 and token '+' resolved as reduce.
Conflict in state 143 between rule 322 and token '-' resolved as reduce.
Conflict in state 143 between rule 322 and token '.' resolved as reduce.
Conflict in state 143 between rule 322 and token '*' resolved as reduce.
Conflict in state 143 between rule 322 and token '/' resolved as reduce.
Conflict in state 143 between rule 322 and token '%' resolved as reduce.
Conflict in state 143 between rule 322 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 144 between rule 323 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 144 between rule 323 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 144 between rule 323 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 144 between rule 323 and token '?' resolved as reduce.
Conflict in state 144 between rule 323 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 144 between rule 323 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 144 between rule 323 and token '|' resolved as reduce.
Conflict in state 144 between rule 323 and token '^' resolved as reduce.
Conflict in state 144 between rule 323 and token '&' resolved as reduce.
Conflict in state 144 between rule 323 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 144 between rule 323 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 144 between rule 323 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 144 between rule 323 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 144 between rule 323 and token '<' resolved as reduce.
Conflict in state 144 between rule 323 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 144 between rule 323 and token '>' resolved as reduce.
Conflict in state 144 between rule 323 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 144 between rule 323 and token "<< (T_SL)" resolved as reduce.
Conflict in state 144 between rule 323 and token ">> (T_SR)" resolved as reduce.
Conflict in state 144 between rule 323 and token '+' resolved as reduce.
Conflict in state 144 between rule 323 and token '-' resolved as reduce.
Conflict in state 144 between rule 323 and token '.' resolved as reduce.
Conflict in state 144 between rule 323 and token '*' resolved as reduce.
Conflict in state 144 between rule 323 and token '/' resolved as reduce.
Conflict in state 144 between rule 323 and token '%' resolved as reduce.
Conflict in state 144 between rule 323 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 145 between rule 324 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 145 between rule 324 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 145 between rule 324 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 145 between rule 324 and token '?' resolved as reduce.
Conflict in state 145 between rule 324 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 145 between rule 324 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 145 between rule 324 and token '|' resolved as reduce.
Conflict in state 145 between rule 324 and token '^' resolved as reduce.
Conflict in state 145 between rule 324 and token '&' resolved as reduce.
Conflict in state 145 between rule 324 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 145 between rule 324 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 145 between rule 324 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 145 between rule 324 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 145 between rule 324 and token '<' resolved as reduce.
Conflict in state 145 between rule 324 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 145 between rule 324 and token '>' resolved as reduce.
Conflict in state 145 between rule 324 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 145 between rule 324 and token "<< (T_SL)" resolved as reduce.
Conflict in state 145 between rule 324 and token ">> (T_SR)" resolved as reduce.
Conflict in state 145 between rule 324 and token '+' resolved as reduce.
Conflict in state 145 between rule 324 and token '-' resolved as reduce.
Conflict in state 145 between rule 324 and token '.' resolved as reduce.
Conflict in state 145 between rule 324 and token '*' resolved as reduce.
Conflict in state 145 between rule 324 and token '/' resolved as reduce.
Conflict in state 145 between rule 324 and token '%' resolved as reduce.
Conflict in state 145 between rule 324 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 161 between rule 259 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 161 between rule 259 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 161 between rule 259 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 161 between rule 259 and token '?' resolved as reduce.
Conflict in state 161 between rule 259 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 161 between rule 259 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 161 between rule 259 and token '|' resolved as reduce.
Conflict in state 161 between rule 259 and token '^' resolved as reduce.
Conflict in state 161 between rule 259 and token '&' resolved as reduce.
Conflict in state 161 between rule 259 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 161 between rule 259 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 161 between rule 259 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 161 between rule 259 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 161 between rule 259 and token '<' resolved as reduce.
Conflict in state 161 between rule 259 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 161 between rule 259 and token '>' resolved as reduce.
Conflict in state 161 between rule 259 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 161 between rule 259 and token "<< (T_SL)" resolved as reduce.
Conflict in state 161 between rule 259 and token ">> (T_SR)" resolved as reduce.
Conflict in state 161 between rule 259 and token '+' resolved as reduce.
Conflict in state 161 between rule 259 and token '-' resolved as reduce.
Conflict in state 161 between rule 259 and token '.' resolved as reduce.
Conflict in state 161 between rule 259 and token '*' resolved as reduce.
Conflict in state 161 between rule 259 and token '/' resolved as reduce.
Conflict in state 161 between rule 259 and token '%' resolved as reduce.
Conflict in state 161 between rule 259 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 290 between rule 327 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 290 between rule 327 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 290 between rule 327 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 290 between rule 327 and token '?' resolved as reduce.
Conflict in state 290 between rule 327 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 290 between rule 327 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 290 between rule 327 and token '|' resolved as reduce.
Conflict in state 290 between rule 327 and token '^' resolved as reduce.
Conflict in state 290 between rule 327 and token '&' resolved as reduce.
Conflict in state 290 between rule 327 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 290 between rule 327 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 290 between rule 327 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 290 between rule 327 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 290 between rule 327 and token '<' resolved as reduce.
Conflict in state 290 between rule 327 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 290 between rule 327 and token '>' resolved as reduce.
Conflict in state 290 between rule 327 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 290 between rule 327 and token "<< (T_SL)" resolved as reduce.
Conflict in state 290 between rule 327 and token ">> (T_SR)" resolved as reduce.
Conflict in state 290 between rule 327 and token '+' resolved as reduce.
Conflict in state 290 between rule 327 and token '-' resolved as reduce.
Conflict in state 290 between rule 327 and token '.' resolved as reduce.
Conflict in state 290 between rule 327 and token '*' resolved as reduce.
Conflict in state 290 between rule 327 and token '/' resolved as reduce.
Conflict in state 290 between rule 327 and token '%' resolved as reduce.
Conflict in state 290 between rule 327 and token "instanceof (T_INSTANCEOF)" resolved as reduce.
Conflict in state 386 between rule 283 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 386 between rule 283 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 386 between rule 283 and token "and (T_LOGICAL_AND)" resolved as shift.
Conflict in state 386 between rule 283 and token '?' resolved as shift.
Conflict in state 386 between rule 283 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 386 between rule 283 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 386 between rule 283 and token '|' resolved as shift.
Conflict in state 386 between rule 283 and token '^' resolved as shift.
Conflict in state 386 between rule 283 and token '&' resolved as shift.
Conflict in state 386 between rule 283 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 386 between rule 283 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 386 between rule 283 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 386 between rule 283 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 386 between rule 283 and token '<' resolved as shift.
Conflict in state 386 between rule 283 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 386 between rule 283 and token '>' resolved as shift.
Conflict in state 386 between rule 283 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 386 between rule 283 and token "<< (T_SL)" resolved as shift.
Conflict in state 386 between rule 283 and token ">> (T_SR)" resolved as shift.
Conflict in state 386 between rule 283 and token '+' resolved as shift.
Conflict in state 386 between rule 283 and token '-' resolved as shift.
Conflict in state 386 between rule 283 and token '.' resolved as shift.
Conflict in state 386 between rule 283 and token '*' resolved as shift.
Conflict in state 386 between rule 283 and token '/' resolved as shift.
Conflict in state 386 between rule 283 and token '%' resolved as shift.
Conflict in state 386 between rule 283 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 392 between rule 284 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 392 between rule 284 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 392 between rule 284 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 392 between rule 284 and token '?' resolved as reduce.
Conflict in state 392 between rule 284 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 392 between rule 284 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 392 between rule 284 and token '|' resolved as reduce.
Conflict in state 392 between rule 284 and token '^' resolved as shift.
Conflict in state 392 between rule 284 and token '&' resolved as shift.
Conflict in state 392 between rule 284 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 392 between rule 284 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 392 between rule 284 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 392 between rule 284 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 392 between rule 284 and token '<' resolved as shift.
Conflict in state 392 between rule 284 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 392 between rule 284 and token '>' resolved as shift.
Conflict in state 392 between rule 284 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 392 between rule 284 and token "<< (T_SL)" resolved as shift.
Conflict in state 392 between rule 284 and token ">> (T_SR)" resolved as shift.
Conflict in state 392 between rule 284 and token '+' resolved as shift.
Conflict in state 392 between rule 284 and token '-' resolved as shift.
Conflict in state 392 between rule 284 and token '.' resolved as shift.
Conflict in state 392 between rule 284 and token '*' resolved as shift.
Conflict in state 392 between rule 284 and token '/' resolved as shift.
Conflict in state 392 between rule 284 and token '%' resolved as shift.
Conflict in state 392 between rule 284 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 393 between rule 286 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 393 between rule 286 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 393 between rule 286 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 393 between rule 286 and token '?' resolved as reduce.
Conflict in state 393 between rule 286 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 393 between rule 286 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 393 between rule 286 and token '|' resolved as reduce.
Conflict in state 393 between rule 286 and token '^' resolved as reduce.
Conflict in state 393 between rule 286 and token '&' resolved as shift.
Conflict in state 393 between rule 286 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 393 between rule 286 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 393 between rule 286 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 393 between rule 286 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 393 between rule 286 and token '<' resolved as shift.
Conflict in state 393 between rule 286 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 393 between rule 286 and token '>' resolved as shift.
Conflict in state 393 between rule 286 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 393 between rule 286 and token "<< (T_SL)" resolved as shift.
Conflict in state 393 between rule 286 and token ">> (T_SR)" resolved as shift.
Conflict in state 393 between rule 286 and token '+' resolved as shift.
Conflict in state 393 between rule 286 and token '-' resolved as shift.
Conflict in state 393 between rule 286 and token '.' resolved as shift.
Conflict in state 393 between rule 286 and token '*' resolved as shift.
Conflict in state 393 between rule 286 and token '/' resolved as shift.
Conflict in state 393 between rule 286 and token '%' resolved as shift.
Conflict in state 393 between rule 286 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 394 between rule 285 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 394 between rule 285 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 394 between rule 285 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 394 between rule 285 and token '?' resolved as reduce.
Conflict in state 394 between rule 285 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 394 between rule 285 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 394 between rule 285 and token '|' resolved as reduce.
Conflict in state 394 between rule 285 and token '^' resolved as reduce.
Conflict in state 394 between rule 285 and token '&' resolved as reduce.
Conflict in state 394 between rule 285 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 394 between rule 285 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 394 between rule 285 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 394 between rule 285 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 394 between rule 285 and token '<' resolved as shift.
Conflict in state 394 between rule 285 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 394 between rule 285 and token '>' resolved as shift.
Conflict in state 394 between rule 285 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 394 between rule 285 and token "<< (T_SL)" resolved as shift.
Conflict in state 394 between rule 285 and token ">> (T_SR)" resolved as shift.
Conflict in state 394 between rule 285 and token '+' resolved as shift.
Conflict in state 394 between rule 285 and token '-' resolved as shift.
Conflict in state 394 between rule 285 and token '.' resolved as shift.
Conflict in state 394 between rule 285 and token '*' resolved as shift.
Conflict in state 394 between rule 285 and token '/' resolved as shift.
Conflict in state 394 between rule 285 and token '%' resolved as shift.
Conflict in state 394 between rule 285 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 395 between rule 301 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 395 between rule 301 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 395 between rule 301 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 395 between rule 301 and token '?' resolved as reduce.
Conflict in state 395 between rule 301 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 395 between rule 301 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 395 between rule 301 and token '|' resolved as reduce.
Conflict in state 395 between rule 301 and token '^' resolved as reduce.
Conflict in state 395 between rule 301 and token '&' resolved as reduce.
Conflict in state 395 between rule 301 and token "== (T_IS_EQUAL)" resolved as an error.
Conflict in state 395 between rule 301 and token "!= (T_IS_NOT_EQUAL)" resolved as an error.
Conflict in state 395 between rule 301 and token "=== (T_IS_IDENTICAL)" resolved as an error.
Conflict in state 395 between rule 301 and token "!== (T_IS_NOT_IDENTICAL)" resolved as an error.
Conflict in state 395 between rule 301 and token '<' resolved as shift.
Conflict in state 395 between rule 301 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 395 between rule 301 and token '>' resolved as shift.
Conflict in state 395 between rule 301 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 395 between rule 301 and token "<< (T_SL)" resolved as shift.
Conflict in state 395 between rule 301 and token ">> (T_SR)" resolved as shift.
Conflict in state 395 between rule 301 and token '+' resolved as shift.
Conflict in state 395 between rule 301 and token '-' resolved as shift.
Conflict in state 395 between rule 301 and token '.' resolved as shift.
Conflict in state 395 between rule 301 and token '*' resolved as shift.
Conflict in state 395 between rule 301 and token '/' resolved as shift.
Conflict in state 395 between rule 301 and token '%' resolved as shift.
Conflict in state 395 between rule 301 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 396 between rule 302 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 396 between rule 302 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 396 between rule 302 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 396 between rule 302 and token '?' resolved as reduce.
Conflict in state 396 between rule 302 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 396 between rule 302 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 396 between rule 302 and token '|' resolved as reduce.
Conflict in state 396 between rule 302 and token '^' resolved as reduce.
Conflict in state 396 between rule 302 and token '&' resolved as reduce.
Conflict in state 396 between rule 302 and token "== (T_IS_EQUAL)" resolved as an error.
Conflict in state 396 between rule 302 and token "!= (T_IS_NOT_EQUAL)" resolved as an error.
Conflict in state 396 between rule 302 and token "=== (T_IS_IDENTICAL)" resolved as an error.
Conflict in state 396 between rule 302 and token "!== (T_IS_NOT_IDENTICAL)" resolved as an error.
Conflict in state 396 between rule 302 and token '<' resolved as shift.
Conflict in state 396 between rule 302 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 396 between rule 302 and token '>' resolved as shift.
Conflict in state 396 between rule 302 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 396 between rule 302 and token "<< (T_SL)" resolved as shift.
Conflict in state 396 between rule 302 and token ">> (T_SR)" resolved as shift.
Conflict in state 396 between rule 302 and token '+' resolved as shift.
Conflict in state 396 between rule 302 and token '-' resolved as shift.
Conflict in state 396 between rule 302 and token '.' resolved as shift.
Conflict in state 396 between rule 302 and token '*' resolved as shift.
Conflict in state 396 between rule 302 and token '/' resolved as shift.
Conflict in state 396 between rule 302 and token '%' resolved as shift.
Conflict in state 396 between rule 302 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 397 between rule 299 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 397 between rule 299 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 397 between rule 299 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 397 between rule 299 and token '?' resolved as reduce.
Conflict in state 397 between rule 299 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 397 between rule 299 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 397 between rule 299 and token '|' resolved as reduce.
Conflict in state 397 between rule 299 and token '^' resolved as reduce.
Conflict in state 397 between rule 299 and token '&' resolved as reduce.
Conflict in state 397 between rule 299 and token "== (T_IS_EQUAL)" resolved as an error.
Conflict in state 397 between rule 299 and token "!= (T_IS_NOT_EQUAL)" resolved as an error.
Conflict in state 397 between rule 299 and token "=== (T_IS_IDENTICAL)" resolved as an error.
Conflict in state 397 between rule 299 and token "!== (T_IS_NOT_IDENTICAL)" resolved as an error.
Conflict in state 397 between rule 299 and token '<' resolved as shift.
Conflict in state 397 between rule 299 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 397 between rule 299 and token '>' resolved as shift.
Conflict in state 397 between rule 299 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 397 between rule 299 and token "<< (T_SL)" resolved as shift.
Conflict in state 397 between rule 299 and token ">> (T_SR)" resolved as shift.
Conflict in state 397 between rule 299 and token '+' resolved as shift.
Conflict in state 397 between rule 299 and token '-' resolved as shift.
Conflict in state 397 between rule 299 and token '.' resolved as shift.
Conflict in state 397 between rule 299 and token '*' resolved as shift.
Conflict in state 397 between rule 299 and token '/' resolved as shift.
Conflict in state 397 between rule 299 and token '%' resolved as shift.
Conflict in state 397 between rule 299 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 398 between rule 300 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 398 between rule 300 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 398 between rule 300 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 398 between rule 300 and token '?' resolved as reduce.
Conflict in state 398 between rule 300 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 398 between rule 300 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 398 between rule 300 and token '|' resolved as reduce.
Conflict in state 398 between rule 300 and token '^' resolved as reduce.
Conflict in state 398 between rule 300 and token '&' resolved as reduce.
Conflict in state 398 between rule 300 and token "== (T_IS_EQUAL)" resolved as an error.
Conflict in state 398 between rule 300 and token "!= (T_IS_NOT_EQUAL)" resolved as an error.
Conflict in state 398 between rule 300 and token "=== (T_IS_IDENTICAL)" resolved as an error.
Conflict in state 398 between rule 300 and token "!== (T_IS_NOT_IDENTICAL)" resolved as an error.
Conflict in state 398 between rule 300 and token '<' resolved as shift.
Conflict in state 398 between rule 300 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 398 between rule 300 and token '>' resolved as shift.
Conflict in state 398 between rule 300 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 398 between rule 300 and token "<< (T_SL)" resolved as shift.
Conflict in state 398 between rule 300 and token ">> (T_SR)" resolved as shift.
Conflict in state 398 between rule 300 and token '+' resolved as shift.
Conflict in state 398 between rule 300 and token '-' resolved as shift.
Conflict in state 398 between rule 300 and token '.' resolved as shift.
Conflict in state 398 between rule 300 and token '*' resolved as shift.
Conflict in state 398 between rule 300 and token '/' resolved as shift.
Conflict in state 398 between rule 300 and token '%' resolved as shift.
Conflict in state 398 between rule 300 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 399 between rule 303 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 399 between rule 303 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 399 between rule 303 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 399 between rule 303 and token '?' resolved as reduce.
Conflict in state 399 between rule 303 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 399 between rule 303 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 399 between rule 303 and token '|' resolved as reduce.
Conflict in state 399 between rule 303 and token '^' resolved as reduce.
Conflict in state 399 between rule 303 and token '&' resolved as reduce.
Conflict in state 399 between rule 303 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 399 between rule 303 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 399 between rule 303 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 399 between rule 303 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 399 between rule 303 and token '<' resolved as an error.
Conflict in state 399 between rule 303 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as an error.
Conflict in state 399 between rule 303 and token '>' resolved as an error.
Conflict in state 399 between rule 303 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as an error.
Conflict in state 399 between rule 303 and token "<< (T_SL)" resolved as shift.
Conflict in state 399 between rule 303 and token ">> (T_SR)" resolved as shift.
Conflict in state 399 between rule 303 and token '+' resolved as shift.
Conflict in state 399 between rule 303 and token '-' resolved as shift.
Conflict in state 399 between rule 303 and token '.' resolved as shift.
Conflict in state 399 between rule 303 and token '*' resolved as shift.
Conflict in state 399 between rule 303 and token '/' resolved as shift.
Conflict in state 399 between rule 303 and token '%' resolved as shift.
Conflict in state 399 between rule 303 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 400 between rule 304 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 400 between rule 304 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 400 between rule 304 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 400 between rule 304 and token '?' resolved as reduce.
Conflict in state 400 between rule 304 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 400 between rule 304 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 400 between rule 304 and token '|' resolved as reduce.
Conflict in state 400 between rule 304 and token '^' resolved as reduce.
Conflict in state 400 between rule 304 and token '&' resolved as reduce.
Conflict in state 400 between rule 304 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 400 between rule 304 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 400 between rule 304 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 400 between rule 304 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 400 between rule 304 and token '<' resolved as an error.
Conflict in state 400 between rule 304 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as an error.
Conflict in state 400 between rule 304 and token '>' resolved as an error.
Conflict in state 400 between rule 304 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as an error.
Conflict in state 400 between rule 304 and token "<< (T_SL)" resolved as shift.
Conflict in state 400 between rule 304 and token ">> (T_SR)" resolved as shift.
Conflict in state 400 between rule 304 and token '+' resolved as shift.
Conflict in state 400 between rule 304 and token '-' resolved as shift.
Conflict in state 400 between rule 304 and token '.' resolved as shift.
Conflict in state 400 between rule 304 and token '*' resolved as shift.
Conflict in state 400 between rule 304 and token '/' resolved as shift.
Conflict in state 400 between rule 304 and token '%' resolved as shift.
Conflict in state 400 between rule 304 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 401 between rule 305 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 401 between rule 305 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 401 between rule 305 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 401 between rule 305 and token '?' resolved as reduce.
Conflict in state 401 between rule 305 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 401 between rule 305 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 401 between rule 305 and token '|' resolved as reduce.
Conflict in state 401 between rule 305 and token '^' resolved as reduce.
Conflict in state 401 between rule 305 and token '&' resolved as reduce.
Conflict in state 401 between rule 305 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 401 between rule 305 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 401 between rule 305 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 401 between rule 305 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 401 between rule 305 and token '<' resolved as an error.
Conflict in state 401 between rule 305 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as an error.
Conflict in state 401 between rule 305 and token '>' resolved as an error.
Conflict in state 401 between rule 305 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as an error.
Conflict in state 401 between rule 305 and token "<< (T_SL)" resolved as shift.
Conflict in state 401 between rule 305 and token ">> (T_SR)" resolved as shift.
Conflict in state 401 between rule 305 and token '+' resolved as shift.
Conflict in state 401 between rule 305 and token '-' resolved as shift.
Conflict in state 401 between rule 305 and token '.' resolved as shift.
Conflict in state 401 between rule 305 and token '*' resolved as shift.
Conflict in state 401 between rule 305 and token '/' resolved as shift.
Conflict in state 401 between rule 305 and token '%' resolved as shift.
Conflict in state 401 between rule 305 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 402 between rule 306 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 402 between rule 306 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 402 between rule 306 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 402 between rule 306 and token '?' resolved as reduce.
Conflict in state 402 between rule 306 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 402 between rule 306 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 402 between rule 306 and token '|' resolved as reduce.
Conflict in state 402 between rule 306 and token '^' resolved as reduce.
Conflict in state 402 between rule 306 and token '&' resolved as reduce.
Conflict in state 402 between rule 306 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 402 between rule 306 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 402 between rule 306 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 402 between rule 306 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 402 between rule 306 and token '<' resolved as an error.
Conflict in state 402 between rule 306 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as an error.
Conflict in state 402 between rule 306 and token '>' resolved as an error.
Conflict in state 402 between rule 306 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as an error.
Conflict in state 402 between rule 306 and token "<< (T_SL)" resolved as shift.
Conflict in state 402 between rule 306 and token ">> (T_SR)" resolved as shift.
Conflict in state 402 between rule 306 and token '+' resolved as shift.
Conflict in state 402 between rule 306 and token '-' resolved as shift.
Conflict in state 402 between rule 306 and token '.' resolved as shift.
Conflict in state 402 between rule 306 and token '*' resolved as shift.
Conflict in state 402 between rule 306 and token '/' resolved as shift.
Conflict in state 402 between rule 306 and token '%' resolved as shift.
Conflict in state 402 between rule 306 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 403 between rule 293 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 403 between rule 293 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 403 between rule 293 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 403 between rule 293 and token '?' resolved as reduce.
Conflict in state 403 between rule 293 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 403 between rule 293 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 403 between rule 293 and token '|' resolved as reduce.
Conflict in state 403 between rule 293 and token '^' resolved as reduce.
Conflict in state 403 between rule 293 and token '&' resolved as reduce.
Conflict in state 403 between rule 293 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 403 between rule 293 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 403 between rule 293 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 403 between rule 293 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 403 between rule 293 and token '<' resolved as reduce.
Conflict in state 403 between rule 293 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 403 between rule 293 and token '>' resolved as reduce.
Conflict in state 403 between rule 293 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 403 between rule 293 and token "<< (T_SL)" resolved as reduce.
Conflict in state 403 between rule 293 and token ">> (T_SR)" resolved as reduce.
Conflict in state 403 between rule 293 and token '+' resolved as shift.
Conflict in state 403 between rule 293 and token '-' resolved as shift.
Conflict in state 403 between rule 293 and token '.' resolved as shift.
Conflict in state 403 between rule 293 and token '*' resolved as shift.
Conflict in state 403 between rule 293 and token '/' resolved as shift.
Conflict in state 403 between rule 293 and token '%' resolved as shift.
Conflict in state 403 between rule 293 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 404 between rule 294 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 404 between rule 294 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 404 between rule 294 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 404 between rule 294 and token '?' resolved as reduce.
Conflict in state 404 between rule 294 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 404 between rule 294 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 404 between rule 294 and token '|' resolved as reduce.
Conflict in state 404 between rule 294 and token '^' resolved as reduce.
Conflict in state 404 between rule 294 and token '&' resolved as reduce.
Conflict in state 404 between rule 294 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 404 between rule 294 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 404 between rule 294 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 404 between rule 294 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 404 between rule 294 and token '<' resolved as reduce.
Conflict in state 404 between rule 294 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 404 between rule 294 and token '>' resolved as reduce.
Conflict in state 404 between rule 294 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 404 between rule 294 and token "<< (T_SL)" resolved as reduce.
Conflict in state 404 between rule 294 and token ">> (T_SR)" resolved as reduce.
Conflict in state 404 between rule 294 and token '+' resolved as shift.
Conflict in state 404 between rule 294 and token '-' resolved as shift.
Conflict in state 404 between rule 294 and token '.' resolved as shift.
Conflict in state 404 between rule 294 and token '*' resolved as shift.
Conflict in state 404 between rule 294 and token '/' resolved as shift.
Conflict in state 404 between rule 294 and token '%' resolved as shift.
Conflict in state 404 between rule 294 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 405 between rule 288 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 405 between rule 288 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 405 between rule 288 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 405 between rule 288 and token '?' resolved as reduce.
Conflict in state 405 between rule 288 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 405 between rule 288 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 405 between rule 288 and token '|' resolved as reduce.
Conflict in state 405 between rule 288 and token '^' resolved as reduce.
Conflict in state 405 between rule 288 and token '&' resolved as reduce.
Conflict in state 405 between rule 288 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 405 between rule 288 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 405 between rule 288 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 405 between rule 288 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 405 between rule 288 and token '<' resolved as reduce.
Conflict in state 405 between rule 288 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 405 between rule 288 and token '>' resolved as reduce.
Conflict in state 405 between rule 288 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 405 between rule 288 and token "<< (T_SL)" resolved as reduce.
Conflict in state 405 between rule 288 and token ">> (T_SR)" resolved as reduce.
Conflict in state 405 between rule 288 and token '+' resolved as reduce.
Conflict in state 405 between rule 288 and token '-' resolved as reduce.
Conflict in state 405 between rule 288 and token '.' resolved as reduce.
Conflict in state 405 between rule 288 and token '*' resolved as shift.
Conflict in state 405 between rule 288 and token '/' resolved as shift.
Conflict in state 405 between rule 288 and token '%' resolved as shift.
Conflict in state 405 between rule 288 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 406 between rule 289 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 406 between rule 289 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 406 between rule 289 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 406 between rule 289 and token '?' resolved as reduce.
Conflict in state 406 between rule 289 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 406 between rule 289 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 406 between rule 289 and token '|' resolved as reduce.
Conflict in state 406 between rule 289 and token '^' resolved as reduce.
Conflict in state 406 between rule 289 and token '&' resolved as reduce.
Conflict in state 406 between rule 289 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 406 between rule 289 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 406 between rule 289 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 406 between rule 289 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 406 between rule 289 and token '<' resolved as reduce.
Conflict in state 406 between rule 289 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 406 between rule 289 and token '>' resolved as reduce.
Conflict in state 406 between rule 289 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 406 between rule 289 and token "<< (T_SL)" resolved as reduce.
Conflict in state 406 between rule 289 and token ">> (T_SR)" resolved as reduce.
Conflict in state 406 between rule 289 and token '+' resolved as reduce.
Conflict in state 406 between rule 289 and token '-' resolved as reduce.
Conflict in state 406 between rule 289 and token '.' resolved as reduce.
Conflict in state 406 between rule 289 and token '*' resolved as shift.
Conflict in state 406 between rule 289 and token '/' resolved as shift.
Conflict in state 406 between rule 289 and token '%' resolved as shift.
Conflict in state 406 between rule 289 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 407 between rule 287 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 407 between rule 287 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 407 between rule 287 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 407 between rule 287 and token '?' resolved as reduce.
Conflict in state 407 between rule 287 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 407 between rule 287 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 407 between rule 287 and token '|' resolved as reduce.
Conflict in state 407 between rule 287 and token '^' resolved as reduce.
Conflict in state 407 between rule 287 and token '&' resolved as reduce.
Conflict in state 407 between rule 287 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 407 between rule 287 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 407 between rule 287 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 407 between rule 287 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 407 between rule 287 and token '<' resolved as reduce.
Conflict in state 407 between rule 287 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 407 between rule 287 and token '>' resolved as reduce.
Conflict in state 407 between rule 287 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 407 between rule 287 and token "<< (T_SL)" resolved as reduce.
Conflict in state 407 between rule 287 and token ">> (T_SR)" resolved as reduce.
Conflict in state 407 between rule 287 and token '+' resolved as reduce.
Conflict in state 407 between rule 287 and token '-' resolved as reduce.
Conflict in state 407 between rule 287 and token '.' resolved as reduce.
Conflict in state 407 between rule 287 and token '*' resolved as shift.
Conflict in state 407 between rule 287 and token '/' resolved as shift.
Conflict in state 407 between rule 287 and token '%' resolved as shift.
Conflict in state 407 between rule 287 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 408 between rule 290 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 408 between rule 290 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 408 between rule 290 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 408 between rule 290 and token '?' resolved as reduce.
Conflict in state 408 between rule 290 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 408 between rule 290 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 408 between rule 290 and token '|' resolved as reduce.
Conflict in state 408 between rule 290 and token '^' resolved as reduce.
Conflict in state 408 between rule 290 and token '&' resolved as reduce.
Conflict in state 408 between rule 290 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 408 between rule 290 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 408 between rule 290 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 408 between rule 290 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 408 between rule 290 and token '<' resolved as reduce.
Conflict in state 408 between rule 290 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 408 between rule 290 and token '>' resolved as reduce.
Conflict in state 408 between rule 290 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 408 between rule 290 and token "<< (T_SL)" resolved as reduce.
Conflict in state 408 between rule 290 and token ">> (T_SR)" resolved as reduce.
Conflict in state 408 between rule 290 and token '+' resolved as reduce.
Conflict in state 408 between rule 290 and token '-' resolved as reduce.
Conflict in state 408 between rule 290 and token '.' resolved as reduce.
Conflict in state 408 between rule 290 and token '*' resolved as reduce.
Conflict in state 408 between rule 290 and token '/' resolved as reduce.
Conflict in state 408 between rule 290 and token '%' resolved as reduce.
Conflict in state 408 between rule 290 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 409 between rule 291 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 409 between rule 291 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 409 between rule 291 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 409 between rule 291 and token '?' resolved as reduce.
Conflict in state 409 between rule 291 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 409 between rule 291 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 409 between rule 291 and token '|' resolved as reduce.
Conflict in state 409 between rule 291 and token '^' resolved as reduce.
Conflict in state 409 between rule 291 and token '&' resolved as reduce.
Conflict in state 409 between rule 291 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 409 between rule 291 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 409 between rule 291 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 409 between rule 291 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 409 between rule 291 and token '<' resolved as reduce.
Conflict in state 409 between rule 291 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 409 between rule 291 and token '>' resolved as reduce.
Conflict in state 409 between rule 291 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 409 between rule 291 and token "<< (T_SL)" resolved as reduce.
Conflict in state 409 between rule 291 and token ">> (T_SR)" resolved as reduce.
Conflict in state 409 between rule 291 and token '+' resolved as reduce.
Conflict in state 409 between rule 291 and token '-' resolved as reduce.
Conflict in state 409 between rule 291 and token '.' resolved as reduce.
Conflict in state 409 between rule 291 and token '*' resolved as reduce.
Conflict in state 409 between rule 291 and token '/' resolved as reduce.
Conflict in state 409 between rule 291 and token '%' resolved as reduce.
Conflict in state 409 between rule 291 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 410 between rule 292 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 410 between rule 292 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 410 between rule 292 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 410 between rule 292 and token '?' resolved as reduce.
Conflict in state 410 between rule 292 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 410 between rule 292 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 410 between rule 292 and token '|' resolved as reduce.
Conflict in state 410 between rule 292 and token '^' resolved as reduce.
Conflict in state 410 between rule 292 and token '&' resolved as reduce.
Conflict in state 410 between rule 292 and token "== (T_IS_EQUAL)" resolved as reduce.
Conflict in state 410 between rule 292 and token "!= (T_IS_NOT_EQUAL)" resolved as reduce.
Conflict in state 410 between rule 292 and token "=== (T_IS_IDENTICAL)" resolved as reduce.
Conflict in state 410 between rule 292 and token "!== (T_IS_NOT_IDENTICAL)" resolved as reduce.
Conflict in state 410 between rule 292 and token '<' resolved as reduce.
Conflict in state 410 between rule 292 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as reduce.
Conflict in state 410 between rule 292 and token '>' resolved as reduce.
Conflict in state 410 between rule 292 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as reduce.
Conflict in state 410 between rule 292 and token "<< (T_SL)" resolved as reduce.
Conflict in state 410 between rule 292 and token ">> (T_SR)" resolved as reduce.
Conflict in state 410 between rule 292 and token '+' resolved as reduce.
Conflict in state 410 between rule 292 and token '-' resolved as reduce.
Conflict in state 410 between rule 292 and token '.' resolved as reduce.
Conflict in state 410 between rule 292 and token '*' resolved as reduce.
Conflict in state 410 between rule 292 and token '/' resolved as reduce.
Conflict in state 410 between rule 292 and token '%' resolved as reduce.
Conflict in state 410 between rule 292 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 413 between rule 255 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 413 between rule 255 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 413 between rule 255 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 413 between rule 255 and token '?' resolved as shift.
Conflict in state 413 between rule 255 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 413 between rule 255 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 413 between rule 255 and token '|' resolved as shift.
Conflict in state 413 between rule 255 and token '^' resolved as shift.
Conflict in state 413 between rule 255 and token '&' resolved as shift.
Conflict in state 413 between rule 255 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 413 between rule 255 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 413 between rule 255 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 413 between rule 255 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 413 between rule 255 and token '<' resolved as shift.
Conflict in state 413 between rule 255 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 413 between rule 255 and token '>' resolved as shift.
Conflict in state 413 between rule 255 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 413 between rule 255 and token "<< (T_SL)" resolved as shift.
Conflict in state 413 between rule 255 and token ">> (T_SR)" resolved as shift.
Conflict in state 413 between rule 255 and token '+' resolved as shift.
Conflict in state 413 between rule 255 and token '-' resolved as shift.
Conflict in state 413 between rule 255 and token '.' resolved as shift.
Conflict in state 413 between rule 255 and token '*' resolved as shift.
Conflict in state 413 between rule 255 and token '/' resolved as shift.
Conflict in state 413 between rule 255 and token '%' resolved as shift.
Conflict in state 413 between rule 255 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 414 between rule 260 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 414 between rule 260 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 414 between rule 260 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 414 between rule 260 and token '?' resolved as shift.
Conflict in state 414 between rule 260 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 414 between rule 260 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 414 between rule 260 and token '|' resolved as shift.
Conflict in state 414 between rule 260 and token '^' resolved as shift.
Conflict in state 414 between rule 260 and token '&' resolved as shift.
Conflict in state 414 between rule 260 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 414 between rule 260 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 414 between rule 260 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 414 between rule 260 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 414 between rule 260 and token '<' resolved as shift.
Conflict in state 414 between rule 260 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 414 between rule 260 and token '>' resolved as shift.
Conflict in state 414 between rule 260 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 414 between rule 260 and token "<< (T_SL)" resolved as shift.
Conflict in state 414 between rule 260 and token ">> (T_SR)" resolved as shift.
Conflict in state 414 between rule 260 and token '+' resolved as shift.
Conflict in state 414 between rule 260 and token '-' resolved as shift.
Conflict in state 414 between rule 260 and token '.' resolved as shift.
Conflict in state 414 between rule 260 and token '*' resolved as shift.
Conflict in state 414 between rule 260 and token '/' resolved as shift.
Conflict in state 414 between rule 260 and token '%' resolved as shift.
Conflict in state 414 between rule 260 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 415 between rule 261 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 415 between rule 261 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 415 between rule 261 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 415 between rule 261 and token '?' resolved as shift.
Conflict in state 415 between rule 261 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 415 between rule 261 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 415 between rule 261 and token '|' resolved as shift.
Conflict in state 415 between rule 261 and token '^' resolved as shift.
Conflict in state 415 between rule 261 and token '&' resolved as shift.
Conflict in state 415 between rule 261 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 415 between rule 261 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 415 between rule 261 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 415 between rule 261 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 415 between rule 261 and token '<' resolved as shift.
Conflict in state 415 between rule 261 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 415 between rule 261 and token '>' resolved as shift.
Conflict in state 415 between rule 261 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 415 between rule 261 and token "<< (T_SL)" resolved as shift.
Conflict in state 415 between rule 261 and token ">> (T_SR)" resolved as shift.
Conflict in state 415 between rule 261 and token '+' resolved as shift.
Conflict in state 415 between rule 261 and token '-' resolved as shift.
Conflict in state 415 between rule 261 and token '.' resolved as shift.
Conflict in state 415 between rule 261 and token '*' resolved as shift.
Conflict in state 415 between rule 261 and token '/' resolved as shift.
Conflict in state 415 between rule 261 and token '%' resolved as shift.
Conflict in state 415 between rule 261 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 416 between rule 262 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 416 between rule 262 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 416 between rule 262 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 416 between rule 262 and token '?' resolved as shift.
Conflict in state 416 between rule 262 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 416 between rule 262 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 416 between rule 262 and token '|' resolved as shift.
Conflict in state 416 between rule 262 and token '^' resolved as shift.
Conflict in state 416 between rule 262 and token '&' resolved as shift.
Conflict in state 416 between rule 262 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 416 between rule 262 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 416 between rule 262 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 416 between rule 262 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 416 between rule 262 and token '<' resolved as shift.
Conflict in state 416 between rule 262 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 416 between rule 262 and token '>' resolved as shift.
Conflict in state 416 between rule 262 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 416 between rule 262 and token "<< (T_SL)" resolved as shift.
Conflict in state 416 between rule 262 and token ">> (T_SR)" resolved as shift.
Conflict in state 416 between rule 262 and token '+' resolved as shift.
Conflict in state 416 between rule 262 and token '-' resolved as shift.
Conflict in state 416 between rule 262 and token '.' resolved as shift.
Conflict in state 416 between rule 262 and token '*' resolved as shift.
Conflict in state 416 between rule 262 and token '/' resolved as shift.
Conflict in state 416 between rule 262 and token '%' resolved as shift.
Conflict in state 416 between rule 262 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 417 between rule 263 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 417 between rule 263 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 417 between rule 263 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 417 between rule 263 and token '?' resolved as shift.
Conflict in state 417 between rule 263 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 417 between rule 263 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 417 between rule 263 and token '|' resolved as shift.
Conflict in state 417 between rule 263 and token '^' resolved as shift.
Conflict in state 417 between rule 263 and token '&' resolved as shift.
Conflict in state 417 between rule 263 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 417 between rule 263 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 417 between rule 263 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 417 between rule 263 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 417 between rule 263 and token '<' resolved as shift.
Conflict in state 417 between rule 263 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 417 between rule 263 and token '>' resolved as shift.
Conflict in state 417 between rule 263 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 417 between rule 263 and token "<< (T_SL)" resolved as shift.
Conflict in state 417 between rule 263 and token ">> (T_SR)" resolved as shift.
Conflict in state 417 between rule 263 and token '+' resolved as shift.
Conflict in state 417 between rule 263 and token '-' resolved as shift.
Conflict in state 417 between rule 263 and token '.' resolved as shift.
Conflict in state 417 between rule 263 and token '*' resolved as shift.
Conflict in state 417 between rule 263 and token '/' resolved as shift.
Conflict in state 417 between rule 263 and token '%' resolved as shift.
Conflict in state 417 between rule 263 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 418 between rule 264 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 418 between rule 264 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 418 between rule 264 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 418 between rule 264 and token '?' resolved as shift.
Conflict in state 418 between rule 264 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 418 between rule 264 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 418 between rule 264 and token '|' resolved as shift.
Conflict in state 418 between rule 264 and token '^' resolved as shift.
Conflict in state 418 between rule 264 and token '&' resolved as shift.
Conflict in state 418 between rule 264 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 418 between rule 264 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 418 between rule 264 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 418 between rule 264 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 418 between rule 264 and token '<' resolved as shift.
Conflict in state 418 between rule 264 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 418 between rule 264 and token '>' resolved as shift.
Conflict in state 418 between rule 264 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 418 between rule 264 and token "<< (T_SL)" resolved as shift.
Conflict in state 418 between rule 264 and token ">> (T_SR)" resolved as shift.
Conflict in state 418 between rule 264 and token '+' resolved as shift.
Conflict in state 418 between rule 264 and token '-' resolved as shift.
Conflict in state 418 between rule 264 and token '.' resolved as shift.
Conflict in state 418 between rule 264 and token '*' resolved as shift.
Conflict in state 418 between rule 264 and token '/' resolved as shift.
Conflict in state 418 between rule 264 and token '%' resolved as shift.
Conflict in state 418 between rule 264 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 419 between rule 265 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 419 between rule 265 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 419 between rule 265 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 419 between rule 265 and token '?' resolved as shift.
Conflict in state 419 between rule 265 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 419 between rule 265 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 419 between rule 265 and token '|' resolved as shift.
Conflict in state 419 between rule 265 and token '^' resolved as shift.
Conflict in state 419 between rule 265 and token '&' resolved as shift.
Conflict in state 419 between rule 265 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 419 between rule 265 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 419 between rule 265 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 419 between rule 265 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 419 between rule 265 and token '<' resolved as shift.
Conflict in state 419 between rule 265 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 419 between rule 265 and token '>' resolved as shift.
Conflict in state 419 between rule 265 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 419 between rule 265 and token "<< (T_SL)" resolved as shift.
Conflict in state 419 between rule 265 and token ">> (T_SR)" resolved as shift.
Conflict in state 419 between rule 265 and token '+' resolved as shift.
Conflict in state 419 between rule 265 and token '-' resolved as shift.
Conflict in state 419 between rule 265 and token '.' resolved as shift.
Conflict in state 419 between rule 265 and token '*' resolved as shift.
Conflict in state 419 between rule 265 and token '/' resolved as shift.
Conflict in state 419 between rule 265 and token '%' resolved as shift.
Conflict in state 419 between rule 265 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 420 between rule 266 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 420 between rule 266 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 420 between rule 266 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 420 between rule 266 and token '?' resolved as shift.
Conflict in state 420 between rule 266 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 420 between rule 266 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 420 between rule 266 and token '|' resolved as shift.
Conflict in state 420 between rule 266 and token '^' resolved as shift.
Conflict in state 420 between rule 266 and token '&' resolved as shift.
Conflict in state 420 between rule 266 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 420 between rule 266 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 420 between rule 266 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 420 between rule 266 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 420 between rule 266 and token '<' resolved as shift.
Conflict in state 420 between rule 266 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 420 between rule 266 and token '>' resolved as shift.
Conflict in state 420 between rule 266 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 420 between rule 266 and token "<< (T_SL)" resolved as shift.
Conflict in state 420 between rule 266 and token ">> (T_SR)" resolved as shift.
Conflict in state 420 between rule 266 and token '+' resolved as shift.
Conflict in state 420 between rule 266 and token '-' resolved as shift.
Conflict in state 420 between rule 266 and token '.' resolved as shift.
Conflict in state 420 between rule 266 and token '*' resolved as shift.
Conflict in state 420 between rule 266 and token '/' resolved as shift.
Conflict in state 420 between rule 266 and token '%' resolved as shift.
Conflict in state 420 between rule 266 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 421 between rule 267 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 421 between rule 267 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 421 between rule 267 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 421 between rule 267 and token '?' resolved as shift.
Conflict in state 421 between rule 267 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 421 between rule 267 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 421 between rule 267 and token '|' resolved as shift.
Conflict in state 421 between rule 267 and token '^' resolved as shift.
Conflict in state 421 between rule 267 and token '&' resolved as shift.
Conflict in state 421 between rule 267 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 421 between rule 267 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 421 between rule 267 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 421 between rule 267 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 421 between rule 267 and token '<' resolved as shift.
Conflict in state 421 between rule 267 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 421 between rule 267 and token '>' resolved as shift.
Conflict in state 421 between rule 267 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 421 between rule 267 and token "<< (T_SL)" resolved as shift.
Conflict in state 421 between rule 267 and token ">> (T_SR)" resolved as shift.
Conflict in state 421 between rule 267 and token '+' resolved as shift.
Conflict in state 421 between rule 267 and token '-' resolved as shift.
Conflict in state 421 between rule 267 and token '.' resolved as shift.
Conflict in state 421 between rule 267 and token '*' resolved as shift.
Conflict in state 421 between rule 267 and token '/' resolved as shift.
Conflict in state 421 between rule 267 and token '%' resolved as shift.
Conflict in state 421 between rule 267 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 422 between rule 268 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 422 between rule 268 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 422 between rule 268 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 422 between rule 268 and token '?' resolved as shift.
Conflict in state 422 between rule 268 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 422 between rule 268 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 422 between rule 268 and token '|' resolved as shift.
Conflict in state 422 between rule 268 and token '^' resolved as shift.
Conflict in state 422 between rule 268 and token '&' resolved as shift.
Conflict in state 422 between rule 268 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 422 between rule 268 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 422 between rule 268 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 422 between rule 268 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 422 between rule 268 and token '<' resolved as shift.
Conflict in state 422 between rule 268 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 422 between rule 268 and token '>' resolved as shift.
Conflict in state 422 between rule 268 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 422 between rule 268 and token "<< (T_SL)" resolved as shift.
Conflict in state 422 between rule 268 and token ">> (T_SR)" resolved as shift.
Conflict in state 422 between rule 268 and token '+' resolved as shift.
Conflict in state 422 between rule 268 and token '-' resolved as shift.
Conflict in state 422 between rule 268 and token '.' resolved as shift.
Conflict in state 422 between rule 268 and token '*' resolved as shift.
Conflict in state 422 between rule 268 and token '/' resolved as shift.
Conflict in state 422 between rule 268 and token '%' resolved as shift.
Conflict in state 422 between rule 268 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 423 between rule 269 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 423 between rule 269 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 423 between rule 269 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 423 between rule 269 and token '?' resolved as shift.
Conflict in state 423 between rule 269 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 423 between rule 269 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 423 between rule 269 and token '|' resolved as shift.
Conflict in state 423 between rule 269 and token '^' resolved as shift.
Conflict in state 423 between rule 269 and token '&' resolved as shift.
Conflict in state 423 between rule 269 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 423 between rule 269 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 423 between rule 269 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 423 between rule 269 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 423 between rule 269 and token '<' resolved as shift.
Conflict in state 423 between rule 269 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 423 between rule 269 and token '>' resolved as shift.
Conflict in state 423 between rule 269 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 423 between rule 269 and token "<< (T_SL)" resolved as shift.
Conflict in state 423 between rule 269 and token ">> (T_SR)" resolved as shift.
Conflict in state 423 between rule 269 and token '+' resolved as shift.
Conflict in state 423 between rule 269 and token '-' resolved as shift.
Conflict in state 423 between rule 269 and token '.' resolved as shift.
Conflict in state 423 between rule 269 and token '*' resolved as shift.
Conflict in state 423 between rule 269 and token '/' resolved as shift.
Conflict in state 423 between rule 269 and token '%' resolved as shift.
Conflict in state 423 between rule 269 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 424 between rule 270 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 424 between rule 270 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 424 between rule 270 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 424 between rule 270 and token '?' resolved as shift.
Conflict in state 424 between rule 270 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 424 between rule 270 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 424 between rule 270 and token '|' resolved as shift.
Conflict in state 424 between rule 270 and token '^' resolved as shift.
Conflict in state 424 between rule 270 and token '&' resolved as shift.
Conflict in state 424 between rule 270 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 424 between rule 270 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 424 between rule 270 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 424 between rule 270 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 424 between rule 270 and token '<' resolved as shift.
Conflict in state 424 between rule 270 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 424 between rule 270 and token '>' resolved as shift.
Conflict in state 424 between rule 270 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 424 between rule 270 and token "<< (T_SL)" resolved as shift.
Conflict in state 424 between rule 270 and token ">> (T_SR)" resolved as shift.
Conflict in state 424 between rule 270 and token '+' resolved as shift.
Conflict in state 424 between rule 270 and token '-' resolved as shift.
Conflict in state 424 between rule 270 and token '.' resolved as shift.
Conflict in state 424 between rule 270 and token '*' resolved as shift.
Conflict in state 424 between rule 270 and token '/' resolved as shift.
Conflict in state 424 between rule 270 and token '%' resolved as shift.
Conflict in state 424 between rule 270 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 528 between rule 280 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 528 between rule 280 and token "xor (T_LOGICAL_XOR)" resolved as shift.
Conflict in state 528 between rule 280 and token "and (T_LOGICAL_AND)" resolved as shift.
Conflict in state 528 between rule 280 and token '?' resolved as shift.
Conflict in state 528 between rule 280 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 528 between rule 280 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 528 between rule 280 and token '|' resolved as shift.
Conflict in state 528 between rule 280 and token '^' resolved as shift.
Conflict in state 528 between rule 280 and token '&' resolved as shift.
Conflict in state 528 between rule 280 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 528 between rule 280 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 528 between rule 280 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 528 between rule 280 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 528 between rule 280 and token '<' resolved as shift.
Conflict in state 528 between rule 280 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 528 between rule 280 and token '>' resolved as shift.
Conflict in state 528 between rule 280 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 528 between rule 280 and token "<< (T_SL)" resolved as shift.
Conflict in state 528 between rule 280 and token ">> (T_SR)" resolved as shift.
Conflict in state 528 between rule 280 and token '+' resolved as shift.
Conflict in state 528 between rule 280 and token '-' resolved as shift.
Conflict in state 528 between rule 280 and token '.' resolved as shift.
Conflict in state 528 between rule 280 and token '*' resolved as shift.
Conflict in state 528 between rule 280 and token '/' resolved as shift.
Conflict in state 528 between rule 280 and token '%' resolved as shift.
Conflict in state 528 between rule 280 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 529 between rule 282 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 529 between rule 282 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 529 between rule 282 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 529 between rule 282 and token '?' resolved as shift.
Conflict in state 529 between rule 282 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 529 between rule 282 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 529 between rule 282 and token '|' resolved as shift.
Conflict in state 529 between rule 282 and token '^' resolved as shift.
Conflict in state 529 between rule 282 and token '&' resolved as shift.
Conflict in state 529 between rule 282 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 529 between rule 282 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 529 between rule 282 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 529 between rule 282 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 529 between rule 282 and token '<' resolved as shift.
Conflict in state 529 between rule 282 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 529 between rule 282 and token '>' resolved as shift.
Conflict in state 529 between rule 282 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 529 between rule 282 and token "<< (T_SL)" resolved as shift.
Conflict in state 529 between rule 282 and token ">> (T_SR)" resolved as shift.
Conflict in state 529 between rule 282 and token '+' resolved as shift.
Conflict in state 529 between rule 282 and token '-' resolved as shift.
Conflict in state 529 between rule 282 and token '.' resolved as shift.
Conflict in state 529 between rule 282 and token '*' resolved as shift.
Conflict in state 529 between rule 282 and token '/' resolved as shift.
Conflict in state 529 between rule 282 and token '%' resolved as shift.
Conflict in state 529 between rule 282 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 532 between rule 276 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 532 between rule 276 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 532 between rule 276 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 532 between rule 276 and token '?' resolved as reduce.
Conflict in state 532 between rule 276 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 532 between rule 276 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 532 between rule 276 and token '|' resolved as shift.
Conflict in state 532 between rule 276 and token '^' resolved as shift.
Conflict in state 532 between rule 276 and token '&' resolved as shift.
Conflict in state 532 between rule 276 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 532 between rule 276 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 532 between rule 276 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 532 between rule 276 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 532 between rule 276 and token '<' resolved as shift.
Conflict in state 532 between rule 276 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 532 between rule 276 and token '>' resolved as shift.
Conflict in state 532 between rule 276 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 532 between rule 276 and token "<< (T_SL)" resolved as shift.
Conflict in state 532 between rule 276 and token ">> (T_SR)" resolved as shift.
Conflict in state 532 between rule 276 and token '+' resolved as shift.
Conflict in state 532 between rule 276 and token '-' resolved as shift.
Conflict in state 532 between rule 276 and token '.' resolved as shift.
Conflict in state 532 between rule 276 and token '*' resolved as shift.
Conflict in state 532 between rule 276 and token '/' resolved as shift.
Conflict in state 532 between rule 276 and token '%' resolved as shift.
Conflict in state 532 between rule 276 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 533 between rule 278 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 533 between rule 278 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 533 between rule 278 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 533 between rule 278 and token '?' resolved as reduce.
Conflict in state 533 between rule 278 and token "|| (T_BOOLEAN_OR)" resolved as reduce.
Conflict in state 533 between rule 278 and token "&& (T_BOOLEAN_AND)" resolved as reduce.
Conflict in state 533 between rule 278 and token '|' resolved as shift.
Conflict in state 533 between rule 278 and token '^' resolved as shift.
Conflict in state 533 between rule 278 and token '&' resolved as shift.
Conflict in state 533 between rule 278 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 533 between rule 278 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 533 between rule 278 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 533 between rule 278 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 533 between rule 278 and token '<' resolved as shift.
Conflict in state 533 between rule 278 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 533 between rule 278 and token '>' resolved as shift.
Conflict in state 533 between rule 278 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 533 between rule 278 and token "<< (T_SL)" resolved as shift.
Conflict in state 533 between rule 278 and token ">> (T_SR)" resolved as shift.
Conflict in state 533 between rule 278 and token '+' resolved as shift.
Conflict in state 533 between rule 278 and token '-' resolved as shift.
Conflict in state 533 between rule 278 and token '.' resolved as shift.
Conflict in state 533 between rule 278 and token '*' resolved as shift.
Conflict in state 533 between rule 278 and token '/' resolved as shift.
Conflict in state 533 between rule 278 and token '%' resolved as shift.
Conflict in state 533 between rule 278 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 618 between rule 316 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 618 between rule 316 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 618 between rule 316 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 618 between rule 316 and token '?' resolved as reduce.
Conflict in state 618 between rule 316 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 618 between rule 316 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 618 between rule 316 and token '|' resolved as shift.
Conflict in state 618 between rule 316 and token '^' resolved as shift.
Conflict in state 618 between rule 316 and token '&' resolved as shift.
Conflict in state 618 between rule 316 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 618 between rule 316 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 618 between rule 316 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 618 between rule 316 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 618 between rule 316 and token '<' resolved as shift.
Conflict in state 618 between rule 316 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 618 between rule 316 and token '>' resolved as shift.
Conflict in state 618 between rule 316 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 618 between rule 316 and token "<< (T_SL)" resolved as shift.
Conflict in state 618 between rule 316 and token ">> (T_SR)" resolved as shift.
Conflict in state 618 between rule 316 and token '+' resolved as shift.
Conflict in state 618 between rule 316 and token '-' resolved as shift.
Conflict in state 618 between rule 316 and token '.' resolved as shift.
Conflict in state 618 between rule 316 and token '*' resolved as shift.
Conflict in state 618 between rule 316 and token '/' resolved as shift.
Conflict in state 618 between rule 316 and token '%' resolved as shift.
Conflict in state 618 between rule 316 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 726 between rule 254 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 726 between rule 254 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 726 between rule 254 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 726 between rule 254 and token '?' resolved as shift.
Conflict in state 726 between rule 254 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 726 between rule 254 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 726 between rule 254 and token '|' resolved as shift.
Conflict in state 726 between rule 254 and token '^' resolved as shift.
Conflict in state 726 between rule 254 and token '&' resolved as shift.
Conflict in state 726 between rule 254 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 726 between rule 254 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 726 between rule 254 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 726 between rule 254 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 726 between rule 254 and token '<' resolved as shift.
Conflict in state 726 between rule 254 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 726 between rule 254 and token '>' resolved as shift.
Conflict in state 726 between rule 254 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 726 between rule 254 and token "<< (T_SL)" resolved as shift.
Conflict in state 726 between rule 254 and token ">> (T_SR)" resolved as shift.
Conflict in state 726 between rule 254 and token '+' resolved as shift.
Conflict in state 726 between rule 254 and token '-' resolved as shift.
Conflict in state 726 between rule 254 and token '.' resolved as shift.
Conflict in state 726 between rule 254 and token '*' resolved as shift.
Conflict in state 726 between rule 254 and token '/' resolved as shift.
Conflict in state 726 between rule 254 and token '%' resolved as shift.
Conflict in state 726 between rule 254 and token "instanceof (T_INSTANCEOF)" resolved as shift.
Conflict in state 763 between rule 314 and token "or (T_LOGICAL_OR)" resolved as reduce.
Conflict in state 763 between rule 314 and token "xor (T_LOGICAL_XOR)" resolved as reduce.
Conflict in state 763 between rule 314 and token "and (T_LOGICAL_AND)" resolved as reduce.
Conflict in state 763 between rule 314 and token '?' resolved as reduce.
Conflict in state 763 between rule 314 and token "|| (T_BOOLEAN_OR)" resolved as shift.
Conflict in state 763 between rule 314 and token "&& (T_BOOLEAN_AND)" resolved as shift.
Conflict in state 763 between rule 314 and token '|' resolved as shift.
Conflict in state 763 between rule 314 and token '^' resolved as shift.
Conflict in state 763 between rule 314 and token '&' resolved as shift.
Conflict in state 763 between rule 314 and token "== (T_IS_EQUAL)" resolved as shift.
Conflict in state 763 between rule 314 and token "!= (T_IS_NOT_EQUAL)" resolved as shift.
Conflict in state 763 between rule 314 and token "=== (T_IS_IDENTICAL)" resolved as shift.
Conflict in state 763 between rule 314 and token "!== (T_IS_NOT_IDENTICAL)" resolved as shift.
Conflict in state 763 between rule 314 and token '<' resolved as shift.
Conflict in state 763 between rule 314 and token "<= (T_IS_SMALLER_OR_EQUAL)" resolved as shift.
Conflict in state 763 between rule 314 and token '>' resolved as shift.
Conflict in state 763 between rule 314 and token ">= (T_IS_GREATER_OR_EQUAL)" resolved as shift.
Conflict in state 763 between rule 314 and token "<< (T_SL)" resolved as shift.
Conflict in state 763 between rule 314 and token ">> (T_SR)" resolved as shift.
Conflict in state 763 between rule 314 and token '+' resolved as shift.
Conflict in state 763 between rule 314 and token '-' resolved as shift.
Conflict in state 763 between rule 314 and token '.' resolved as shift.
Conflict in state 763 between rule 314 and token '*' resolved as shift.
Conflict in state 763 between rule 314 and token '/' resolved as shift.
Conflict in state 763 between rule 314 and token '%' resolved as shift.
Conflict in state 763 between rule 314 and token "instanceof (T_INSTANCEOF)" resolved as shift.
State 216 contains 1 shift/reduce conflict.
State 776 contains 2 shift/reduce conflicts.

Grammar
rule 1    start -> top_statement_list
rule 2    @1 ->		/* empty */
rule 3    top_statement_list -> top_statement_list @1 top_statement
rule 4    top_statement_list ->		/* empty */
rule 5    namespace_name -> "identifier (T_STRING)"
rule 6    namespace_name -> namespace_name "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"
rule 7    top_statement -> statement
rule 8    top_statement -> function_declaration_statement
rule 9    top_statement -> class_declaration_statement
rule 10   top_statement -> "__halt_compiler (T_HALT_COMPILER)" '(' ')' ';'
rule 11   top_statement -> "namespace (T_NAMESPACE)" namespace_name ';'
rule 12   @2 ->		/* empty */
rule 13   top_statement -> "namespace (T_NAMESPACE)" namespace_name '{' @2 top_statement_list '}'
rule 14   @3 ->		/* empty */
rule 15   top_statement -> "namespace (T_NAMESPACE)" '{' @3 top_statement_list '}'
rule 16   top_statement -> "use (T_USE)" use_declarations ';'
rule 17   top_statement -> constant_declaration ';'
rule 18   use_declarations -> use_declarations ',' use_declaration
rule 19   use_declarations -> use_declaration
rule 20   use_declaration -> namespace_name
rule 21   use_declaration -> namespace_name "as (T_AS)" "identifier (T_STRING)"
rule 22   use_declaration -> "\\ (T_NS_SEPARATOR)" namespace_name
rule 23   use_declaration -> "\\ (T_NS_SEPARATOR)" namespace_name "as (T_AS)" "identifier (T_STRING)"
rule 24   constant_declaration -> constant_declaration ',' "identifier (T_STRING)" '=' static_scalar
rule 25   constant_declaration -> "const (T_CONST)" "identifier (T_STRING)" '=' static_scalar
rule 26   @4 ->		/* empty */
rule 27   inner_statement_list -> inner_statement_list @4 inner_statement
rule 28   inner_statement_list ->		/* empty */
rule 29   inner_statement -> statement
rule 30   inner_statement -> function_declaration_statement
rule 31   inner_statement -> class_declaration_statement
rule 32   inner_statement -> "__halt_compiler (T_HALT_COMPILER)" '(' ')' ';'
rule 33   statement -> unticked_statement
rule 34   statement -> "identifier (T_STRING)" ':'
rule 35   unticked_statement -> '{' inner_statement_list '}'
rule 36   @5 ->		/* empty */
rule 37   @6 ->		/* empty */
rule 38   unticked_statement -> "if (T_IF)" '(' expr ')' @5 statement @6 elseif_list else_single
rule 39   @7 ->		/* empty */
rule 40   @8 ->		/* empty */
rule 41   unticked_statement -> "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'
rule 42   @9 ->		/* empty */
rule 43   @10 ->		/* empty */
rule 44   unticked_statement -> "while (T_WHILE)" '(' @9 expr ')' @10 while_statement
rule 45   @11 ->		/* empty */
rule 46   @12 ->		/* empty */
rule 47   unticked_statement -> "do (T_DO)" @11 statement "while (T_WHILE)" '(' @12 expr ')' ';'
rule 48   @13 ->		/* empty */
rule 49   @14 ->		/* empty */
rule 50   @15 ->		/* empty */
rule 51   unticked_statement -> "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' @14 for_expr ')' @15 for_statement
rule 52   @16 ->		/* empty */
rule 53   unticked_statement -> "switch (T_SWITCH)" '(' expr ')' @16 switch_case_list
rule 54   unticked_statement -> "break (T_BREAK)" ';'
rule 55   unticked_statement -> "break (T_BREAK)" expr ';'
rule 56   unticked_statement -> "continue (T_CONTINUE)" ';'
rule 57   unticked_statement -> "continue (T_CONTINUE)" expr ';'
rule 58   unticked_statement -> "return (T_RETURN)" ';'
rule 59   unticked_statement -> "return (T_RETURN)" expr_without_variable ';'
rule 60   unticked_statement -> "return (T_RETURN)" variable ';'
rule 61   unticked_statement -> "global (T_GLOBAL)" global_var_list ';'
rule 62   unticked_statement -> "static (T_STATIC)" static_var_list ';'
rule 63   unticked_statement -> "echo (T_ECHO)" echo_expr_list ';'
rule 64   unticked_statement -> T_INLINE_HTML
rule 65   unticked_statement -> expr ';'
rule 66   unticked_statement -> "unset (T_UNSET)" '(' unset_variables ')' ';'
rule 67   @17 ->		/* empty */
rule 68   @18 ->		/* empty */
rule 69   unticked_statement -> "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' @18 foreach_statement
rule 70   @19 ->		/* empty */
rule 71   @20 ->		/* empty */
rule 72   unticked_statement -> "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg ')' @20 foreach_statement
rule 73   @21 ->		/* empty */
rule 74   unticked_statement -> "declare (T_DECLARE)" @21 '(' declare_list ')' declare_statement
rule 75   unticked_statement -> ';'
rule 76   @22 ->		/* empty */
rule 77   @23 ->		/* empty */
rule 78   @24 ->		/* empty */
rule 79   @25 ->		/* empty */
rule 80   @26 ->		/* empty */
rule 81   unticked_statement -> "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches
rule 82   unticked_statement -> "throw (T_THROW)" expr ';'
rule 83   unticked_statement -> "goto (T_GOTO)" "identifier (T_STRING)" ';'
rule 84   unticked_statement -> "hellowork (T_HELLOWORK)" ';'
rule 85   additional_catches -> non_empty_additional_catches
rule 86   additional_catches ->		/* empty */
rule 87   non_empty_additional_catches -> additional_catch
rule 88   non_empty_additional_catches -> non_empty_additional_catches additional_catch
rule 89   @27 ->		/* empty */
rule 90   @28 ->		/* empty */
rule 91   additional_catch -> "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list '}'
rule 92   unset_variables -> unset_variable
rule 93   unset_variables -> unset_variables ',' unset_variable
rule 94   unset_variable -> variable
rule 95   function_declaration_statement -> unticked_function_declaration_statement
rule 96   class_declaration_statement -> unticked_class_declaration_statement
rule 97   is_reference ->		/* empty */
rule 98   is_reference -> '&'
rule 99   @29 ->		/* empty */
rule 100  unticked_function_declaration_statement -> function is_reference "identifier (T_STRING)" @29 '(' parameter_list ')' '{' inner_statement_list '}'
rule 101  @30 ->		/* empty */
rule 102  unticked_class_declaration_statement -> class_entry_type "identifier (T_STRING)" extends_from @30 implements_list '{' class_statement_list '}'
rule 103  @31 ->		/* empty */
rule 104  unticked_class_declaration_statement -> interface_entry "identifier (T_STRING)" @31 interface_extends_list '{' class_statement_list '}'
rule 105  class_entry_type -> "class (T_CLASS)"
rule 106  class_entry_type -> "abstract (T_ABSTRACT)" "class (T_CLASS)"
rule 107  class_entry_type -> "trait (T_TRAIT)"
rule 108  class_entry_type -> "final (T_FINAL)" "class (T_CLASS)"
rule 109  extends_from ->		/* empty */
rule 110  extends_from -> "extends (T_EXTENDS)" fully_qualified_class_name
rule 111  interface_entry -> "interface (T_INTERFACE)"
rule 112  interface_extends_list ->		/* empty */
rule 113  interface_extends_list -> "extends (T_EXTENDS)" interface_list
rule 114  implements_list ->		/* empty */
rule 115  implements_list -> "implements (T_IMPLEMENTS)" interface_list
rule 116  interface_list -> fully_qualified_class_name
rule 117  interface_list -> interface_list ',' fully_qualified_class_name
rule 118  foreach_optional_arg ->		/* empty */
rule 119  foreach_optional_arg -> "=> (T_DOUBLE_ARROW)" foreach_variable
rule 120  foreach_variable -> variable
rule 121  foreach_variable -> '&' variable
rule 122  for_statement -> statement
rule 123  for_statement -> ':' inner_statement_list "endfor (T_ENDFOR)" ';'
rule 124  foreach_statement -> statement
rule 125  foreach_statement -> ':' inner_statement_list "endforeach (T_ENDFOREACH)" ';'
rule 126  declare_statement -> statement
rule 127  declare_statement -> ':' inner_statement_list "enddeclare (T_ENDDECLARE)" ';'
rule 128  declare_list -> "identifier (T_STRING)" '=' static_scalar
rule 129  declare_list -> declare_list ',' "identifier (T_STRING)" '=' static_scalar
rule 130  switch_case_list -> '{' case_list '}'
rule 131  switch_case_list -> '{' ';' case_list '}'
rule 132  switch_case_list -> ':' case_list "endswitch (T_ENDSWITCH)" ';'
rule 133  switch_case_list -> ':' ';' case_list "endswitch (T_ENDSWITCH)" ';'
rule 134  case_list ->		/* empty */
rule 135  @32 ->		/* empty */
rule 136  case_list -> case_list "case (T_CASE)" expr case_separator @32 inner_statement_list
rule 137  @33 ->		/* empty */
rule 138  case_list -> case_list "default (T_DEFAULT)" case_separator @33 inner_statement_list
rule 139  case_separator -> ':'
rule 140  case_separator -> ';'
rule 141  while_statement -> statement
rule 142  while_statement -> ':' inner_statement_list "endwhile (T_ENDWHILE)" ';'
rule 143  elseif_list ->		/* empty */
rule 144  @34 ->		/* empty */
rule 145  elseif_list -> elseif_list "elseif (T_ELSEIF)" '(' expr ')' @34 statement
rule 146  new_elseif_list ->		/* empty */
rule 147  @35 ->		/* empty */
rule 148  new_elseif_list -> new_elseif_list "elseif (T_ELSEIF)" '(' expr ')' ':' @35 inner_statement_list
rule 149  else_single ->		/* empty */
rule 150  else_single -> "else (T_ELSE)" statement
rule 151  new_else_single ->		/* empty */
rule 152  new_else_single -> "else (T_ELSE)" ':' inner_statement_list
rule 153  parameter_list -> non_empty_parameter_list
rule 154  parameter_list ->		/* empty */
rule 155  non_empty_parameter_list -> optional_class_type "variable (T_VARIABLE)"
rule 156  non_empty_parameter_list -> optional_class_type '&' "variable (T_VARIABLE)"
rule 157  non_empty_parameter_list -> optional_class_type '&' "variable (T_VARIABLE)" '=' static_scalar
rule 158  non_empty_parameter_list -> optional_class_type "variable (T_VARIABLE)" '=' static_scalar
rule 159  non_empty_parameter_list -> non_empty_parameter_list ',' optional_class_type "variable (T_VARIABLE)"
rule 160  non_empty_parameter_list -> non_empty_parameter_list ',' optional_class_type '&' "variable (T_VARIABLE)"
rule 161  non_empty_parameter_list -> non_empty_parameter_list ',' optional_class_type '&' "variable (T_VARIABLE)" '=' static_scalar
rule 162  non_empty_parameter_list -> non_empty_parameter_list ',' optional_class_type "variable (T_VARIABLE)" '=' static_scalar
rule 163  optional_class_type ->		/* empty */
rule 164  optional_class_type -> "array (T_ARRAY)"
rule 165  optional_class_type -> "callable (T_CALLABLE)"
rule 166  optional_class_type -> fully_qualified_class_name
rule 167  function_call_parameter_list -> non_empty_function_call_parameter_list
rule 168  function_call_parameter_list ->		/* empty */
rule 169  non_empty_function_call_parameter_list -> expr_without_variable
rule 170  non_empty_function_call_parameter_list -> variable
rule 171  non_empty_function_call_parameter_list -> '&' w_variable
rule 172  non_empty_function_call_parameter_list -> non_empty_function_call_parameter_list ',' expr_without_variable
rule 173  non_empty_function_call_parameter_list -> non_empty_function_call_parameter_list ',' variable
rule 174  non_empty_function_call_parameter_list -> non_empty_function_call_parameter_list ',' '&' w_variable
rule 175  global_var_list -> global_var_list ',' global_var
rule 176  global_var_list -> global_var
rule 177  global_var -> "variable (T_VARIABLE)"
rule 178  global_var -> '$' r_variable
rule 179  global_var -> '$' '{' expr '}'
rule 180  static_var_list -> static_var_list ',' "variable (T_VARIABLE)"
rule 181  static_var_list -> static_var_list ',' "variable (T_VARIABLE)" '=' static_scalar
rule 182  static_var_list -> "variable (T_VARIABLE)"
rule 183  static_var_list -> "variable (T_VARIABLE)" '=' static_scalar
rule 184  class_statement_list -> class_statement_list class_statement
rule 185  class_statement_list ->		/* empty */
rule 186  @36 ->		/* empty */
rule 187  class_statement -> variable_modifiers @36 class_variable_declaration ';'
rule 188  class_statement -> class_constant_declaration ';'
rule 189  class_statement -> trait_use_statement
rule 190  @37 ->		/* empty */
rule 191  class_statement -> method_modifiers function is_reference "identifier (T_STRING)" @37 '(' parameter_list ')' method_body
rule 192  trait_use_statement -> "use (T_USE)" trait_list trait_adaptations
rule 193  trait_list -> fully_qualified_class_name
rule 194  trait_list -> trait_list ',' fully_qualified_class_name
rule 195  trait_adaptations -> ';'
rule 196  trait_adaptations -> '{' trait_adaptation_list '}'
rule 197  trait_adaptation_list ->		/* empty */
rule 198  trait_adaptation_list -> non_empty_trait_adaptation_list
rule 199  non_empty_trait_adaptation_list -> trait_adaptation_statement
rule 200  non_empty_trait_adaptation_list -> non_empty_trait_adaptation_list trait_adaptation_statement
rule 201  trait_adaptation_statement -> trait_precedence ';'
rule 202  trait_adaptation_statement -> trait_alias ';'
rule 203  trait_precedence -> trait_method_reference_fully_qualified "insteadof (T_INSTEADOF)" trait_reference_list
rule 204  trait_reference_list -> fully_qualified_class_name
rule 205  trait_reference_list -> trait_reference_list ',' fully_qualified_class_name
rule 206  trait_method_reference -> "identifier (T_STRING)"
rule 207  trait_method_reference -> trait_method_reference_fully_qualified
rule 208  trait_method_reference_fully_qualified -> fully_qualified_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"
rule 209  trait_alias -> trait_method_reference "as (T_AS)" trait_modifiers "identifier (T_STRING)"
rule 210  trait_alias -> trait_method_reference "as (T_AS)" member_modifier
rule 211  trait_modifiers ->		/* empty */
rule 212  trait_modifiers -> member_modifier
rule 213  method_body -> ';'
rule 214  method_body -> '{' inner_statement_list '}'
rule 215  variable_modifiers -> non_empty_member_modifiers
rule 216  variable_modifiers -> "var (T_VAR)"
rule 217  method_modifiers ->		/* empty */
rule 218  method_modifiers -> non_empty_member_modifiers
rule 219  non_empty_member_modifiers -> member_modifier
rule 220  non_empty_member_modifiers -> non_empty_member_modifiers member_modifier
rule 221  member_modifier -> "public (T_PUBLIC)"
rule 222  member_modifier -> "protected (T_PROTECTED)"
rule 223  member_modifier -> "private (T_PRIVATE)"
rule 224  member_modifier -> "static (T_STATIC)"
rule 225  member_modifier -> "abstract (T_ABSTRACT)"
rule 226  member_modifier -> "final (T_FINAL)"
rule 227  class_variable_declaration -> class_variable_declaration ',' "variable (T_VARIABLE)"
rule 228  class_variable_declaration -> class_variable_declaration ',' "variable (T_VARIABLE)" '=' static_scalar
rule 229  class_variable_declaration -> "variable (T_VARIABLE)"
rule 230  class_variable_declaration -> "variable (T_VARIABLE)" '=' static_scalar
rule 231  class_constant_declaration -> class_constant_declaration ',' "identifier (T_STRING)" '=' static_scalar
rule 232  class_constant_declaration -> "const (T_CONST)" "identifier (T_STRING)" '=' static_scalar
rule 233  echo_expr_list -> echo_expr_list ',' expr
rule 234  echo_expr_list -> expr
rule 235  for_expr ->		/* empty */
rule 236  for_expr -> non_empty_for_expr
rule 237  @38 ->		/* empty */
rule 238  non_empty_for_expr -> non_empty_for_expr ',' @38 expr
rule 239  non_empty_for_expr -> expr
rule 240  chaining_method_or_property -> chaining_method_or_property variable_property
rule 241  chaining_method_or_property -> variable_property
rule 242  chaining_dereference -> chaining_dereference '[' dim_offset ']'
rule 243  chaining_dereference -> '[' dim_offset ']'
rule 244  @39 ->		/* empty */
rule 245  chaining_instance_call -> chaining_dereference @39 chaining_method_or_property
rule 246  chaining_instance_call -> chaining_dereference
rule 247  chaining_instance_call -> chaining_method_or_property
rule 248  instance_call ->		/* empty */
rule 249  @40 ->		/* empty */
rule 250  instance_call -> @40 chaining_instance_call
rule 251  @41 ->		/* empty */
rule 252  new_expr -> "new (T_NEW)" class_name_reference @41 ctor_arguments
rule 253  @42 ->		/* empty */
rule 254  expr_without_variable -> "list (T_LIST)" '(' @42 assignment_list ')' '=' expr
rule 255  expr_without_variable -> variable '=' expr
rule 256  expr_without_variable -> variable '=' '&' variable
rule 257  @43 ->		/* empty */
rule 258  expr_without_variable -> variable '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments
rule 259  expr_without_variable -> "clone (T_CLONE)" expr
rule 260  expr_without_variable -> variable "+= (T_PLUS_EQUAL)" expr
rule 261  expr_without_variable -> variable "-= (T_MINUS_EQUAL)" expr
rule 262  expr_without_variable -> variable "*= (T_MUL_EQUAL)" expr
rule 263  expr_without_variable -> variable "/= (T_DIV_EQUAL)" expr
rule 264  expr_without_variable -> variable ".= (T_CONCAT_EQUAL)" expr
rule 265  expr_without_variable -> variable "%= (T_MOD_EQUAL)" expr
rule 266  expr_without_variable -> variable "&= (T_AND_EQUAL)" expr
rule 267  expr_without_variable -> variable "|= (T_OR_EQUAL)" expr
rule 268  expr_without_variable -> variable "^= (T_XOR_EQUAL)" expr
rule 269  expr_without_variable -> variable "<<= (T_SL_EQUAL)" expr
rule 270  expr_without_variable -> variable ">>= (T_SR_EQUAL)" expr
rule 271  expr_without_variable -> rw_variable "++ (T_INC)"
rule 272  expr_without_variable -> "++ (T_INC)" rw_variable
rule 273  expr_without_variable -> rw_variable "-- (T_DEC)"
rule 274  expr_without_variable -> "-- (T_DEC)" rw_variable
rule 275  @44 ->		/* empty */
rule 276  expr_without_variable -> expr "|| (T_BOOLEAN_OR)" @44 expr
rule 277  @45 ->		/* empty */
rule 278  expr_without_variable -> expr "&& (T_BOOLEAN_AND)" @45 expr
rule 279  @46 ->		/* empty */
rule 280  expr_without_variable -> expr "or (T_LOGICAL_OR)" @46 expr
rule 281  @47 ->		/* empty */
rule 282  expr_without_variable -> expr "and (T_LOGICAL_AND)" @47 expr
rule 283  expr_without_variable -> expr "xor (T_LOGICAL_XOR)" expr
rule 284  expr_without_variable -> expr '|' expr
rule 285  expr_without_variable -> expr '&' expr
rule 286  expr_without_variable -> expr '^' expr
rule 287  expr_without_variable -> expr '.' expr
rule 288  expr_without_variable -> expr '+' expr
rule 289  expr_without_variable -> expr '-' expr
rule 290  expr_without_variable -> expr '*' expr
rule 291  expr_without_variable -> expr '/' expr
rule 292  expr_without_variable -> expr '%' expr
rule 293  expr_without_variable -> expr "<< (T_SL)" expr
rule 294  expr_without_variable -> expr ">> (T_SR)" expr
rule 295  expr_without_variable -> '+' expr
rule 296  expr_without_variable -> '-' expr
rule 297  expr_without_variable -> '!' expr
rule 298  expr_without_variable -> '~' expr
rule 299  expr_without_variable -> expr "=== (T_IS_IDENTICAL)" expr
rule 300  expr_without_variable -> expr "!== (T_IS_NOT_IDENTICAL)" expr
rule 301  expr_without_variable -> expr "== (T_IS_EQUAL)" expr
rule 302  expr_without_variable -> expr "!= (T_IS_NOT_EQUAL)" expr
rule 303  expr_without_variable -> expr '<' expr
rule 304  expr_without_variable -> expr "<= (T_IS_SMALLER_OR_EQUAL)" expr
rule 305  expr_without_variable -> expr '>' expr
rule 306  expr_without_variable -> expr ">= (T_IS_GREATER_OR_EQUAL)" expr
rule 307  expr_without_variable -> expr "instanceof (T_INSTANCEOF)" class_name_reference
rule 308  expr_without_variable -> '(' expr ')'
rule 309  expr_without_variable -> new_expr
rule 310  @48 ->		/* empty */
rule 311  expr_without_variable -> '(' new_expr ')' @48 instance_call
rule 312  @49 ->		/* empty */
rule 313  @50 ->		/* empty */
rule 314  expr_without_variable -> expr '?' @49 expr ':' @50 expr
rule 315  @51 ->		/* empty */
rule 316  expr_without_variable -> expr '?' ':' @51 expr
rule 317  expr_without_variable -> internal_functions_in_yacc
rule 318  expr_without_variable -> "(int) (T_INT_CAST)" expr
rule 319  expr_without_variable -> "(double) (T_DOUBLE_CAST)" expr
rule 320  expr_without_variable -> "(string) (T_STRING_CAST)" expr
rule 321  expr_without_variable -> "(array) (T_ARRAY_CAST)" expr
rule 322  expr_without_variable -> "(object) (T_OBJECT_CAST)" expr
rule 323  expr_without_variable -> "(bool) (T_BOOL_CAST)" expr
rule 324  expr_without_variable -> "(unset) (T_UNSET_CAST)" expr
rule 325  expr_without_variable -> "exit (T_EXIT)" exit_expr
rule 326  @52 ->		/* empty */
rule 327  expr_without_variable -> '@' @52 expr
rule 328  expr_without_variable -> scalar
rule 329  expr_without_variable -> "array (T_ARRAY)" '(' array_pair_list ')'
rule 330  expr_without_variable -> '[' array_pair_list ']'
rule 331  expr_without_variable -> '`' backticks_expr '`'
rule 332  expr_without_variable -> "print (T_PRINT)" expr
rule 333  @53 ->		/* empty */
rule 334  expr_without_variable -> function is_reference '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list '}'
rule 335  @54 ->		/* empty */
rule 336  expr_without_variable -> "static (T_STATIC)" function is_reference '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list '}'
rule 337  function -> "function (T_FUNCTION)"
rule 338  lexical_vars ->		/* empty */
rule 339  lexical_vars -> "use (T_USE)" '(' lexical_var_list ')'
rule 340  lexical_var_list -> lexical_var_list ',' "variable (T_VARIABLE)"
rule 341  lexical_var_list -> lexical_var_list ',' '&' "variable (T_VARIABLE)"
rule 342  lexical_var_list -> "variable (T_VARIABLE)"
rule 343  lexical_var_list -> '&' "variable (T_VARIABLE)"
rule 344  @55 ->		/* empty */
rule 345  function_call -> namespace_name '(' @55 function_call_parameter_list ')'
rule 346  @56 ->		/* empty */
rule 347  function_call -> "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 function_call_parameter_list ')'
rule 348  @57 ->		/* empty */
rule 349  function_call -> "\\ (T_NS_SEPARATOR)" namespace_name '(' @57 function_call_parameter_list ')'
rule 350  @58 ->		/* empty */
rule 351  function_call -> class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @58 function_call_parameter_list ')'
rule 352  @59 ->		/* empty */
rule 353  function_call -> class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @59 function_call_parameter_list ')'
rule 354  @60 ->		/* empty */
rule 355  function_call -> variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @60 function_call_parameter_list ')'
rule 356  @61 ->		/* empty */
rule 357  function_call -> variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @61 function_call_parameter_list ')'
rule 358  @62 ->		/* empty */
rule 359  function_call -> variable_without_objects '(' @62 function_call_parameter_list ')'
rule 360  class_name -> "static (T_STATIC)"
rule 361  class_name -> namespace_name
rule 362  class_name -> "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name
rule 363  class_name -> "\\ (T_NS_SEPARATOR)" namespace_name
rule 364  fully_qualified_class_name -> namespace_name
rule 365  fully_qualified_class_name -> "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name
rule 366  fully_qualified_class_name -> "\\ (T_NS_SEPARATOR)" namespace_name
rule 367  class_name_reference -> class_name
rule 368  class_name_reference -> dynamic_class_name_reference
rule 369  @63 ->		/* empty */
rule 370  @64 ->		/* empty */
rule 371  dynamic_class_name_reference -> base_variable "-> (T_OBJECT_OPERATOR)" @63 object_property @64 dynamic_class_name_variable_properties
rule 372  dynamic_class_name_reference -> base_variable
rule 373  dynamic_class_name_variable_properties -> dynamic_class_name_variable_properties dynamic_class_name_variable_property
rule 374  dynamic_class_name_variable_properties ->		/* empty */
rule 375  dynamic_class_name_variable_property -> "-> (T_OBJECT_OPERATOR)" object_property
rule 376  exit_expr ->		/* empty */
rule 377  exit_expr -> '(' ')'
rule 378  exit_expr -> '(' expr ')'
rule 379  backticks_expr ->		/* empty */
rule 380  backticks_expr -> "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"
rule 381  backticks_expr -> encaps_list
rule 382  ctor_arguments ->		/* empty */
rule 383  ctor_arguments -> '(' function_call_parameter_list ')'
rule 384  common_scalar -> "integer number (T_LNUMBER)"
rule 385  common_scalar -> "floating-point number (T_DNUMBER)"
rule 386  common_scalar -> "quoted-string (T_CONSTANT_ENCAPSED_STRING)"
rule 387  common_scalar -> "__LINE__ (T_LINE)"
rule 388  common_scalar -> "__FILE__ (T_FILE)"
rule 389  common_scalar -> "__DIR__ (T_DIR)"
rule 390  common_scalar -> "__TRAIT__ (T_TRAIT_C)"
rule 391  common_scalar -> "__METHOD__ (T_METHOD_C)"
rule 392  common_scalar -> "__FUNCTION__ (T_FUNC_C)"
rule 393  common_scalar -> "__NAMESPACE__ (T_NS_C)"
rule 394  common_scalar -> "heredoc start (T_START_HEREDOC)" "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" "heredoc end (T_END_HEREDOC)"
rule 395  common_scalar -> "heredoc start (T_START_HEREDOC)" "heredoc end (T_END_HEREDOC)"
rule 396  static_scalar -> common_scalar
rule 397  static_scalar -> namespace_name
rule 398  static_scalar -> "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name
rule 399  static_scalar -> "\\ (T_NS_SEPARATOR)" namespace_name
rule 400  static_scalar -> '+' static_scalar
rule 401  static_scalar -> '-' static_scalar
rule 402  static_scalar -> "array (T_ARRAY)" '(' static_array_pair_list ')'
rule 403  static_scalar -> '[' static_array_pair_list ']'
rule 404  static_scalar -> static_class_constant
rule 405  static_scalar -> "__CLASS__ (T_CLASS_C)"
rule 406  static_class_constant -> class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"
rule 407  scalar -> "variable name (T_STRING_VARNAME)"
rule 408  scalar -> class_constant
rule 409  scalar -> namespace_name
rule 410  scalar -> "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name
rule 411  scalar -> "\\ (T_NS_SEPARATOR)" namespace_name
rule 412  scalar -> common_scalar
rule 413  scalar -> '\"' encaps_list '\"'
rule 414  scalar -> "heredoc start (T_START_HEREDOC)" encaps_list "heredoc end (T_END_HEREDOC)"
rule 415  scalar -> "__CLASS__ (T_CLASS_C)"
rule 416  static_array_pair_list ->		/* empty */
rule 417  static_array_pair_list -> non_empty_static_array_pair_list possible_comma
rule 418  possible_comma ->		/* empty */
rule 419  possible_comma -> ','
rule 420  non_empty_static_array_pair_list -> non_empty_static_array_pair_list ',' static_scalar "=> (T_DOUBLE_ARROW)" static_scalar
rule 421  non_empty_static_array_pair_list -> non_empty_static_array_pair_list ',' static_scalar
rule 422  non_empty_static_array_pair_list -> static_scalar "=> (T_DOUBLE_ARROW)" static_scalar
rule 423  non_empty_static_array_pair_list -> static_scalar
rule 424  expr -> r_variable
rule 425  expr -> expr_without_variable
rule 426  r_variable -> variable
rule 427  w_variable -> variable
rule 428  rw_variable -> variable
rule 429  @65 ->		/* empty */
rule 430  @66 ->		/* empty */
rule 431  variable -> base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" @65 object_property @66 method_or_not variable_properties
rule 432  variable -> base_variable_with_function_calls
rule 433  variable_properties -> variable_properties variable_property
rule 434  variable_properties ->		/* empty */
rule 435  @67 ->		/* empty */
rule 436  variable_property -> "-> (T_OBJECT_OPERATOR)" object_property @67 method_or_not
rule 437  array_method_dereference -> array_method_dereference '[' dim_offset ']'
rule 438  array_method_dereference -> method '[' dim_offset ']'
rule 439  @68 ->		/* empty */
rule 440  method -> '(' @68 function_call_parameter_list ')'
rule 441  method_or_not -> method
rule 442  method_or_not -> array_method_dereference
rule 443  method_or_not ->		/* empty */
rule 444  variable_without_objects -> reference_variable
rule 445  variable_without_objects -> simple_indirect_reference reference_variable
rule 446  static_member -> class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects
rule 447  static_member -> variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects
rule 448  variable_class_name -> reference_variable
rule 449  array_function_dereference -> array_function_dereference '[' dim_offset ']'
rule 450  @69 ->		/* empty */
rule 451  array_function_dereference -> function_call @69 '[' dim_offset ']'
rule 452  base_variable_with_function_calls -> base_variable
rule 453  base_variable_with_function_calls -> array_function_dereference
rule 454  base_variable_with_function_calls -> function_call
rule 455  base_variable -> reference_variable
rule 456  base_variable -> simple_indirect_reference reference_variable
rule 457  base_variable -> static_member
rule 458  reference_variable -> reference_variable '[' dim_offset ']'
rule 459  reference_variable -> reference_variable '{' expr '}'
rule 460  reference_variable -> compound_variable
rule 461  compound_variable -> "variable (T_VARIABLE)"
rule 462  compound_variable -> '$' '{' expr '}'
rule 463  dim_offset ->		/* empty */
rule 464  dim_offset -> expr
rule 465  object_property -> object_dim_list
rule 466  @70 ->		/* empty */
rule 467  object_property -> variable_without_objects @70
rule 468  object_dim_list -> object_dim_list '[' dim_offset ']'
rule 469  object_dim_list -> object_dim_list '{' expr '}'
rule 470  object_dim_list -> variable_name
rule 471  variable_name -> "identifier (T_STRING)"
rule 472  variable_name -> '{' expr '}'
rule 473  simple_indirect_reference -> '$'
rule 474  simple_indirect_reference -> simple_indirect_reference '$'
rule 475  assignment_list -> assignment_list ',' assignment_list_element
rule 476  assignment_list -> assignment_list_element
rule 477  assignment_list_element -> variable
rule 478  @71 ->		/* empty */
rule 479  assignment_list_element -> "list (T_LIST)" '(' @71 assignment_list ')'
rule 480  assignment_list_element ->		/* empty */
rule 481  array_pair_list ->		/* empty */
rule 482  array_pair_list -> non_empty_array_pair_list possible_comma
rule 483  non_empty_array_pair_list -> non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" expr
rule 484  non_empty_array_pair_list -> non_empty_array_pair_list ',' expr
rule 485  non_empty_array_pair_list -> expr "=> (T_DOUBLE_ARROW)" expr
rule 486  non_empty_array_pair_list -> expr
rule 487  non_empty_array_pair_list -> non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" '&' w_variable
rule 488  non_empty_array_pair_list -> non_empty_array_pair_list ',' '&' w_variable
rule 489  non_empty_array_pair_list -> expr "=> (T_DOUBLE_ARROW)" '&' w_variable
rule 490  non_empty_array_pair_list -> '&' w_variable
rule 491  encaps_list -> encaps_list encaps_var
rule 492  encaps_list -> encaps_list "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"
rule 493  encaps_list -> encaps_var
rule 494  encaps_list -> "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" encaps_var
rule 495  encaps_var -> "variable (T_VARIABLE)"
rule 496  @72 ->		/* empty */
rule 497  encaps_var -> "variable (T_VARIABLE)" '[' @72 encaps_var_offset ']'
rule 498  encaps_var -> "variable (T_VARIABLE)" "-> (T_OBJECT_OPERATOR)" "identifier (T_STRING)"
rule 499  encaps_var -> "${ (T_DOLLAR_OPEN_CURLY_BRACES)" expr '}'
rule 500  encaps_var -> "${ (T_DOLLAR_OPEN_CURLY_BRACES)" "variable name (T_STRING_VARNAME)" '[' expr ']' '}'
rule 501  encaps_var -> "{$ (T_CURLY_OPEN)" variable '}'
rule 502  encaps_var_offset -> "identifier (T_STRING)"
rule 503  encaps_var_offset -> "number (T_NUM_STRING)"
rule 504  encaps_var_offset -> "variable (T_VARIABLE)"
rule 505  internal_functions_in_yacc -> "isset (T_ISSET)" '(' isset_variables ')'
rule 506  internal_functions_in_yacc -> "empty (T_EMPTY)" '(' variable ')'
rule 507  internal_functions_in_yacc -> "include (T_INCLUDE)" expr
rule 508  internal_functions_in_yacc -> "include_once (T_INCLUDE_ONCE)" expr
rule 509  internal_functions_in_yacc -> "eval (T_EVAL)" '(' expr ')'
rule 510  internal_functions_in_yacc -> "require (T_REQUIRE)" expr
rule 511  internal_functions_in_yacc -> "require_once (T_REQUIRE_ONCE)" expr
rule 512  isset_variables -> variable
rule 513  @73 ->		/* empty */
rule 514  isset_variables -> isset_variables ',' @73 variable
rule 515  class_constant -> class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"
rule 516  class_constant -> variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"

Terminals, with rules where they appear

$ (-1)
'!' (33) 297
'\"' (34) 413
'$' (36) 178 179 462 473 474
'%' (37) 292
'&' (38) 98 121 156 157 160 161 171 174 256 258 285 341 343 487 488
    489 490
'(' (40) 10 32 38 41 44 47 51 53 66 69 72 74 81 91 100 145 148 191
    254 308 311 329 334 336 339 345 347 349 351 353 355 357 359 377
    378 383 402 440 479 505 506 509
')' (41) 10 32 38 41 44 47 51 53 66 69 72 74 81 91 100 145 148 191
    254 308 311 329 334 336 339 345 347 349 351 353 355 357 359 377
    378 383 402 440 479 505 506 509
'*' (42) 290
'+' (43) 288 295 400
',' (44) 18 24 93 117 129 159 160 161 162 172 173 174 175 180 181 194
    205 227 228 231 233 238 340 341 419 420 421 475 483 484 487 488
    514
'-' (45) 289 296 401
'.' (46) 287
'/' (47) 291
':' (58) 34 41 123 125 127 132 133 139 142 148 152 314 316
';' (59) 10 11 16 17 32 41 47 51 54 55 56 57 58 59 60 61 62 63 65 66
    75 82 83 84 123 125 127 131 132 133 140 142 187 188 195 201 202
    213
'<' (60) 303
'=' (61) 24 25 128 129 157 158 161 162 181 183 228 230 231 232 254
    255 256 258
'>' (62) 305
'?' (63) 314 316
'@' (64) 327
'[' (91) 242 243 330 403 437 438 449 451 458 468 497 500
']' (93) 242 243 330 403 437 438 449 451 458 468 497 500
'^' (94) 286
'`' (96) 331
'{' (123) 13 15 35 81 91 100 102 104 130 131 179 196 214 334 336 459
    462 469 472
'|' (124) 284
'}' (125) 13 15 35 81 91 100 102 104 130 131 179 196 214 334 336 459
    462 469 472 499 500 501
'~' (126) 298
error (256)
"hellowork (T_HELLOWORK)" (257) 84
"end of file" (258)
"include (T_INCLUDE)" (259) 507
"include_once (T_INCLUDE_ONCE)" (260) 508
"eval (T_EVAL)" (261) 509
"require (T_REQUIRE)" (262) 510
"require_once (T_REQUIRE_ONCE)" (263) 511
"or (T_LOGICAL_OR)" (264) 280
"xor (T_LOGICAL_XOR)" (265) 283
"and (T_LOGICAL_AND)" (266) 282
"print (T_PRINT)" (267) 332
"+= (T_PLUS_EQUAL)" (268) 260
"-= (T_MINUS_EQUAL)" (269) 261
"*= (T_MUL_EQUAL)" (270) 262
"/= (T_DIV_EQUAL)" (271) 263
".= (T_CONCAT_EQUAL)" (272) 264
"%= (T_MOD_EQUAL)" (273) 265
"&= (T_AND_EQUAL)" (274) 266
"|= (T_OR_EQUAL)" (275) 267
"^= (T_XOR_EQUAL)" (276) 268
"<<= (T_SL_EQUAL)" (277) 269
">>= (T_SR_EQUAL)" (278) 270
"|| (T_BOOLEAN_OR)" (279) 276
"&& (T_BOOLEAN_AND)" (280) 278
"== (T_IS_EQUAL)" (281) 301
"!= (T_IS_NOT_EQUAL)" (282) 302
"=== (T_IS_IDENTICAL)" (283) 299
"!== (T_IS_NOT_IDENTICAL)" (284) 300
"<= (T_IS_SMALLER_OR_EQUAL)" (285) 304
">= (T_IS_GREATER_OR_EQUAL)" (286) 306
"<< (T_SL)" (287) 293
">> (T_SR)" (288) 294
"instanceof (T_INSTANCEOF)" (289) 307
"++ (T_INC)" (290) 271 272
"-- (T_DEC)" (291) 273 274
"(int) (T_INT_CAST)" (292) 318
"(double) (T_DOUBLE_CAST)" (293) 319
"(string) (T_STRING_CAST)" (294) 320
"(array) (T_ARRAY_CAST)" (295) 321
"(object) (T_OBJECT_CAST)" (296) 322
"(bool) (T_BOOL_CAST)" (297) 323
"(unset) (T_UNSET_CAST)" (298) 324
"new (T_NEW)" (299) 252 258
"clone (T_CLONE)" (300) 259
"exit (T_EXIT)" (301) 325
"if (T_IF)" (302) 38 41
"elseif (T_ELSEIF)" (303) 145 148
"else (T_ELSE)" (304) 150 152
"endif (T_ENDIF)" (305) 41
"integer number (T_LNUMBER)" (306) 384
"floating-point number (T_DNUMBER)" (307) 385
"identifier (T_STRING)" (308) 5 6 21 23 24 25 34 83 100 102 104 128
    129 191 206 208 209 231 232 406 471 498 502 515 516
"variable name (T_STRING_VARNAME)" (309) 407 500
"variable (T_VARIABLE)" (310) 81 91 155 156 157 158 159 160 161 162
    177 180 181 182 183 227 228 229 230 340 341 342 343 461 495 497
    498 504
"number (T_NUM_STRING)" (311) 503
T_INLINE_HTML (312) 64
T_CHARACTER (313)
T_BAD_CHARACTER (314)
"quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"
    (315) 380 394 492 494
"quoted-string (T_CONSTANT_ENCAPSED_STRING)" (316) 386
"echo (T_ECHO)" (317) 63
"do (T_DO)" (318) 47
"while (T_WHILE)" (319) 44 47
"endwhile (T_ENDWHILE)" (320) 142
"for (T_FOR)" (321) 51
"endfor (T_ENDFOR)" (322) 123
"foreach (T_FOREACH)" (323) 69 72
"endforeach (T_ENDFOREACH)" (324) 125
"declare (T_DECLARE)" (325) 74
"enddeclare (T_ENDDECLARE)" (326) 127
"as (T_AS)" (327) 21 23 69 72 209 210
"switch (T_SWITCH)" (328) 53
"endswitch (T_ENDSWITCH)" (329) 132 133
"case (T_CASE)" (330) 136
"default (T_DEFAULT)" (331) 138
"break (T_BREAK)" (332) 54 55
"continue (T_CONTINUE)" (333) 56 57
"goto (T_GOTO)" (334) 83
"function (T_FUNCTION)" (335) 337
"const (T_CONST)" (336) 25 232
"return (T_RETURN)" (337) 58 59 60
"try (T_TRY)" (338) 81
"catch (T_CATCH)" (339) 81 91
"throw (T_THROW)" (340) 82
"use (T_USE)" (341) 16 192 339
"insteadof (T_INSTEADOF)" (342) 203
"global (T_GLOBAL)" (343) 61
"static (T_STATIC)" (344) 62 224 336 360
"abstract (T_ABSTRACT)" (345) 106 225
"final (T_FINAL)" (346) 108 226
"private (T_PRIVATE)" (347) 223
"protected (T_PROTECTED)" (348) 222
"public (T_PUBLIC)" (349) 221
"var (T_VAR)" (350) 216
"unset (T_UNSET)" (351) 66
"isset (T_ISSET)" (352) 505
"empty (T_EMPTY)" (353) 506
"__halt_compiler (T_HALT_COMPILER)" (354) 10 32
"class (T_CLASS)" (355) 105 106 108
"trait (T_TRAIT)" (356) 107
"interface (T_INTERFACE)" (357) 111
"extends (T_EXTENDS)" (358) 110 113
"implements (T_IMPLEMENTS)" (359) 115
"-> (T_OBJECT_OPERATOR)" (360) 371 375 431 436 498
"=> (T_DOUBLE_ARROW)" (361) 119 420 422 483 485 487 489
"list (T_LIST)" (362) 254 479
"array (T_ARRAY)" (363) 164 329 402
"callable (T_CALLABLE)" (364) 165
"__CLASS__ (T_CLASS_C)" (365) 405 415
"__TRAIT__ (T_TRAIT_C)" (366) 390
"__METHOD__ (T_METHOD_C)" (367) 391
"__FUNCTION__ (T_FUNC_C)" (368) 392
"__LINE__ (T_LINE)" (369) 387
"__FILE__ (T_FILE)" (370) 388
"comment (T_COMMENT)" (371)
"doc comment (T_DOC_COMMENT)" (372)
"open tag (T_OPEN_TAG)" (373)
"open tag with echo (T_OPEN_TAG_WITH_ECHO)" (374)
"close tag (T_CLOSE_TAG)" (375)
"whitespace (T_WHITESPACE)" (376)
"heredoc start (T_START_HEREDOC)" (377) 394 395 414
"heredoc end (T_END_HEREDOC)" (378) 394 395 414
"${ (T_DOLLAR_OPEN_CURLY_BRACES)" (379) 499 500
"{$ (T_CURLY_OPEN)" (380) 501
":: (T_PAAMAYIM_NEKUDOTAYIM)" (381) 208 351 353 355 357 406 446 447
    515 516
"namespace (T_NAMESPACE)" (382) 11 13 15 347 362 365 398 410
"__NAMESPACE__ (T_NS_C)" (383) 393
"__DIR__ (T_DIR)" (384) 389
"\\ (T_NS_SEPARATOR)" (385) 6 22 23 347 349 362 363 365 366 398 399
    410 411

Nonterminals, with rules where they appear

start (160)
    on left: 1
top_statement_list (161)
    on left: 3 4, on right: 1 3 13 15
@1 (162)
    on left: 2, on right: 3
namespace_name (163)
    on left: 5 6, on right: 6 11 13 20 21 22 23 345 347 349 361 362
    363 364 365 366 397 398 399 409 410 411
top_statement (164)
    on left: 7 8 9 10 11 13 15 16 17, on right: 3
@2 (165)
    on left: 12, on right: 13
@3 (166)
    on left: 14, on right: 15
use_declarations (167)
    on left: 18 19, on right: 16 18
use_declaration (168)
    on left: 20 21 22 23, on right: 18 19
constant_declaration (169)
    on left: 24 25, on right: 17 24
inner_statement_list (170)
    on left: 27 28, on right: 27 35 41 81 91 100 123 125 127 136 138
    142 148 152 214 334 336
@4 (171)
    on left: 26, on right: 27
inner_statement (172)
    on left: 29 30 31 32, on right: 27
statement (173)
    on left: 33 34, on right: 7 29 38 47 122 124 126 141 145 150
unticked_statement (174)
    on left: 35 38 41 44 47 51 53 54 55 56 57 58 59 60 61 62 63 64
    65 66 69 72 74 75 81 82 83 84, on right: 33
@5 (175)
    on left: 36, on right: 38
@6 (176)
    on left: 37, on right: 38
@7 (177)
    on left: 39, on right: 41
@8 (178)
    on left: 40, on right: 41
@9 (179)
    on left: 42, on right: 44
@10 (180)
    on left: 43, on right: 44
@11 (181)
    on left: 45, on right: 47
@12 (182)
    on left: 46, on right: 47
@13 (183)
    on left: 48, on right: 51
@14 (184)
    on left: 49, on right: 51
@15 (185)
    on left: 50, on right: 51
@16 (186)
    on left: 52, on right: 53
@17 (187)
    on left: 67, on right: 69
@18 (188)
    on left: 68, on right: 69
@19 (189)
    on left: 70, on right: 72
@20 (190)
    on left: 71, on right: 72
@21 (191)
    on left: 73, on right: 74
@22 (192)
    on left: 76, on right: 81
@23 (193)
    on left: 77, on right: 81
@24 (194)
    on left: 78, on right: 81
@25 (195)
    on left: 79, on right: 81
@26 (196)
    on left: 80, on right: 81
additional_catches (197)
    on left: 85 86, on right: 81
non_empty_additional_catches (198)
    on left: 87 88, on right: 85 88
additional_catch (199)
    on left: 91, on right: 87 88
@27 (200)
    on left: 89, on right: 91
@28 (201)
    on left: 90, on right: 91
unset_variables (202)
    on left: 92 93, on right: 66 93
unset_variable (203)
    on left: 94, on right: 92 93
function_declaration_statement (204)
    on left: 95, on right: 8 30
class_declaration_statement (205)
    on left: 96, on right: 9 31
is_reference (206)
    on left: 97 98, on right: 100 191 334 336
unticked_function_declaration_statement (207)
    on left: 100, on right: 95
@29 (208)
    on left: 99, on right: 100
unticked_class_declaration_statement (209)
    on left: 102 104, on right: 96
@30 (210)
    on left: 101, on right: 102
@31 (211)
    on left: 103, on right: 104
class_entry_type (212)
    on left: 105 106 107 108, on right: 102
extends_from (213)
    on left: 109 110, on right: 102
interface_entry (214)
    on left: 111, on right: 104
interface_extends_list (215)
    on left: 112 113, on right: 104
implements_list (216)
    on left: 114 115, on right: 102
interface_list (217)
    on left: 116 117, on right: 113 115 117
foreach_optional_arg (218)
    on left: 118 119, on right: 69 72
foreach_variable (219)
    on left: 120 121, on right: 69 119
for_statement (220)
    on left: 122 123, on right: 51
foreach_statement (221)
    on left: 124 125, on right: 69 72
declare_statement (222)
    on left: 126 127, on right: 74
declare_list (223)
    on left: 128 129, on right: 74 129
switch_case_list (224)
    on left: 130 131 132 133, on right: 53
case_list (225)
    on left: 134 136 138, on right: 130 131 132 133 136 138
@32 (226)
    on left: 135, on right: 136
@33 (227)
    on left: 137, on right: 138
case_separator (228)
    on left: 139 140, on right: 136 138
while_statement (229)
    on left: 141 142, on right: 44
elseif_list (230)
    on left: 143 145, on right: 38 145
@34 (231)
    on left: 144, on right: 145
new_elseif_list (232)
    on left: 146 148, on right: 41 148
@35 (233)
    on left: 147, on right: 148
else_single (234)
    on left: 149 150, on right: 38
new_else_single (235)
    on left: 151 152, on right: 41
parameter_list (236)
    on left: 153 154, on right: 100 191 334 336
non_empty_parameter_list (237)
    on left: 155 156 157 158 159 160 161 162, on right: 153 159 160
    161 162
optional_class_type (238)
    on left: 163 164 165 166, on right: 155 156 157 158 159 160 161
    162
function_call_parameter_list (239)
    on left: 167 168, on right: 345 347 349 351 353 355 357 359 383
    440
non_empty_function_call_parameter_list (240)
    on left: 169 170 171 172 173 174, on right: 167 172 173 174
global_var_list (241)
    on left: 175 176, on right: 61 175
global_var (242)
    on left: 177 178 179, on right: 175 176
static_var_list (243)
    on left: 180 181 182 183, on right: 62 180 181
class_statement_list (244)
    on left: 184 185, on right: 102 104 184
class_statement (245)
    on left: 187 188 189 191, on right: 184
@36 (246)
    on left: 186, on right: 187
@37 (247)
    on left: 190, on right: 191
trait_use_statement (248)
    on left: 192, on right: 189
trait_list (249)
    on left: 193 194, on right: 192 194
trait_adaptations (250)
    on left: 195 196, on right: 192
trait_adaptation_list (251)
    on left: 197 198, on right: 196
non_empty_trait_adaptation_list (252)
    on left: 199 200, on right: 198 200
trait_adaptation_statement (253)
    on left: 201 202, on right: 199 200
trait_precedence (254)
    on left: 203, on right: 201
trait_reference_list (255)
    on left: 204 205, on right: 203 205
trait_method_reference (256)
    on left: 206 207, on right: 209 210
trait_method_reference_fully_qualified (257)
    on left: 208, on right: 203 207
trait_alias (258)
    on left: 209 210, on right: 202
trait_modifiers (259)
    on left: 211 212, on right: 209
method_body (260)
    on left: 213 214, on right: 191
variable_modifiers (261)
    on left: 215 216, on right: 187
method_modifiers (262)
    on left: 217 218, on right: 191
non_empty_member_modifiers (263)
    on left: 219 220, on right: 215 218 220
member_modifier (264)
    on left: 221 222 223 224 225 226, on right: 210 212 219 220
class_variable_declaration (265)
    on left: 227 228 229 230, on right: 187 227 228
class_constant_declaration (266)
    on left: 231 232, on right: 188 231
echo_expr_list (267)
    on left: 233 234, on right: 63 233
for_expr (268)
    on left: 235 236, on right: 51
non_empty_for_expr (269)
    on left: 238 239, on right: 236 238
@38 (270)
    on left: 237, on right: 238
chaining_method_or_property (271)
    on left: 240 241, on right: 240 245 247
chaining_dereference (272)
    on left: 242 243, on right: 242 245 246
chaining_instance_call (273)
    on left: 245 246 247, on right: 250
@39 (274)
    on left: 244, on right: 245
instance_call (275)
    on left: 248 250, on right: 311
@40 (276)
    on left: 249, on right: 250
new_expr (277)
    on left: 252, on right: 309 311
@41 (278)
    on left: 251, on right: 252
expr_without_variable (279)
    on left: 254 255 256 258 259 260 261 262 263 264 265 266 267 268
    269 270 271 272 273 274 276 278 280 282 283 284 285 286 287 288
    289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304
    305 306 307 308 309 311 314 316 317 318 319 320 321 322 323 324
    325 327 328 329 330 331 332 334 336, on right: 59 72 169 172 425
@42 (280)
    on left: 253, on right: 254
@43 (281)
    on left: 257, on right: 258
@44 (282)
    on left: 275, on right: 276
@45 (283)
    on left: 277, on right: 278
@46 (284)
    on left: 279, on right: 280
@47 (285)
    on left: 281, on right: 282
@48 (286)
    on left: 310, on right: 311
@49 (287)
    on left: 312, on right: 314
@50 (288)
    on left: 313, on right: 314
@51 (289)
    on left: 315, on right: 316
@52 (290)
    on left: 326, on right: 327
@53 (291)
    on left: 333, on right: 334
@54 (292)
    on left: 335, on right: 336
function (293)
    on left: 337, on right: 100 191 334 336
lexical_vars (294)
    on left: 338 339, on right: 334 336
lexical_var_list (295)
    on left: 340 341 342 343, on right: 339 340 341
function_call (296)
    on left: 345 347 349 351 353 355 357 359, on right: 451 454
@55 (297)
    on left: 344, on right: 345
@56 (298)
    on left: 346, on right: 347
@57 (299)
    on left: 348, on right: 349
@58 (300)
    on left: 350, on right: 351
@59 (301)
    on left: 352, on right: 353
@60 (302)
    on left: 354, on right: 355
@61 (303)
    on left: 356, on right: 357
@62 (304)
    on left: 358, on right: 359
class_name (305)
    on left: 360 361 362 363, on right: 351 353 367 406 446 515
fully_qualified_class_name (306)
    on left: 364 365 366, on right: 81 91 110 116 117 166 193 194 204
    205 208
class_name_reference (307)
    on left: 367 368, on right: 252 258 307
dynamic_class_name_reference (308)
    on left: 371 372, on right: 368
@63 (309)
    on left: 369, on right: 371
@64 (310)
    on left: 370, on right: 371
dynamic_class_name_variable_properties (311)
    on left: 373 374, on right: 371 373
dynamic_class_name_variable_property (312)
    on left: 375, on right: 373
exit_expr (313)
    on left: 376 377 378, on right: 325
backticks_expr (314)
    on left: 379 380 381, on right: 331
ctor_arguments (315)
    on left: 382 383, on right: 252 258
common_scalar (316)
    on left: 384 385 386 387 388 389 390 391 392 393 394 395,
    on right: 396 412
static_scalar (317)
    on left: 396 397 398 399 400 401 402 403 404 405,
    on right: 24 25 128 129 157 158 161 162 181 183 228 230 231 232
    400 401 420 421 422 423
static_class_constant (318)
    on left: 406, on right: 404
scalar (319)
    on left: 407 408 409 410 411 412 413 414 415, on right: 328
static_array_pair_list (320)
    on left: 416 417, on right: 402 403
possible_comma (321)
    on left: 418 419, on right: 417 482
non_empty_static_array_pair_list (322)
    on left: 420 421 422 423, on right: 417 420 421
expr (323)
    on left: 424 425, on right: 38 41 44 47 53 55 57 65 82 136 145
    148 179 233 234 238 239 254 255 259 260 261 262 263 264 265 266
    267 268 269 270 276 278 280 282 283 284 285 286 287 288 289 290
    291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306
    307 308 314 316 318 319 320 321 322 323 324 327 332 378 459 462
    464 469 472 483 484 485 486 487 489 499 500 507 508 509 510 511
r_variable (324)
    on left: 426, on right: 178 424
w_variable (325)
    on left: 427, on right: 171 174 487 488 489 490
rw_variable (326)
    on left: 428, on right: 271 272 273 274
variable (327)
    on left: 431 432, on right: 60 69 72 94 120 121 170 173 255 256
    258 260 261 262 263 264 265 266 267 268 269 270 426 427 428 477
    501 506 512 514
@65 (328)
    on left: 429, on right: 431
@66 (329)
    on left: 430, on right: 431
variable_properties (330)
    on left: 433 434, on right: 431 433
variable_property (331)
    on left: 436, on right: 240 241 433
@67 (332)
    on left: 435, on right: 436
array_method_dereference (333)
    on left: 437 438, on right: 437 442
method (334)
    on left: 440, on right: 438 441
@68 (335)
    on left: 439, on right: 440
method_or_not (336)
    on left: 441 442 443, on right: 431 436
variable_without_objects (337)
    on left: 444 445, on right: 353 357 359 446 447 467
static_member (338)
    on left: 446 447, on right: 457
variable_class_name (339)
    on left: 448, on right: 355 357 447 516
array_function_dereference (340)
    on left: 449 451, on right: 449 453
@69 (341)
    on left: 450, on right: 451
base_variable_with_function_calls (342)
    on left: 452 453 454, on right: 431 432
base_variable (343)
    on left: 455 456 457, on right: 371 372 452
reference_variable (344)
    on left: 458 459 460, on right: 444 445 448 455 456 458 459
compound_variable (345)
    on left: 461 462, on right: 460
dim_offset (346)
    on left: 463 464, on right: 242 243 437 438 449 451 458 468
object_property (347)
    on left: 465 467, on right: 371 375 431 436
@70 (348)
    on left: 466, on right: 467
object_dim_list (349)
    on left: 468 469 470, on right: 465 468 469
variable_name (350)
    on left: 471 472, on right: 351 355 470
simple_indirect_reference (351)
    on left: 473 474, on right: 445 456 474
assignment_list (352)
    on left: 475 476, on right: 254 475 479
assignment_list_element (353)
    on left: 477 479 480, on right: 475 476
@71 (354)
    on left: 478, on right: 479
array_pair_list (355)
    on left: 481 482, on right: 329 330
non_empty_array_pair_list (356)
    on left: 483 484 485 486 487 488 489 490, on right: 482 483 484
    487 488
encaps_list (357)
    on left: 491 492 493 494, on right: 381 413 414 491 492
encaps_var (358)
    on left: 495 497 498 499 500 501, on right: 491 493 494
@72 (359)
    on left: 496, on right: 497
encaps_var_offset (360)
    on left: 502 503 504, on right: 497
internal_functions_in_yacc (361)
    on left: 505 506 507 508 509 510 511, on right: 317
isset_variables (362)
    on left: 512 514, on right: 505 514
@73 (363)
    on left: 513, on right: 514
class_constant (364)
    on left: 515 516, on right: 408


state 0

    $default	reduce using rule 4 (top_statement_list)

    start	go to state 983
    top_statement_list	go to state 1



state 1

    start  ->  top_statement_list .   (rule 1)
    top_statement_list  ->  top_statement_list . @1 top_statement   (rule 3)

    $   	reduce using rule 1 (start)
    $default	reduce using rule 2 (@1)

    @1  	go to state 2



state 2

    top_statement_list  ->  top_statement_list @1 . top_statement   (rule 3)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "const (T_CONST)"	shift, and go to state 47
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "use (T_USE)"	shift, and go to state 51
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "abstract (T_ABSTRACT)"	shift, and go to state 54
    "final (T_FINAL)"	shift, and go to state 55
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "__halt_compiler (T_HALT_COMPILER)"	shift, and go to state 59
    "class (T_CLASS)"	shift, and go to state 60
    "trait (T_TRAIT)"	shift, and go to state 61
    "interface (T_INTERFACE)"	shift, and go to state 62
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 72
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    top_statement	go to state 83
    constant_declaration	go to state 84
    statement	go to state 85
    unticked_statement	go to state 86
    function_declaration_statement	go to state 87
    class_declaration_statement	go to state 88
    unticked_function_declaration_statement	go to state 89
    unticked_class_declaration_statement	go to state 90
    class_entry_type	go to state 91
    interface_entry	go to state 92
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 95
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 3

    unticked_statement  ->  "hellowork (T_HELLOWORK)" . ';'   (rule 84)

    ';' 	shift, and go to state 115



state 4

    internal_functions_in_yacc  ->  "include (T_INCLUDE)" . expr   (rule 507)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 120
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 5

    internal_functions_in_yacc  ->  "include_once (T_INCLUDE_ONCE)" . expr   (rule 508)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 121
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 6

    internal_functions_in_yacc  ->  "eval (T_EVAL)" . '(' expr ')'   (rule 509)

    '(' 	shift, and go to state 122



state 7

    internal_functions_in_yacc  ->  "require (T_REQUIRE)" . expr   (rule 510)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 123
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 8

    internal_functions_in_yacc  ->  "require_once (T_REQUIRE_ONCE)" . expr   (rule 511)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 124
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 9

    expr_without_variable  ->  "print (T_PRINT)" . expr   (rule 332)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 125
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 10

    expr_without_variable  ->  '+' . expr   (rule 295)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 126
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 11

    expr_without_variable  ->  '-' . expr   (rule 296)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 127
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 12

    expr_without_variable  ->  '!' . expr   (rule 297)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 128
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 13

    expr_without_variable  ->  '~' . expr   (rule 298)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 129
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 14

    expr_without_variable  ->  "++ (T_INC)" . rw_variable   (rule 272)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    rw_variable	go to state 135
    variable	go to state 136
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 15

    expr_without_variable  ->  "-- (T_DEC)" . rw_variable   (rule 274)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    rw_variable	go to state 138
    variable	go to state 136
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 16

    expr_without_variable  ->  "(int) (T_INT_CAST)" . expr   (rule 318)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 139
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 17

    expr_without_variable  ->  "(double) (T_DOUBLE_CAST)" . expr   (rule 319)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 140
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 18

    expr_without_variable  ->  "(string) (T_STRING_CAST)" . expr   (rule 320)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 141
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 19

    expr_without_variable  ->  "(array) (T_ARRAY_CAST)" . expr   (rule 321)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 142
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 20

    expr_without_variable  ->  "(object) (T_OBJECT_CAST)" . expr   (rule 322)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 143
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 21

    expr_without_variable  ->  "(bool) (T_BOOL_CAST)" . expr   (rule 323)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 144
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 22

    expr_without_variable  ->  "(unset) (T_UNSET_CAST)" . expr   (rule 324)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 145
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 23

    expr_without_variable  ->  '@' . @52 expr   (rule 327)

    $default	reduce using rule 326 (@52)

    @52 	go to state 146



state 24

    expr_without_variable  ->  '[' . array_pair_list ']'   (rule 330)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 147
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 481 (array_pair_list)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 148
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    array_pair_list	go to state 149
    non_empty_array_pair_list	go to state 150
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 25

    new_expr  ->  "new (T_NEW)" . class_name_reference @41 ctor_arguments   (rule 252)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 151
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 152
    '$' 	shift, and go to state 79

    namespace_name	go to state 153
    class_name	go to state 154
    class_name_reference	go to state 155
    dynamic_class_name_reference	go to state 156
    static_member	go to state 105
    variable_class_name	go to state 157
    base_variable	go to state 158
    reference_variable	go to state 159
    compound_variable	go to state 111
    simple_indirect_reference	go to state 160



state 26

    expr_without_variable  ->  "clone (T_CLONE)" . expr   (rule 259)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 161
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 27

    expr_without_variable  ->  "exit (T_EXIT)" . exit_expr   (rule 325)

    '(' 	shift, and go to state 162

    $default	reduce using rule 376 (exit_expr)

    exit_expr	go to state 163



state 28

    unticked_statement  ->  "if (T_IF)" . '(' expr ')' @5 statement @6 elseif_list else_single   (rule 38)
    unticked_statement  ->  "if (T_IF)" . '(' expr ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    '(' 	shift, and go to state 164



state 29

    common_scalar  ->  "integer number (T_LNUMBER)" .   (rule 384)

    $default	reduce using rule 384 (common_scalar)



state 30

    common_scalar  ->  "floating-point number (T_DNUMBER)" .   (rule 385)

    $default	reduce using rule 385 (common_scalar)



state 31

    namespace_name  ->  "identifier (T_STRING)" .   (rule 5)
    statement  ->  "identifier (T_STRING)" . ':'   (rule 34)

    ':' 	shift, and go to state 165

    $default	reduce using rule 5 (namespace_name)



state 32

    scalar  ->  "variable name (T_STRING_VARNAME)" .   (rule 407)

    $default	reduce using rule 407 (scalar)



state 33

    compound_variable  ->  "variable (T_VARIABLE)" .   (rule 461)

    $default	reduce using rule 461 (compound_variable)



state 34

    unticked_statement  ->  T_INLINE_HTML .   (rule 64)

    $default	reduce using rule 64 (unticked_statement)



state 35

    common_scalar  ->  "quoted-string (T_CONSTANT_ENCAPSED_STRING)" .   (rule 386)

    $default	reduce using rule 386 (common_scalar)



state 36

    unticked_statement  ->  "echo (T_ECHO)" . echo_expr_list ';'   (rule 63)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    echo_expr_list	go to state 166
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 167
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 37

    unticked_statement  ->  "do (T_DO)" . @11 statement "while (T_WHILE)" '(' @12 expr ')' ';'   (rule 47)

    $default	reduce using rule 45 (@11)

    @11 	go to state 168



state 38

    unticked_statement  ->  "while (T_WHILE)" . '(' @9 expr ')' @10 while_statement   (rule 44)

    '(' 	shift, and go to state 169



state 39

    unticked_statement  ->  "for (T_FOR)" . '(' for_expr ';' @13 for_expr ';' @14 for_expr ')' @15 for_statement   (rule 51)

    '(' 	shift, and go to state 170



state 40

    unticked_statement  ->  "foreach (T_FOREACH)" . '(' variable "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' @18 foreach_statement   (rule 69)
    unticked_statement  ->  "foreach (T_FOREACH)" . '(' expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg ')' @20 foreach_statement   (rule 72)

    '(' 	shift, and go to state 171



state 41

    unticked_statement  ->  "declare (T_DECLARE)" . @21 '(' declare_list ')' declare_statement   (rule 74)

    $default	reduce using rule 73 (@21)

    @21 	go to state 172



state 42

    unticked_statement  ->  "switch (T_SWITCH)" . '(' expr ')' @16 switch_case_list   (rule 53)

    '(' 	shift, and go to state 173



state 43

    unticked_statement  ->  "break (T_BREAK)" . ';'   (rule 54)
    unticked_statement  ->  "break (T_BREAK)" . expr ';'   (rule 55)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 174
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 175
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 44

    unticked_statement  ->  "continue (T_CONTINUE)" . ';'   (rule 56)
    unticked_statement  ->  "continue (T_CONTINUE)" . expr ';'   (rule 57)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 176
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 177
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 45

    unticked_statement  ->  "goto (T_GOTO)" . "identifier (T_STRING)" ';'   (rule 83)

    "identifier (T_STRING)"	shift, and go to state 178



state 46

    function  ->  "function (T_FUNCTION)" .   (rule 337)

    $default	reduce using rule 337 (function)



state 47

    constant_declaration  ->  "const (T_CONST)" . "identifier (T_STRING)" '=' static_scalar   (rule 25)

    "identifier (T_STRING)"	shift, and go to state 179



state 48

    unticked_statement  ->  "return (T_RETURN)" . ';'   (rule 58)
    unticked_statement  ->  "return (T_RETURN)" . expr_without_variable ';'   (rule 59)
    unticked_statement  ->  "return (T_RETURN)" . variable ';'   (rule 60)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 180
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 181
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 183
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 49

    unticked_statement  ->  "try (T_TRY)" . @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    $default	reduce using rule 76 (@22)

    @22 	go to state 184



state 50

    unticked_statement  ->  "throw (T_THROW)" . expr ';'   (rule 82)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 185
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 51

    top_statement  ->  "use (T_USE)" . use_declarations ';'   (rule 16)

    "identifier (T_STRING)"	shift, and go to state 116
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 186

    namespace_name	go to state 187
    use_declarations	go to state 188
    use_declaration	go to state 189



state 52

    unticked_statement  ->  "global (T_GLOBAL)" . global_var_list ';'   (rule 61)

    "variable (T_VARIABLE)"	shift, and go to state 190
    '$' 	shift, and go to state 191

    global_var_list	go to state 192
    global_var	go to state 193



state 53

    unticked_statement  ->  "static (T_STATIC)" . static_var_list ';'   (rule 62)
    expr_without_variable  ->  "static (T_STATIC)" . function is_reference '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 336)
    class_name  ->  "static (T_STATIC)" .   (rule 360)

    "variable (T_VARIABLE)"	shift, and go to state 194
    "function (T_FUNCTION)"	shift, and go to state 46

    $default	reduce using rule 360 (class_name)

    static_var_list	go to state 195
    function	go to state 196



state 54

    class_entry_type  ->  "abstract (T_ABSTRACT)" . "class (T_CLASS)"   (rule 106)

    "class (T_CLASS)"	shift, and go to state 197



state 55

    class_entry_type  ->  "final (T_FINAL)" . "class (T_CLASS)"   (rule 108)

    "class (T_CLASS)"	shift, and go to state 198



state 56

    unticked_statement  ->  "unset (T_UNSET)" . '(' unset_variables ')' ';'   (rule 66)

    '(' 	shift, and go to state 199



state 57

    internal_functions_in_yacc  ->  "isset (T_ISSET)" . '(' isset_variables ')'   (rule 505)

    '(' 	shift, and go to state 200



state 58

    internal_functions_in_yacc  ->  "empty (T_EMPTY)" . '(' variable ')'   (rule 506)

    '(' 	shift, and go to state 201



state 59

    top_statement  ->  "__halt_compiler (T_HALT_COMPILER)" . '(' ')' ';'   (rule 10)

    '(' 	shift, and go to state 202



state 60

    class_entry_type  ->  "class (T_CLASS)" .   (rule 105)

    $default	reduce using rule 105 (class_entry_type)



state 61

    class_entry_type  ->  "trait (T_TRAIT)" .   (rule 107)

    $default	reduce using rule 107 (class_entry_type)



state 62

    interface_entry  ->  "interface (T_INTERFACE)" .   (rule 111)

    $default	reduce using rule 111 (interface_entry)



state 63

    expr_without_variable  ->  "list (T_LIST)" . '(' @42 assignment_list ')' '=' expr   (rule 254)

    '(' 	shift, and go to state 203



state 64

    expr_without_variable  ->  "array (T_ARRAY)" . '(' array_pair_list ')'   (rule 329)

    '(' 	shift, and go to state 204



state 65

    scalar  ->  "__CLASS__ (T_CLASS_C)" .   (rule 415)

    $default	reduce using rule 415 (scalar)



state 66

    common_scalar  ->  "__TRAIT__ (T_TRAIT_C)" .   (rule 390)

    $default	reduce using rule 390 (common_scalar)



state 67

    common_scalar  ->  "__METHOD__ (T_METHOD_C)" .   (rule 391)

    $default	reduce using rule 391 (common_scalar)



state 68

    common_scalar  ->  "__FUNCTION__ (T_FUNC_C)" .   (rule 392)

    $default	reduce using rule 392 (common_scalar)



state 69

    common_scalar  ->  "__LINE__ (T_LINE)" .   (rule 387)

    $default	reduce using rule 387 (common_scalar)



state 70

    common_scalar  ->  "__FILE__ (T_FILE)" .   (rule 388)

    $default	reduce using rule 388 (common_scalar)



state 71

    common_scalar  ->  "heredoc start (T_START_HEREDOC)" . "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" "heredoc end (T_END_HEREDOC)"   (rule 394)
    common_scalar  ->  "heredoc start (T_START_HEREDOC)" . "heredoc end (T_END_HEREDOC)"   (rule 395)
    scalar  ->  "heredoc start (T_START_HEREDOC)" . encaps_list "heredoc end (T_END_HEREDOC)"   (rule 414)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 206
    "heredoc end (T_END_HEREDOC)"	shift, and go to state 207
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    encaps_list	go to state 210
    encaps_var	go to state 211



state 72

    top_statement  ->  "namespace (T_NAMESPACE)" . namespace_name ';'   (rule 11)
    top_statement  ->  "namespace (T_NAMESPACE)" . namespace_name '{' @2 top_statement_list '}'   (rule 13)
    top_statement  ->  "namespace (T_NAMESPACE)" . '{' @3 top_statement_list '}'   (rule 15)
    function_call  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 362)
    scalar  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 410)

    "identifier (T_STRING)"	shift, and go to state 116
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 212
    '{' 	shift, and go to state 213

    namespace_name	go to state 214



state 73

    common_scalar  ->  "__NAMESPACE__ (T_NS_C)" .   (rule 393)

    $default	reduce using rule 393 (common_scalar)



state 74

    common_scalar  ->  "__DIR__ (T_DIR)" .   (rule 389)

    $default	reduce using rule 389 (common_scalar)



state 75

    function_call  ->  "\\ (T_NS_SEPARATOR)" . namespace_name '(' @57 function_call_parameter_list ')'   (rule 349)
    class_name  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 363)
    scalar  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 411)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 215



state 76

    expr_without_variable  ->  '(' . expr ')'   (rule 308)
    expr_without_variable  ->  '(' . new_expr ')' @48 instance_call   (rule 311)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 216
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 217
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 77

    unticked_statement  ->  ';' .   (rule 75)

    $default	reduce using rule 75 (unticked_statement)



state 78

    unticked_statement  ->  '{' . inner_statement_list '}'   (rule 35)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 218



state 79

    compound_variable  ->  '$' . '{' expr '}'   (rule 462)
    simple_indirect_reference  ->  '$' .   (rule 473)

    '{' 	shift, and go to state 219

    $default	reduce using rule 473 (simple_indirect_reference)



state 80

    expr_without_variable  ->  '`' . backticks_expr '`'   (rule 331)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 220
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    $default	reduce using rule 379 (backticks_expr)

    backticks_expr	go to state 221
    encaps_list	go to state 222
    encaps_var	go to state 211



state 81

    scalar  ->  '\"' . encaps_list '\"'   (rule 413)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 223
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    encaps_list	go to state 224
    encaps_var	go to state 211



state 82

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    function_call  ->  namespace_name . '(' @55 function_call_parameter_list ')'   (rule 345)
    class_name  ->  namespace_name .   (rule 361)
    scalar  ->  namespace_name .   (rule 409)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    '(' 	shift, and go to state 226

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 361 (class_name)
    $default	reduce using rule 409 (scalar)



state 83

    top_statement_list  ->  top_statement_list @1 top_statement .   (rule 3)

    $default	reduce using rule 3 (top_statement_list)



state 84

    top_statement  ->  constant_declaration . ';'   (rule 17)
    constant_declaration  ->  constant_declaration . ',' "identifier (T_STRING)" '=' static_scalar   (rule 24)

    ',' 	shift, and go to state 227
    ';' 	shift, and go to state 228



state 85

    top_statement  ->  statement .   (rule 7)

    $default	reduce using rule 7 (top_statement)



state 86

    statement  ->  unticked_statement .   (rule 33)

    $default	reduce using rule 33 (statement)



state 87

    top_statement  ->  function_declaration_statement .   (rule 8)

    $default	reduce using rule 8 (top_statement)



state 88

    top_statement  ->  class_declaration_statement .   (rule 9)

    $default	reduce using rule 9 (top_statement)



state 89

    function_declaration_statement  ->  unticked_function_declaration_statement .   (rule 95)

    $default	reduce using rule 95 (function_declaration_statement)



state 90

    class_declaration_statement  ->  unticked_class_declaration_statement .   (rule 96)

    $default	reduce using rule 96 (class_declaration_statement)



state 91

    unticked_class_declaration_statement  ->  class_entry_type . "identifier (T_STRING)" extends_from @30 implements_list '{' class_statement_list '}'   (rule 102)

    "identifier (T_STRING)"	shift, and go to state 229



state 92

    unticked_class_declaration_statement  ->  interface_entry . "identifier (T_STRING)" @31 interface_extends_list '{' class_statement_list '}'   (rule 104)

    "identifier (T_STRING)"	shift, and go to state 230



state 93

    expr_without_variable  ->  new_expr .   (rule 309)

    $default	reduce using rule 309 (expr_without_variable)



state 94

    expr  ->  expr_without_variable .   (rule 425)

    $default	reduce using rule 425 (expr)



state 95

    unticked_function_declaration_statement  ->  function . is_reference "identifier (T_STRING)" @29 '(' parameter_list ')' '{' inner_statement_list '}'   (rule 100)
    expr_without_variable  ->  function . is_reference '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    '&' 	shift, and go to state 231

    $default	reduce using rule 97 (is_reference)

    is_reference	go to state 232



state 96

    array_function_dereference  ->  function_call . @69 '[' dim_offset ']'   (rule 451)
    base_variable_with_function_calls  ->  function_call .   (rule 454)

    '[' 	reduce using rule 450 (@69)
    $default	reduce using rule 454 (base_variable_with_function_calls)

    @69 	go to state 233



state 97

    function_call  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @58 function_call_parameter_list ')'   (rule 351)
    function_call  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @59 function_call_parameter_list ')'   (rule 353)
    static_member  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects   (rule 446)
    class_constant  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"   (rule 515)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 234



state 98

    scalar  ->  common_scalar .   (rule 412)

    $default	reduce using rule 412 (scalar)



state 99

    expr_without_variable  ->  scalar .   (rule 328)

    $default	reduce using rule 328 (expr_without_variable)



state 100

    unticked_statement  ->  expr . ';'   (rule 65)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ';' 	shift, and go to state 261



state 101

    expr  ->  r_variable .   (rule 424)

    $default	reduce using rule 424 (expr)



state 102

    expr_without_variable  ->  rw_variable . "++ (T_INC)"   (rule 271)
    expr_without_variable  ->  rw_variable . "-- (T_DEC)"   (rule 273)

    "++ (T_INC)"	shift, and go to state 262
    "-- (T_DEC)"	shift, and go to state 263



state 103

    expr_without_variable  ->  variable . '=' expr   (rule 255)
    expr_without_variable  ->  variable . '=' '&' variable   (rule 256)
    expr_without_variable  ->  variable . '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)
    expr_without_variable  ->  variable . "+= (T_PLUS_EQUAL)" expr   (rule 260)
    expr_without_variable  ->  variable . "-= (T_MINUS_EQUAL)" expr   (rule 261)
    expr_without_variable  ->  variable . "*= (T_MUL_EQUAL)" expr   (rule 262)
    expr_without_variable  ->  variable . "/= (T_DIV_EQUAL)" expr   (rule 263)
    expr_without_variable  ->  variable . ".= (T_CONCAT_EQUAL)" expr   (rule 264)
    expr_without_variable  ->  variable . "%= (T_MOD_EQUAL)" expr   (rule 265)
    expr_without_variable  ->  variable . "&= (T_AND_EQUAL)" expr   (rule 266)
    expr_without_variable  ->  variable . "|= (T_OR_EQUAL)" expr   (rule 267)
    expr_without_variable  ->  variable . "^= (T_XOR_EQUAL)" expr   (rule 268)
    expr_without_variable  ->  variable . "<<= (T_SL_EQUAL)" expr   (rule 269)
    expr_without_variable  ->  variable . ">>= (T_SR_EQUAL)" expr   (rule 270)
    r_variable  ->  variable .   (rule 426)
    rw_variable  ->  variable .   (rule 428)

    '=' 	shift, and go to state 264
    "+= (T_PLUS_EQUAL)"	shift, and go to state 265
    "-= (T_MINUS_EQUAL)"	shift, and go to state 266
    "*= (T_MUL_EQUAL)"	shift, and go to state 267
    "/= (T_DIV_EQUAL)"	shift, and go to state 268
    ".= (T_CONCAT_EQUAL)"	shift, and go to state 269
    "%= (T_MOD_EQUAL)"	shift, and go to state 270
    "&= (T_AND_EQUAL)"	shift, and go to state 271
    "|= (T_OR_EQUAL)"	shift, and go to state 272
    "^= (T_XOR_EQUAL)"	shift, and go to state 273
    "<<= (T_SL_EQUAL)"	shift, and go to state 274
    ">>= (T_SR_EQUAL)"	shift, and go to state 275

    "++ (T_INC)"	reduce using rule 428 (rw_variable)
    "-- (T_DEC)"	reduce using rule 428 (rw_variable)
    $default	reduce using rule 426 (r_variable)



state 104

    function_call  ->  variable_without_objects . '(' @62 function_call_parameter_list ')'   (rule 359)

    '(' 	shift, and go to state 276



state 105

    base_variable  ->  static_member .   (rule 457)

    $default	reduce using rule 457 (base_variable)



state 106

    function_call  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @60 function_call_parameter_list ')'   (rule 355)
    function_call  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @61 function_call_parameter_list ')'   (rule 357)
    static_member  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects   (rule 447)
    class_constant  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"   (rule 516)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 277



state 107

    array_function_dereference  ->  array_function_dereference . '[' dim_offset ']'   (rule 449)
    base_variable_with_function_calls  ->  array_function_dereference .   (rule 453)

    '[' 	shift, and go to state 278

    $default	reduce using rule 453 (base_variable_with_function_calls)



state 108

    variable  ->  base_variable_with_function_calls . "-> (T_OBJECT_OPERATOR)" @65 object_property @66 method_or_not variable_properties   (rule 431)
    variable  ->  base_variable_with_function_calls .   (rule 432)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 279

    $default	reduce using rule 432 (variable)



state 109

    base_variable_with_function_calls  ->  base_variable .   (rule 452)

    $default	reduce using rule 452 (base_variable_with_function_calls)



state 110

    variable_without_objects  ->  reference_variable .   (rule 444)
    variable_class_name  ->  reference_variable .   (rule 448)
    base_variable  ->  reference_variable .   (rule 455)
    reference_variable  ->  reference_variable . '[' dim_offset ']'   (rule 458)
    reference_variable  ->  reference_variable . '{' expr '}'   (rule 459)

    '[' 	shift, and go to state 280
    '{' 	shift, and go to state 281

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 448 (variable_class_name)
    '(' 	reduce using rule 444 (variable_without_objects)
    $default	reduce using rule 455 (base_variable)



state 111

    reference_variable  ->  compound_variable .   (rule 460)

    $default	reduce using rule 460 (reference_variable)



state 112

    variable_without_objects  ->  simple_indirect_reference . reference_variable   (rule 445)
    base_variable  ->  simple_indirect_reference . reference_variable   (rule 456)
    simple_indirect_reference  ->  simple_indirect_reference . '$'   (rule 474)

    "variable (T_VARIABLE)"	shift, and go to state 33
    '$' 	shift, and go to state 282

    reference_variable	go to state 283
    compound_variable	go to state 111



state 113

    expr_without_variable  ->  internal_functions_in_yacc .   (rule 317)

    $default	reduce using rule 317 (expr_without_variable)



state 114

    scalar  ->  class_constant .   (rule 408)

    $default	reduce using rule 408 (scalar)



state 115

    unticked_statement  ->  "hellowork (T_HELLOWORK)" ';' .   (rule 84)

    $default	reduce using rule 84 (unticked_statement)



state 116

    namespace_name  ->  "identifier (T_STRING)" .   (rule 5)

    $default	reduce using rule 5 (namespace_name)



state 117

    expr_without_variable  ->  "static (T_STATIC)" . function is_reference '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 336)
    class_name  ->  "static (T_STATIC)" .   (rule 360)

    "function (T_FUNCTION)"	shift, and go to state 46

    $default	reduce using rule 360 (class_name)

    function	go to state 196



state 118

    function_call  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 362)
    scalar  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 410)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 212



state 119

    expr_without_variable  ->  function . is_reference '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    '&' 	shift, and go to state 231

    $default	reduce using rule 97 (is_reference)

    is_reference	go to state 284



state 120

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    internal_functions_in_yacc  ->  "include (T_INCLUDE)" expr .   (rule 507)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 507 (internal_functions_in_yacc)



state 121

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    internal_functions_in_yacc  ->  "include_once (T_INCLUDE_ONCE)" expr .   (rule 508)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 508 (internal_functions_in_yacc)



state 122

    internal_functions_in_yacc  ->  "eval (T_EVAL)" '(' . expr ')'   (rule 509)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 285
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 123

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    internal_functions_in_yacc  ->  "require (T_REQUIRE)" expr .   (rule 510)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 510 (internal_functions_in_yacc)



state 124

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    internal_functions_in_yacc  ->  "require_once (T_REQUIRE_ONCE)" expr .   (rule 511)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 511 (internal_functions_in_yacc)



state 125

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "print (T_PRINT)" expr .   (rule 332)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 332 (expr_without_variable)



state 126

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  '+' expr .   (rule 295)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)


    $default	reduce using rule 295 (expr_without_variable)



state 127

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  '-' expr .   (rule 296)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)


    $default	reduce using rule 296 (expr_without_variable)



state 128

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  '!' expr .   (rule 297)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 297 (expr_without_variable)



state 129

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  '~' expr .   (rule 298)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)


    $default	reduce using rule 298 (expr_without_variable)



state 130

    class_name  ->  "static (T_STATIC)" .   (rule 360)

    $default	reduce using rule 360 (class_name)



state 131

    function_call  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 362)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 286



state 132

    function_call  ->  "\\ (T_NS_SEPARATOR)" . namespace_name '(' @57 function_call_parameter_list ')'   (rule 349)
    class_name  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 363)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 287



state 133

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    function_call  ->  namespace_name . '(' @55 function_call_parameter_list ')'   (rule 345)
    class_name  ->  namespace_name .   (rule 361)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    '(' 	shift, and go to state 226

    $default	reduce using rule 361 (class_name)



state 134

    function_call  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @58 function_call_parameter_list ')'   (rule 351)
    function_call  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @59 function_call_parameter_list ')'   (rule 353)
    static_member  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects   (rule 446)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 288



state 135

    expr_without_variable  ->  "++ (T_INC)" rw_variable .   (rule 272)

    $default	reduce using rule 272 (expr_without_variable)



state 136

    rw_variable  ->  variable .   (rule 428)

    $default	reduce using rule 428 (rw_variable)



state 137

    function_call  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @60 function_call_parameter_list ')'   (rule 355)
    function_call  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @61 function_call_parameter_list ')'   (rule 357)
    static_member  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects   (rule 447)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 289



state 138

    expr_without_variable  ->  "-- (T_DEC)" rw_variable .   (rule 274)

    $default	reduce using rule 274 (expr_without_variable)



state 139

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(int) (T_INT_CAST)" expr .   (rule 318)


    $default	reduce using rule 318 (expr_without_variable)



state 140

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(double) (T_DOUBLE_CAST)" expr .   (rule 319)


    $default	reduce using rule 319 (expr_without_variable)



state 141

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(string) (T_STRING_CAST)" expr .   (rule 320)


    $default	reduce using rule 320 (expr_without_variable)



state 142

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(array) (T_ARRAY_CAST)" expr .   (rule 321)


    $default	reduce using rule 321 (expr_without_variable)



state 143

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(object) (T_OBJECT_CAST)" expr .   (rule 322)


    $default	reduce using rule 322 (expr_without_variable)



state 144

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(bool) (T_BOOL_CAST)" expr .   (rule 323)


    $default	reduce using rule 323 (expr_without_variable)



state 145

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  "(unset) (T_UNSET_CAST)" expr .   (rule 324)


    $default	reduce using rule 324 (expr_without_variable)



state 146

    expr_without_variable  ->  '@' @52 . expr   (rule 327)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 290
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 147

    non_empty_array_pair_list  ->  '&' . w_variable   (rule 490)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    w_variable	go to state 291
    variable	go to state 292
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 148

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    non_empty_array_pair_list  ->  expr . "=> (T_DOUBLE_ARROW)" expr   (rule 485)
    non_empty_array_pair_list  ->  expr .   (rule 486)
    non_empty_array_pair_list  ->  expr . "=> (T_DOUBLE_ARROW)" '&' w_variable   (rule 489)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    "=> (T_DOUBLE_ARROW)"	shift, and go to state 293

    $default	reduce using rule 486 (non_empty_array_pair_list)



state 149

    expr_without_variable  ->  '[' array_pair_list . ']'   (rule 330)

    ']' 	shift, and go to state 294



state 150

    array_pair_list  ->  non_empty_array_pair_list . possible_comma   (rule 482)
    non_empty_array_pair_list  ->  non_empty_array_pair_list . ',' expr "=> (T_DOUBLE_ARROW)" expr   (rule 483)
    non_empty_array_pair_list  ->  non_empty_array_pair_list . ',' expr   (rule 484)
    non_empty_array_pair_list  ->  non_empty_array_pair_list . ',' expr "=> (T_DOUBLE_ARROW)" '&' w_variable   (rule 487)
    non_empty_array_pair_list  ->  non_empty_array_pair_list . ',' '&' w_variable   (rule 488)

    ',' 	shift, and go to state 295

    $default	reduce using rule 418 (possible_comma)

    possible_comma	go to state 296



state 151

    class_name  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 362)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 297



state 152

    class_name  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 363)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 298



state 153

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    class_name  ->  namespace_name .   (rule 361)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 361 (class_name)



state 154

    class_name_reference  ->  class_name .   (rule 367)
    static_member  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects   (rule 446)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 299

    $default	reduce using rule 367 (class_name_reference)



state 155

    new_expr  ->  "new (T_NEW)" class_name_reference . @41 ctor_arguments   (rule 252)

    $default	reduce using rule 251 (@41)

    @41 	go to state 300



state 156

    class_name_reference  ->  dynamic_class_name_reference .   (rule 368)

    $default	reduce using rule 368 (class_name_reference)



state 157

    static_member  ->  variable_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects   (rule 447)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 301



state 158

    dynamic_class_name_reference  ->  base_variable . "-> (T_OBJECT_OPERATOR)" @63 object_property @64 dynamic_class_name_variable_properties   (rule 371)
    dynamic_class_name_reference  ->  base_variable .   (rule 372)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 302

    $default	reduce using rule 372 (dynamic_class_name_reference)



state 159

    variable_class_name  ->  reference_variable .   (rule 448)
    base_variable  ->  reference_variable .   (rule 455)
    reference_variable  ->  reference_variable . '[' dim_offset ']'   (rule 458)
    reference_variable  ->  reference_variable . '{' expr '}'   (rule 459)

    '[' 	shift, and go to state 280
    '{' 	shift, and go to state 281

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 448 (variable_class_name)
    $default	reduce using rule 455 (base_variable)



state 160

    base_variable  ->  simple_indirect_reference . reference_variable   (rule 456)
    simple_indirect_reference  ->  simple_indirect_reference . '$'   (rule 474)

    "variable (T_VARIABLE)"	shift, and go to state 33
    '$' 	shift, and go to state 282

    reference_variable	go to state 303
    compound_variable	go to state 111



state 161

    expr_without_variable  ->  "clone (T_CLONE)" expr .   (rule 259)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)


    $default	reduce using rule 259 (expr_without_variable)



state 162

    exit_expr  ->  '(' . ')'   (rule 377)
    exit_expr  ->  '(' . expr ')'   (rule 378)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ')' 	shift, and go to state 304
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 305
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 163

    expr_without_variable  ->  "exit (T_EXIT)" exit_expr .   (rule 325)

    $default	reduce using rule 325 (expr_without_variable)



state 164

    unticked_statement  ->  "if (T_IF)" '(' . expr ')' @5 statement @6 elseif_list else_single   (rule 38)
    unticked_statement  ->  "if (T_IF)" '(' . expr ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 306
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 165

    statement  ->  "identifier (T_STRING)" ':' .   (rule 34)

    $default	reduce using rule 34 (statement)



state 166

    unticked_statement  ->  "echo (T_ECHO)" echo_expr_list . ';'   (rule 63)
    echo_expr_list  ->  echo_expr_list . ',' expr   (rule 233)

    ',' 	shift, and go to state 307
    ';' 	shift, and go to state 308



state 167

    echo_expr_list  ->  expr .   (rule 234)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 234 (echo_expr_list)



state 168

    unticked_statement  ->  "do (T_DO)" @11 . statement "while (T_WHILE)" '(' @12 expr ')' ';'   (rule 47)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 309
    unticked_statement	go to state 86
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 169

    unticked_statement  ->  "while (T_WHILE)" '(' . @9 expr ')' @10 while_statement   (rule 44)

    $default	reduce using rule 42 (@9)

    @9  	go to state 310



state 170

    unticked_statement  ->  "for (T_FOR)" '(' . for_expr ';' @13 for_expr ';' @14 for_expr ')' @15 for_statement   (rule 51)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 235 (for_expr)

    namespace_name	go to state 82
    for_expr	go to state 311
    non_empty_for_expr	go to state 312
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 313
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 171

    unticked_statement  ->  "foreach (T_FOREACH)" '(' . variable "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' @18 foreach_statement   (rule 69)
    unticked_statement  ->  "foreach (T_FOREACH)" '(' . expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg ')' @20 foreach_statement   (rule 72)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 314
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 315
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 172

    unticked_statement  ->  "declare (T_DECLARE)" @21 . '(' declare_list ')' declare_statement   (rule 74)

    '(' 	shift, and go to state 316



state 173

    unticked_statement  ->  "switch (T_SWITCH)" '(' . expr ')' @16 switch_case_list   (rule 53)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 317
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 174

    unticked_statement  ->  "break (T_BREAK)" ';' .   (rule 54)

    $default	reduce using rule 54 (unticked_statement)



state 175

    unticked_statement  ->  "break (T_BREAK)" expr . ';'   (rule 55)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ';' 	shift, and go to state 318



state 176

    unticked_statement  ->  "continue (T_CONTINUE)" ';' .   (rule 56)

    $default	reduce using rule 56 (unticked_statement)



state 177

    unticked_statement  ->  "continue (T_CONTINUE)" expr . ';'   (rule 57)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ';' 	shift, and go to state 319



state 178

    unticked_statement  ->  "goto (T_GOTO)" "identifier (T_STRING)" . ';'   (rule 83)

    ';' 	shift, and go to state 320



state 179

    constant_declaration  ->  "const (T_CONST)" "identifier (T_STRING)" . '=' static_scalar   (rule 25)

    '=' 	shift, and go to state 321



state 180

    unticked_statement  ->  "return (T_RETURN)" ';' .   (rule 58)

    $default	reduce using rule 58 (unticked_statement)



state 181

    unticked_statement  ->  "return (T_RETURN)" expr_without_variable . ';'   (rule 59)
    expr  ->  expr_without_variable .   (rule 425)

    ';' 	shift, and go to state 322

    $default	reduce using rule 425 (expr)



state 182

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260



state 183

    unticked_statement  ->  "return (T_RETURN)" variable . ';'   (rule 60)
    expr_without_variable  ->  variable . '=' expr   (rule 255)
    expr_without_variable  ->  variable . '=' '&' variable   (rule 256)
    expr_without_variable  ->  variable . '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)
    expr_without_variable  ->  variable . "+= (T_PLUS_EQUAL)" expr   (rule 260)
    expr_without_variable  ->  variable . "-= (T_MINUS_EQUAL)" expr   (rule 261)
    expr_without_variable  ->  variable . "*= (T_MUL_EQUAL)" expr   (rule 262)
    expr_without_variable  ->  variable . "/= (T_DIV_EQUAL)" expr   (rule 263)
    expr_without_variable  ->  variable . ".= (T_CONCAT_EQUAL)" expr   (rule 264)
    expr_without_variable  ->  variable . "%= (T_MOD_EQUAL)" expr   (rule 265)
    expr_without_variable  ->  variable . "&= (T_AND_EQUAL)" expr   (rule 266)
    expr_without_variable  ->  variable . "|= (T_OR_EQUAL)" expr   (rule 267)
    expr_without_variable  ->  variable . "^= (T_XOR_EQUAL)" expr   (rule 268)
    expr_without_variable  ->  variable . "<<= (T_SL_EQUAL)" expr   (rule 269)
    expr_without_variable  ->  variable . ">>= (T_SR_EQUAL)" expr   (rule 270)
    r_variable  ->  variable .   (rule 426)
    rw_variable  ->  variable .   (rule 428)

    '=' 	shift, and go to state 264
    "+= (T_PLUS_EQUAL)"	shift, and go to state 265
    "-= (T_MINUS_EQUAL)"	shift, and go to state 266
    "*= (T_MUL_EQUAL)"	shift, and go to state 267
    "/= (T_DIV_EQUAL)"	shift, and go to state 268
    ".= (T_CONCAT_EQUAL)"	shift, and go to state 269
    "%= (T_MOD_EQUAL)"	shift, and go to state 270
    "&= (T_AND_EQUAL)"	shift, and go to state 271
    "|= (T_OR_EQUAL)"	shift, and go to state 272
    "^= (T_XOR_EQUAL)"	shift, and go to state 273
    "<<= (T_SL_EQUAL)"	shift, and go to state 274
    ">>= (T_SR_EQUAL)"	shift, and go to state 275
    ';' 	shift, and go to state 323

    "++ (T_INC)"	reduce using rule 428 (rw_variable)
    "-- (T_DEC)"	reduce using rule 428 (rw_variable)
    $default	reduce using rule 426 (r_variable)



state 184

    unticked_statement  ->  "try (T_TRY)" @22 . '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    '{' 	shift, and go to state 324



state 185

    unticked_statement  ->  "throw (T_THROW)" expr . ';'   (rule 82)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ';' 	shift, and go to state 325



state 186

    use_declaration  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 22)
    use_declaration  ->  "\\ (T_NS_SEPARATOR)" . namespace_name "as (T_AS)" "identifier (T_STRING)"   (rule 23)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 326



state 187

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    use_declaration  ->  namespace_name .   (rule 20)
    use_declaration  ->  namespace_name . "as (T_AS)" "identifier (T_STRING)"   (rule 21)

    "as (T_AS)"	shift, and go to state 327
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 20 (use_declaration)



state 188

    top_statement  ->  "use (T_USE)" use_declarations . ';'   (rule 16)
    use_declarations  ->  use_declarations . ',' use_declaration   (rule 18)

    ',' 	shift, and go to state 328
    ';' 	shift, and go to state 329



state 189

    use_declarations  ->  use_declaration .   (rule 19)

    $default	reduce using rule 19 (use_declarations)



state 190

    global_var  ->  "variable (T_VARIABLE)" .   (rule 177)

    $default	reduce using rule 177 (global_var)



state 191

    global_var  ->  '$' . r_variable   (rule 178)
    global_var  ->  '$' . '{' expr '}'   (rule 179)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '{' 	shift, and go to state 330
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    r_variable	go to state 331
    variable	go to state 332
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 192

    unticked_statement  ->  "global (T_GLOBAL)" global_var_list . ';'   (rule 61)
    global_var_list  ->  global_var_list . ',' global_var   (rule 175)

    ',' 	shift, and go to state 333
    ';' 	shift, and go to state 334



state 193

    global_var_list  ->  global_var .   (rule 176)

    $default	reduce using rule 176 (global_var_list)



state 194

    static_var_list  ->  "variable (T_VARIABLE)" .   (rule 182)
    static_var_list  ->  "variable (T_VARIABLE)" . '=' static_scalar   (rule 183)

    '=' 	shift, and go to state 335

    $default	reduce using rule 182 (static_var_list)



state 195

    unticked_statement  ->  "static (T_STATIC)" static_var_list . ';'   (rule 62)
    static_var_list  ->  static_var_list . ',' "variable (T_VARIABLE)"   (rule 180)
    static_var_list  ->  static_var_list . ',' "variable (T_VARIABLE)" '=' static_scalar   (rule 181)

    ',' 	shift, and go to state 336
    ';' 	shift, and go to state 337



state 196

    expr_without_variable  ->  "static (T_STATIC)" function . is_reference '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 336)

    '&' 	shift, and go to state 231

    $default	reduce using rule 97 (is_reference)

    is_reference	go to state 338



state 197

    class_entry_type  ->  "abstract (T_ABSTRACT)" "class (T_CLASS)" .   (rule 106)

    $default	reduce using rule 106 (class_entry_type)



state 198

    class_entry_type  ->  "final (T_FINAL)" "class (T_CLASS)" .   (rule 108)

    $default	reduce using rule 108 (class_entry_type)



state 199

    unticked_statement  ->  "unset (T_UNSET)" '(' . unset_variables ')' ';'   (rule 66)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    unset_variables	go to state 339
    unset_variable	go to state 340
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 341
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 200

    internal_functions_in_yacc  ->  "isset (T_ISSET)" '(' . isset_variables ')'   (rule 505)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 342
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    isset_variables	go to state 343



state 201

    internal_functions_in_yacc  ->  "empty (T_EMPTY)" '(' . variable ')'   (rule 506)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 344
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 202

    top_statement  ->  "__halt_compiler (T_HALT_COMPILER)" '(' . ')' ';'   (rule 10)

    ')' 	shift, and go to state 345



state 203

    expr_without_variable  ->  "list (T_LIST)" '(' . @42 assignment_list ')' '=' expr   (rule 254)

    $default	reduce using rule 253 (@42)

    @42 	go to state 346



state 204

    expr_without_variable  ->  "array (T_ARRAY)" '(' . array_pair_list ')'   (rule 329)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 147
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 481 (array_pair_list)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 148
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    array_pair_list	go to state 347
    non_empty_array_pair_list	go to state 150
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 205

    encaps_var  ->  "variable (T_VARIABLE)" .   (rule 495)
    encaps_var  ->  "variable (T_VARIABLE)" . '[' @72 encaps_var_offset ']'   (rule 497)
    encaps_var  ->  "variable (T_VARIABLE)" . "-> (T_OBJECT_OPERATOR)" "identifier (T_STRING)"   (rule 498)

    '[' 	shift, and go to state 348
    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 349

    $default	reduce using rule 495 (encaps_var)



state 206

    common_scalar  ->  "heredoc start (T_START_HEREDOC)" "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" . "heredoc end (T_END_HEREDOC)"   (rule 394)
    encaps_list  ->  "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" . encaps_var   (rule 494)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "heredoc end (T_END_HEREDOC)"	shift, and go to state 350
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    encaps_var	go to state 351



state 207

    common_scalar  ->  "heredoc start (T_START_HEREDOC)" "heredoc end (T_END_HEREDOC)" .   (rule 395)

    $default	reduce using rule 395 (common_scalar)



state 208

    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" . expr '}'   (rule 499)
    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" . "variable name (T_STRING_VARNAME)" '[' expr ']' '}'   (rule 500)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 352
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 353
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 209

    encaps_var  ->  "{$ (T_CURLY_OPEN)" . variable '}'   (rule 501)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 354
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 210

    scalar  ->  "heredoc start (T_START_HEREDOC)" encaps_list . "heredoc end (T_END_HEREDOC)"   (rule 414)
    encaps_list  ->  encaps_list . encaps_var   (rule 491)
    encaps_list  ->  encaps_list . "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"   (rule 492)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 355
    "heredoc end (T_END_HEREDOC)"	shift, and go to state 356
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    encaps_var	go to state 357



state 211

    encaps_list  ->  encaps_var .   (rule 493)

    $default	reduce using rule 493 (encaps_list)



state 212

    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 362)
    scalar  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 410)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 358



state 213

    top_statement  ->  "namespace (T_NAMESPACE)" '{' . @3 top_statement_list '}'   (rule 15)

    $default	reduce using rule 14 (@3)

    @3  	go to state 359



state 214

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name . ';'   (rule 11)
    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name . '{' @2 top_statement_list '}'   (rule 13)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    ';' 	shift, and go to state 360
    '{' 	shift, and go to state 361



state 215

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    function_call  ->  "\\ (T_NS_SEPARATOR)" namespace_name . '(' @57 function_call_parameter_list ')'   (rule 349)
    class_name  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 363)
    scalar  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 411)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    '(' 	shift, and go to state 362

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 363 (class_name)
    $default	reduce using rule 411 (scalar)



state 216

    expr_without_variable  ->  new_expr .   (rule 309)
    expr_without_variable  ->  '(' new_expr . ')' @48 instance_call   (rule 311)

    ')' 	shift, and go to state 363

    ')' 	[reduce using rule 309 (expr_without_variable)]
    $default	reduce using rule 309 (expr_without_variable)



state 217

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  '(' expr . ')'   (rule 308)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 364



state 218

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    unticked_statement  ->  '{' inner_statement_list . '}'   (rule 35)

    '}' 	shift, and go to state 365

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 219

    compound_variable  ->  '$' '{' . expr '}'   (rule 462)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 367
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 220

    backticks_expr  ->  "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" .   (rule 380)
    encaps_list  ->  "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" . encaps_var   (rule 494)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    $default	reduce using rule 380 (backticks_expr)

    encaps_var	go to state 351



state 221

    expr_without_variable  ->  '`' backticks_expr . '`'   (rule 331)

    '`' 	shift, and go to state 368



state 222

    backticks_expr  ->  encaps_list .   (rule 381)
    encaps_list  ->  encaps_list . encaps_var   (rule 491)
    encaps_list  ->  encaps_list . "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"   (rule 492)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 355
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    $default	reduce using rule 381 (backticks_expr)

    encaps_var	go to state 357



state 223

    encaps_list  ->  "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" . encaps_var   (rule 494)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209

    encaps_var	go to state 351



state 224

    scalar  ->  '\"' encaps_list . '\"'   (rule 413)
    encaps_list  ->  encaps_list . encaps_var   (rule 491)
    encaps_list  ->  encaps_list . "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"   (rule 492)

    "variable (T_VARIABLE)"	shift, and go to state 205
    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 355
    "${ (T_DOLLAR_OPEN_CURLY_BRACES)"	shift, and go to state 208
    "{$ (T_CURLY_OPEN)"	shift, and go to state 209
    '\"'	shift, and go to state 369

    encaps_var	go to state 357



state 225

    namespace_name  ->  namespace_name "\\ (T_NS_SEPARATOR)" . "identifier (T_STRING)"   (rule 6)

    "identifier (T_STRING)"	shift, and go to state 370



state 226

    function_call  ->  namespace_name '(' . @55 function_call_parameter_list ')'   (rule 345)

    $default	reduce using rule 344 (@55)

    @55 	go to state 371



state 227

    constant_declaration  ->  constant_declaration ',' . "identifier (T_STRING)" '=' static_scalar   (rule 24)

    "identifier (T_STRING)"	shift, and go to state 372



state 228

    top_statement  ->  constant_declaration ';' .   (rule 17)

    $default	reduce using rule 17 (top_statement)



state 229

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" . extends_from @30 implements_list '{' class_statement_list '}'   (rule 102)

    "extends (T_EXTENDS)"	shift, and go to state 373

    $default	reduce using rule 109 (extends_from)

    extends_from	go to state 374



state 230

    unticked_class_declaration_statement  ->  interface_entry "identifier (T_STRING)" . @31 interface_extends_list '{' class_statement_list '}'   (rule 104)

    $default	reduce using rule 103 (@31)

    @31 	go to state 375



state 231

    is_reference  ->  '&' .   (rule 98)

    $default	reduce using rule 98 (is_reference)



state 232

    unticked_function_declaration_statement  ->  function is_reference . "identifier (T_STRING)" @29 '(' parameter_list ')' '{' inner_statement_list '}'   (rule 100)
    expr_without_variable  ->  function is_reference . '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    "identifier (T_STRING)"	shift, and go to state 376
    '(' 	shift, and go to state 377



state 233

    array_function_dereference  ->  function_call @69 . '[' dim_offset ']'   (rule 451)

    '[' 	shift, and go to state 378



state 234

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_name '(' @58 function_call_parameter_list ')'   (rule 351)
    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects '(' @59 function_call_parameter_list ')'   (rule 353)
    static_member  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects   (rule 446)
    class_constant  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . "identifier (T_STRING)"   (rule 515)

    "identifier (T_STRING)"	shift, and go to state 379
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 381
    reference_variable	go to state 382
    compound_variable	go to state 111
    variable_name	go to state 383
    simple_indirect_reference	go to state 384



state 235

    expr_without_variable  ->  expr "or (T_LOGICAL_OR)" . @46 expr   (rule 280)

    $default	reduce using rule 279 (@46)

    @46 	go to state 385



state 236

    expr_without_variable  ->  expr "xor (T_LOGICAL_XOR)" . expr   (rule 283)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 386
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 237

    expr_without_variable  ->  expr "and (T_LOGICAL_AND)" . @47 expr   (rule 282)

    $default	reduce using rule 281 (@47)

    @47 	go to state 387



state 238

    expr_without_variable  ->  expr '?' . @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr '?' . ':' @51 expr   (rule 316)

    ':' 	shift, and go to state 388

    $default	reduce using rule 312 (@49)

    @49 	go to state 389



state 239

    expr_without_variable  ->  expr "|| (T_BOOLEAN_OR)" . @44 expr   (rule 276)

    $default	reduce using rule 275 (@44)

    @44 	go to state 390



state 240

    expr_without_variable  ->  expr "&& (T_BOOLEAN_AND)" . @45 expr   (rule 278)

    $default	reduce using rule 277 (@45)

    @45 	go to state 391



state 241

    expr_without_variable  ->  expr '|' . expr   (rule 284)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 392
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 242

    expr_without_variable  ->  expr '^' . expr   (rule 286)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 393
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 243

    expr_without_variable  ->  expr '&' . expr   (rule 285)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 394
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 244

    expr_without_variable  ->  expr "== (T_IS_EQUAL)" . expr   (rule 301)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 395
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 245

    expr_without_variable  ->  expr "!= (T_IS_NOT_EQUAL)" . expr   (rule 302)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 396
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 246

    expr_without_variable  ->  expr "=== (T_IS_IDENTICAL)" . expr   (rule 299)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 397
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 247

    expr_without_variable  ->  expr "!== (T_IS_NOT_IDENTICAL)" . expr   (rule 300)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 398
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 248

    expr_without_variable  ->  expr '<' . expr   (rule 303)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 399
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 249

    expr_without_variable  ->  expr "<= (T_IS_SMALLER_OR_EQUAL)" . expr   (rule 304)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 400
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 250

    expr_without_variable  ->  expr '>' . expr   (rule 305)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 401
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 251

    expr_without_variable  ->  expr ">= (T_IS_GREATER_OR_EQUAL)" . expr   (rule 306)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 402
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 252

    expr_without_variable  ->  expr "<< (T_SL)" . expr   (rule 293)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 403
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 253

    expr_without_variable  ->  expr ">> (T_SR)" . expr   (rule 294)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 404
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 254

    expr_without_variable  ->  expr '+' . expr   (rule 288)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 405
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 255

    expr_without_variable  ->  expr '-' . expr   (rule 289)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 406
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 256

    expr_without_variable  ->  expr '.' . expr   (rule 287)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 407
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 257

    expr_without_variable  ->  expr '*' . expr   (rule 290)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 408
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 258

    expr_without_variable  ->  expr '/' . expr   (rule 291)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 409
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 259

    expr_without_variable  ->  expr '%' . expr   (rule 292)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 410
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 260

    expr_without_variable  ->  expr "instanceof (T_INSTANCEOF)" . class_name_reference   (rule 307)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 151
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 152
    '$' 	shift, and go to state 79

    namespace_name	go to state 153
    class_name	go to state 154
    class_name_reference	go to state 411
    dynamic_class_name_reference	go to state 156
    static_member	go to state 105
    variable_class_name	go to state 157
    base_variable	go to state 158
    reference_variable	go to state 159
    compound_variable	go to state 111
    simple_indirect_reference	go to state 160



state 261

    unticked_statement  ->  expr ';' .   (rule 65)

    $default	reduce using rule 65 (unticked_statement)



state 262

    expr_without_variable  ->  rw_variable "++ (T_INC)" .   (rule 271)

    $default	reduce using rule 271 (expr_without_variable)



state 263

    expr_without_variable  ->  rw_variable "-- (T_DEC)" .   (rule 273)

    $default	reduce using rule 273 (expr_without_variable)



state 264

    expr_without_variable  ->  variable '=' . expr   (rule 255)
    expr_without_variable  ->  variable '=' . '&' variable   (rule 256)
    expr_without_variable  ->  variable '=' . '&' "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 412
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 413
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 265

    expr_without_variable  ->  variable "+= (T_PLUS_EQUAL)" . expr   (rule 260)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 414
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 266

    expr_without_variable  ->  variable "-= (T_MINUS_EQUAL)" . expr   (rule 261)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 415
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 267

    expr_without_variable  ->  variable "*= (T_MUL_EQUAL)" . expr   (rule 262)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 416
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 268

    expr_without_variable  ->  variable "/= (T_DIV_EQUAL)" . expr   (rule 263)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 417
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 269

    expr_without_variable  ->  variable ".= (T_CONCAT_EQUAL)" . expr   (rule 264)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 418
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 270

    expr_without_variable  ->  variable "%= (T_MOD_EQUAL)" . expr   (rule 265)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 419
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 271

    expr_without_variable  ->  variable "&= (T_AND_EQUAL)" . expr   (rule 266)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 420
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 272

    expr_without_variable  ->  variable "|= (T_OR_EQUAL)" . expr   (rule 267)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 421
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 273

    expr_without_variable  ->  variable "^= (T_XOR_EQUAL)" . expr   (rule 268)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 422
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 274

    expr_without_variable  ->  variable "<<= (T_SL_EQUAL)" . expr   (rule 269)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 423
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 275

    expr_without_variable  ->  variable ">>= (T_SR_EQUAL)" . expr   (rule 270)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 424
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 276

    function_call  ->  variable_without_objects '(' . @62 function_call_parameter_list ')'   (rule 359)

    $default	reduce using rule 358 (@62)

    @62 	go to state 425



state 277

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_name '(' @60 function_call_parameter_list ')'   (rule 355)
    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects '(' @61 function_call_parameter_list ')'   (rule 357)
    static_member  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects   (rule 447)
    class_constant  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . "identifier (T_STRING)"   (rule 516)

    "identifier (T_STRING)"	shift, and go to state 426
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 427
    reference_variable	go to state 382
    compound_variable	go to state 111
    variable_name	go to state 428
    simple_indirect_reference	go to state 384



state 278

    array_function_dereference  ->  array_function_dereference '[' . dim_offset ']'   (rule 449)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 430
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 279

    variable  ->  base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" . @65 object_property @66 method_or_not variable_properties   (rule 431)

    $default	reduce using rule 429 (@65)

    @65 	go to state 431



state 280

    reference_variable  ->  reference_variable '[' . dim_offset ']'   (rule 458)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 432
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 281

    reference_variable  ->  reference_variable '{' . expr '}'   (rule 459)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 433
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 282

    compound_variable  ->  '$' . '{' expr '}'   (rule 462)
    simple_indirect_reference  ->  simple_indirect_reference '$' .   (rule 474)

    '{' 	shift, and go to state 219

    $default	reduce using rule 474 (simple_indirect_reference)



state 283

    variable_without_objects  ->  simple_indirect_reference reference_variable .   (rule 445)
    base_variable  ->  simple_indirect_reference reference_variable .   (rule 456)
    reference_variable  ->  reference_variable . '[' dim_offset ']'   (rule 458)
    reference_variable  ->  reference_variable . '{' expr '}'   (rule 459)

    '[' 	shift, and go to state 280
    '{' 	shift, and go to state 281

    '(' 	reduce using rule 445 (variable_without_objects)
    $default	reduce using rule 456 (base_variable)



state 284

    expr_without_variable  ->  function is_reference . '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    '(' 	shift, and go to state 377



state 285

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    internal_functions_in_yacc  ->  "eval (T_EVAL)" '(' expr . ')'   (rule 509)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 434



state 286

    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 362)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 435



state 287

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    function_call  ->  "\\ (T_NS_SEPARATOR)" namespace_name . '(' @57 function_call_parameter_list ')'   (rule 349)
    class_name  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 363)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    '(' 	shift, and go to state 362

    $default	reduce using rule 363 (class_name)



state 288

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_name '(' @58 function_call_parameter_list ')'   (rule 351)
    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects '(' @59 function_call_parameter_list ')'   (rule 353)
    static_member  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects   (rule 446)

    "identifier (T_STRING)"	shift, and go to state 436
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 381
    reference_variable	go to state 382
    compound_variable	go to state 111
    variable_name	go to state 383
    simple_indirect_reference	go to state 384



state 289

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_name '(' @60 function_call_parameter_list ')'   (rule 355)
    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects '(' @61 function_call_parameter_list ')'   (rule 357)
    static_member  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects   (rule 447)

    "identifier (T_STRING)"	shift, and go to state 436
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 427
    reference_variable	go to state 382
    compound_variable	go to state 111
    variable_name	go to state 428
    simple_indirect_reference	go to state 384



state 290

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  '@' @52 expr .   (rule 327)


    $default	reduce using rule 327 (expr_without_variable)



state 291

    non_empty_array_pair_list  ->  '&' w_variable .   (rule 490)

    $default	reduce using rule 490 (non_empty_array_pair_list)



state 292

    w_variable  ->  variable .   (rule 427)

    $default	reduce using rule 427 (w_variable)



state 293

    non_empty_array_pair_list  ->  expr "=> (T_DOUBLE_ARROW)" . expr   (rule 485)
    non_empty_array_pair_list  ->  expr "=> (T_DOUBLE_ARROW)" . '&' w_variable   (rule 489)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 437
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 438
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 294

    expr_without_variable  ->  '[' array_pair_list ']' .   (rule 330)

    $default	reduce using rule 330 (expr_without_variable)



state 295

    possible_comma  ->  ',' .   (rule 419)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' . expr "=> (T_DOUBLE_ARROW)" expr   (rule 483)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' . expr   (rule 484)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' . expr "=> (T_DOUBLE_ARROW)" '&' w_variable   (rule 487)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' . '&' w_variable   (rule 488)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 439
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 419 (possible_comma)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 440
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 296

    array_pair_list  ->  non_empty_array_pair_list possible_comma .   (rule 482)

    $default	reduce using rule 482 (array_pair_list)



state 297

    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 362)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 441



state 298

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    class_name  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 363)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 363 (class_name)



state 299

    static_member  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects   (rule 446)

    "variable (T_VARIABLE)"	shift, and go to state 33
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 442
    reference_variable	go to state 382
    compound_variable	go to state 111
    simple_indirect_reference	go to state 384



state 300

    new_expr  ->  "new (T_NEW)" class_name_reference @41 . ctor_arguments   (rule 252)

    '(' 	shift, and go to state 443

    $default	reduce using rule 382 (ctor_arguments)

    ctor_arguments	go to state 444



state 301

    static_member  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . variable_without_objects   (rule 447)

    "variable (T_VARIABLE)"	shift, and go to state 33
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 445
    reference_variable	go to state 382
    compound_variable	go to state 111
    simple_indirect_reference	go to state 384



state 302

    dynamic_class_name_reference  ->  base_variable "-> (T_OBJECT_OPERATOR)" . @63 object_property @64 dynamic_class_name_variable_properties   (rule 371)

    $default	reduce using rule 369 (@63)

    @63 	go to state 446



state 303

    base_variable  ->  simple_indirect_reference reference_variable .   (rule 456)
    reference_variable  ->  reference_variable . '[' dim_offset ']'   (rule 458)
    reference_variable  ->  reference_variable . '{' expr '}'   (rule 459)

    '[' 	shift, and go to state 280
    '{' 	shift, and go to state 281

    $default	reduce using rule 456 (base_variable)



state 304

    exit_expr  ->  '(' ')' .   (rule 377)

    $default	reduce using rule 377 (exit_expr)



state 305

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    exit_expr  ->  '(' expr . ')'   (rule 378)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 447



state 306

    unticked_statement  ->  "if (T_IF)" '(' expr . ')' @5 statement @6 elseif_list else_single   (rule 38)
    unticked_statement  ->  "if (T_IF)" '(' expr . ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 448



state 307

    echo_expr_list  ->  echo_expr_list ',' . expr   (rule 233)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 449
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 308

    unticked_statement  ->  "echo (T_ECHO)" echo_expr_list ';' .   (rule 63)

    $default	reduce using rule 63 (unticked_statement)



state 309

    unticked_statement  ->  "do (T_DO)" @11 statement . "while (T_WHILE)" '(' @12 expr ')' ';'   (rule 47)

    "while (T_WHILE)"	shift, and go to state 450



state 310

    unticked_statement  ->  "while (T_WHILE)" '(' @9 . expr ')' @10 while_statement   (rule 44)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 451
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 311

    unticked_statement  ->  "for (T_FOR)" '(' for_expr . ';' @13 for_expr ';' @14 for_expr ')' @15 for_statement   (rule 51)

    ';' 	shift, and go to state 452



state 312

    for_expr  ->  non_empty_for_expr .   (rule 236)
    non_empty_for_expr  ->  non_empty_for_expr . ',' @38 expr   (rule 238)

    ',' 	shift, and go to state 453

    $default	reduce using rule 236 (for_expr)



state 313

    non_empty_for_expr  ->  expr .   (rule 239)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 239 (non_empty_for_expr)



state 314

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable . "as (T_AS)" @19 variable foreach_optional_arg ')' @20 foreach_statement   (rule 72)
    expr  ->  expr_without_variable .   (rule 425)

    "as (T_AS)"	shift, and go to state 454

    $default	reduce using rule 425 (expr)



state 315

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable . "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' @18 foreach_statement   (rule 69)
    expr_without_variable  ->  variable . '=' expr   (rule 255)
    expr_without_variable  ->  variable . '=' '&' variable   (rule 256)
    expr_without_variable  ->  variable . '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)
    expr_without_variable  ->  variable . "+= (T_PLUS_EQUAL)" expr   (rule 260)
    expr_without_variable  ->  variable . "-= (T_MINUS_EQUAL)" expr   (rule 261)
    expr_without_variable  ->  variable . "*= (T_MUL_EQUAL)" expr   (rule 262)
    expr_without_variable  ->  variable . "/= (T_DIV_EQUAL)" expr   (rule 263)
    expr_without_variable  ->  variable . ".= (T_CONCAT_EQUAL)" expr   (rule 264)
    expr_without_variable  ->  variable . "%= (T_MOD_EQUAL)" expr   (rule 265)
    expr_without_variable  ->  variable . "&= (T_AND_EQUAL)" expr   (rule 266)
    expr_without_variable  ->  variable . "|= (T_OR_EQUAL)" expr   (rule 267)
    expr_without_variable  ->  variable . "^= (T_XOR_EQUAL)" expr   (rule 268)
    expr_without_variable  ->  variable . "<<= (T_SL_EQUAL)" expr   (rule 269)
    expr_without_variable  ->  variable . ">>= (T_SR_EQUAL)" expr   (rule 270)
    r_variable  ->  variable .   (rule 426)
    rw_variable  ->  variable .   (rule 428)

    '=' 	shift, and go to state 264
    "+= (T_PLUS_EQUAL)"	shift, and go to state 265
    "-= (T_MINUS_EQUAL)"	shift, and go to state 266
    "*= (T_MUL_EQUAL)"	shift, and go to state 267
    "/= (T_DIV_EQUAL)"	shift, and go to state 268
    ".= (T_CONCAT_EQUAL)"	shift, and go to state 269
    "%= (T_MOD_EQUAL)"	shift, and go to state 270
    "&= (T_AND_EQUAL)"	shift, and go to state 271
    "|= (T_OR_EQUAL)"	shift, and go to state 272
    "^= (T_XOR_EQUAL)"	shift, and go to state 273
    "<<= (T_SL_EQUAL)"	shift, and go to state 274
    ">>= (T_SR_EQUAL)"	shift, and go to state 275
    "as (T_AS)"	shift, and go to state 455

    "++ (T_INC)"	reduce using rule 428 (rw_variable)
    "-- (T_DEC)"	reduce using rule 428 (rw_variable)
    $default	reduce using rule 426 (r_variable)



state 316

    unticked_statement  ->  "declare (T_DECLARE)" @21 '(' . declare_list ')' declare_statement   (rule 74)

    "identifier (T_STRING)"	shift, and go to state 456

    declare_list	go to state 457



state 317

    unticked_statement  ->  "switch (T_SWITCH)" '(' expr . ')' @16 switch_case_list   (rule 53)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 458



state 318

    unticked_statement  ->  "break (T_BREAK)" expr ';' .   (rule 55)

    $default	reduce using rule 55 (unticked_statement)



state 319

    unticked_statement  ->  "continue (T_CONTINUE)" expr ';' .   (rule 57)

    $default	reduce using rule 57 (unticked_statement)



state 320

    unticked_statement  ->  "goto (T_GOTO)" "identifier (T_STRING)" ';' .   (rule 83)

    $default	reduce using rule 83 (unticked_statement)



state 321

    constant_declaration  ->  "const (T_CONST)" "identifier (T_STRING)" '=' . static_scalar   (rule 25)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 470
    static_class_constant	go to state 471



state 322

    unticked_statement  ->  "return (T_RETURN)" expr_without_variable ';' .   (rule 59)

    $default	reduce using rule 59 (unticked_statement)



state 323

    unticked_statement  ->  "return (T_RETURN)" variable ';' .   (rule 60)

    $default	reduce using rule 60 (unticked_statement)



state 324

    unticked_statement  ->  "try (T_TRY)" @22 '{' . inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 472



state 325

    unticked_statement  ->  "throw (T_THROW)" expr ';' .   (rule 82)

    $default	reduce using rule 82 (unticked_statement)



state 326

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    use_declaration  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 22)
    use_declaration  ->  "\\ (T_NS_SEPARATOR)" namespace_name . "as (T_AS)" "identifier (T_STRING)"   (rule 23)

    "as (T_AS)"	shift, and go to state 473
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 22 (use_declaration)



state 327

    use_declaration  ->  namespace_name "as (T_AS)" . "identifier (T_STRING)"   (rule 21)

    "identifier (T_STRING)"	shift, and go to state 474



state 328

    use_declarations  ->  use_declarations ',' . use_declaration   (rule 18)

    "identifier (T_STRING)"	shift, and go to state 116
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 186

    namespace_name	go to state 187
    use_declaration	go to state 475



state 329

    top_statement  ->  "use (T_USE)" use_declarations ';' .   (rule 16)

    $default	reduce using rule 16 (top_statement)



state 330

    global_var  ->  '$' '{' . expr '}'   (rule 179)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 476
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 331

    global_var  ->  '$' r_variable .   (rule 178)

    $default	reduce using rule 178 (global_var)



state 332

    r_variable  ->  variable .   (rule 426)

    $default	reduce using rule 426 (r_variable)



state 333

    global_var_list  ->  global_var_list ',' . global_var   (rule 175)

    "variable (T_VARIABLE)"	shift, and go to state 190
    '$' 	shift, and go to state 191

    global_var	go to state 477



state 334

    unticked_statement  ->  "global (T_GLOBAL)" global_var_list ';' .   (rule 61)

    $default	reduce using rule 61 (unticked_statement)



state 335

    static_var_list  ->  "variable (T_VARIABLE)" '=' . static_scalar   (rule 183)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 478
    static_class_constant	go to state 471



state 336

    static_var_list  ->  static_var_list ',' . "variable (T_VARIABLE)"   (rule 180)
    static_var_list  ->  static_var_list ',' . "variable (T_VARIABLE)" '=' static_scalar   (rule 181)

    "variable (T_VARIABLE)"	shift, and go to state 479



state 337

    unticked_statement  ->  "static (T_STATIC)" static_var_list ';' .   (rule 62)

    $default	reduce using rule 62 (unticked_statement)



state 338

    expr_without_variable  ->  "static (T_STATIC)" function is_reference . '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 336)

    '(' 	shift, and go to state 480



state 339

    unticked_statement  ->  "unset (T_UNSET)" '(' unset_variables . ')' ';'   (rule 66)
    unset_variables  ->  unset_variables . ',' unset_variable   (rule 93)

    ',' 	shift, and go to state 481
    ')' 	shift, and go to state 482



state 340

    unset_variables  ->  unset_variable .   (rule 92)

    $default	reduce using rule 92 (unset_variables)



state 341

    unset_variable  ->  variable .   (rule 94)

    $default	reduce using rule 94 (unset_variable)



state 342

    isset_variables  ->  variable .   (rule 512)

    $default	reduce using rule 512 (isset_variables)



state 343

    internal_functions_in_yacc  ->  "isset (T_ISSET)" '(' isset_variables . ')'   (rule 505)
    isset_variables  ->  isset_variables . ',' @73 variable   (rule 514)

    ',' 	shift, and go to state 483
    ')' 	shift, and go to state 484



state 344

    internal_functions_in_yacc  ->  "empty (T_EMPTY)" '(' variable . ')'   (rule 506)

    ')' 	shift, and go to state 485



state 345

    top_statement  ->  "__halt_compiler (T_HALT_COMPILER)" '(' ')' . ';'   (rule 10)

    ';' 	shift, and go to state 486



state 346

    expr_without_variable  ->  "list (T_LIST)" '(' @42 . assignment_list ')' '=' expr   (rule 254)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "list (T_LIST)"	shift, and go to state 487
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    $default	reduce using rule 480 (assignment_list_element)

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 488
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    assignment_list	go to state 489
    assignment_list_element	go to state 490



state 347

    expr_without_variable  ->  "array (T_ARRAY)" '(' array_pair_list . ')'   (rule 329)

    ')' 	shift, and go to state 491



state 348

    encaps_var  ->  "variable (T_VARIABLE)" '[' . @72 encaps_var_offset ']'   (rule 497)

    $default	reduce using rule 496 (@72)

    @72 	go to state 492



state 349

    encaps_var  ->  "variable (T_VARIABLE)" "-> (T_OBJECT_OPERATOR)" . "identifier (T_STRING)"   (rule 498)

    "identifier (T_STRING)"	shift, and go to state 493



state 350

    common_scalar  ->  "heredoc start (T_START_HEREDOC)" "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" "heredoc end (T_END_HEREDOC)" .   (rule 394)

    $default	reduce using rule 394 (common_scalar)



state 351

    encaps_list  ->  "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" encaps_var .   (rule 494)

    $default	reduce using rule 494 (encaps_list)



state 352

    scalar  ->  "variable name (T_STRING_VARNAME)" .   (rule 407)
    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" "variable name (T_STRING_VARNAME)" . '[' expr ']' '}'   (rule 500)

    '[' 	shift, and go to state 494

    $default	reduce using rule 407 (scalar)



state 353

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" expr . '}'   (rule 499)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    '}' 	shift, and go to state 495



state 354

    encaps_var  ->  "{$ (T_CURLY_OPEN)" variable . '}'   (rule 501)

    '}' 	shift, and go to state 496



state 355

    encaps_list  ->  encaps_list "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" .   (rule 492)

    $default	reduce using rule 492 (encaps_list)



state 356

    scalar  ->  "heredoc start (T_START_HEREDOC)" encaps_list "heredoc end (T_END_HEREDOC)" .   (rule 414)

    $default	reduce using rule 414 (scalar)



state 357

    encaps_list  ->  encaps_list encaps_var .   (rule 491)

    $default	reduce using rule 491 (encaps_list)



state 358

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name . '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 362)
    scalar  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 410)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    '(' 	shift, and go to state 497

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 362 (class_name)
    $default	reduce using rule 410 (scalar)



state 359

    top_statement  ->  "namespace (T_NAMESPACE)" '{' @3 . top_statement_list '}'   (rule 15)

    $default	reduce using rule 4 (top_statement_list)

    top_statement_list	go to state 498



state 360

    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name ';' .   (rule 11)

    $default	reduce using rule 11 (top_statement)



state 361

    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name '{' . @2 top_statement_list '}'   (rule 13)

    $default	reduce using rule 12 (@2)

    @2  	go to state 499



state 362

    function_call  ->  "\\ (T_NS_SEPARATOR)" namespace_name '(' . @57 function_call_parameter_list ')'   (rule 349)

    $default	reduce using rule 348 (@57)

    @57 	go to state 500



state 363

    expr_without_variable  ->  '(' new_expr ')' . @48 instance_call   (rule 311)

    $default	reduce using rule 310 (@48)

    @48 	go to state 501



state 364

    expr_without_variable  ->  '(' expr ')' .   (rule 308)

    $default	reduce using rule 308 (expr_without_variable)



state 365

    unticked_statement  ->  '{' inner_statement_list '}' .   (rule 35)

    $default	reduce using rule 35 (unticked_statement)



state 366

    inner_statement_list  ->  inner_statement_list @4 . inner_statement   (rule 27)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "abstract (T_ABSTRACT)"	shift, and go to state 54
    "final (T_FINAL)"	shift, and go to state 55
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "__halt_compiler (T_HALT_COMPILER)"	shift, and go to state 502
    "class (T_CLASS)"	shift, and go to state 60
    "trait (T_TRAIT)"	shift, and go to state 61
    "interface (T_INTERFACE)"	shift, and go to state 62
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    inner_statement	go to state 503
    statement	go to state 504
    unticked_statement	go to state 86
    function_declaration_statement	go to state 505
    class_declaration_statement	go to state 506
    unticked_function_declaration_statement	go to state 89
    unticked_class_declaration_statement	go to state 90
    class_entry_type	go to state 91
    interface_entry	go to state 92
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 95
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 367

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    compound_variable  ->  '$' '{' expr . '}'   (rule 462)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    '}' 	shift, and go to state 507



state 368

    expr_without_variable  ->  '`' backticks_expr '`' .   (rule 331)

    $default	reduce using rule 331 (expr_without_variable)



state 369

    scalar  ->  '\"' encaps_list '\"' .   (rule 413)

    $default	reduce using rule 413 (scalar)



state 370

    namespace_name  ->  namespace_name "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)" .   (rule 6)

    $default	reduce using rule 6 (namespace_name)



state 371

    function_call  ->  namespace_name '(' @55 . function_call_parameter_list ')'   (rule 345)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 509
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 372

    constant_declaration  ->  constant_declaration ',' "identifier (T_STRING)" . '=' static_scalar   (rule 24)

    '=' 	shift, and go to state 513



state 373

    extends_from  ->  "extends (T_EXTENDS)" . fully_qualified_class_name   (rule 110)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    fully_qualified_class_name	go to state 517



state 374

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" extends_from . @30 implements_list '{' class_statement_list '}'   (rule 102)

    $default	reduce using rule 101 (@30)

    @30 	go to state 518



state 375

    unticked_class_declaration_statement  ->  interface_entry "identifier (T_STRING)" @31 . interface_extends_list '{' class_statement_list '}'   (rule 104)

    "extends (T_EXTENDS)"	shift, and go to state 519

    $default	reduce using rule 112 (interface_extends_list)

    interface_extends_list	go to state 520



state 376

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" . @29 '(' parameter_list ')' '{' inner_statement_list '}'   (rule 100)

    $default	reduce using rule 99 (@29)

    @29 	go to state 521



state 377

    expr_without_variable  ->  function is_reference '(' . @53 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    $default	reduce using rule 333 (@53)

    @53 	go to state 522



state 378

    array_function_dereference  ->  function_call @69 '[' . dim_offset ']'   (rule 451)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 523
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 379

    variable_name  ->  "identifier (T_STRING)" .   (rule 471)
    class_constant  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)" .   (rule 515)

    '(' 	reduce using rule 471 (variable_name)
    $default	reduce using rule 515 (class_constant)



state 380

    variable_name  ->  '{' . expr '}'   (rule 472)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 524
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 381

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects . '(' @59 function_call_parameter_list ')'   (rule 353)
    static_member  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects .   (rule 446)

    '(' 	shift, and go to state 525

    $default	reduce using rule 446 (static_member)



state 382

    variable_without_objects  ->  reference_variable .   (rule 444)
    reference_variable  ->  reference_variable . '[' dim_offset ']'   (rule 458)
    reference_variable  ->  reference_variable . '{' expr '}'   (rule 459)

    '[' 	shift, and go to state 280
    '{' 	shift, and go to state 281

    $default	reduce using rule 444 (variable_without_objects)



state 383

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name . '(' @58 function_call_parameter_list ')'   (rule 351)

    '(' 	shift, and go to state 526



state 384

    variable_without_objects  ->  simple_indirect_reference . reference_variable   (rule 445)
    simple_indirect_reference  ->  simple_indirect_reference . '$'   (rule 474)

    "variable (T_VARIABLE)"	shift, and go to state 33
    '$' 	shift, and go to state 282

    reference_variable	go to state 527
    compound_variable	go to state 111



state 385

    expr_without_variable  ->  expr "or (T_LOGICAL_OR)" @46 . expr   (rule 280)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 528
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 386

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr "xor (T_LOGICAL_XOR)" expr .   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 283 (expr_without_variable)



state 387

    expr_without_variable  ->  expr "and (T_LOGICAL_AND)" @47 . expr   (rule 282)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 529
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 388

    expr_without_variable  ->  expr '?' ':' . @51 expr   (rule 316)

    $default	reduce using rule 315 (@51)

    @51 	go to state 530



state 389

    expr_without_variable  ->  expr '?' @49 . expr ':' @50 expr   (rule 314)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 531
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 390

    expr_without_variable  ->  expr "|| (T_BOOLEAN_OR)" @44 . expr   (rule 276)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 532
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 391

    expr_without_variable  ->  expr "&& (T_BOOLEAN_AND)" @45 . expr   (rule 278)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 533
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 392

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr '|' expr .   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 284 (expr_without_variable)



state 393

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr '^' expr .   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 286 (expr_without_variable)



state 394

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr '&' expr .   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 285 (expr_without_variable)



state 395

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr "== (T_IS_EQUAL)" expr .   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    "== (T_IS_EQUAL)"	error (nonassociative)
    "!= (T_IS_NOT_EQUAL)"	error (nonassociative)
    "=== (T_IS_IDENTICAL)"	error (nonassociative)
    "!== (T_IS_NOT_IDENTICAL)"	error (nonassociative)

    $default	reduce using rule 301 (expr_without_variable)



state 396

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr "!= (T_IS_NOT_EQUAL)" expr .   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    "== (T_IS_EQUAL)"	error (nonassociative)
    "!= (T_IS_NOT_EQUAL)"	error (nonassociative)
    "=== (T_IS_IDENTICAL)"	error (nonassociative)
    "!== (T_IS_NOT_IDENTICAL)"	error (nonassociative)

    $default	reduce using rule 302 (expr_without_variable)



state 397

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr "=== (T_IS_IDENTICAL)" expr .   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    "== (T_IS_EQUAL)"	error (nonassociative)
    "!= (T_IS_NOT_EQUAL)"	error (nonassociative)
    "=== (T_IS_IDENTICAL)"	error (nonassociative)
    "!== (T_IS_NOT_IDENTICAL)"	error (nonassociative)

    $default	reduce using rule 299 (expr_without_variable)



state 398

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr "!== (T_IS_NOT_IDENTICAL)" expr .   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    "== (T_IS_EQUAL)"	error (nonassociative)
    "!= (T_IS_NOT_EQUAL)"	error (nonassociative)
    "=== (T_IS_IDENTICAL)"	error (nonassociative)
    "!== (T_IS_NOT_IDENTICAL)"	error (nonassociative)

    $default	reduce using rule 300 (expr_without_variable)



state 399

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr '<' expr .   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    '<' 	error (nonassociative)
    "<= (T_IS_SMALLER_OR_EQUAL)"	error (nonassociative)
    '>' 	error (nonassociative)
    ">= (T_IS_GREATER_OR_EQUAL)"	error (nonassociative)

    $default	reduce using rule 303 (expr_without_variable)



state 400

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr "<= (T_IS_SMALLER_OR_EQUAL)" expr .   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    '<' 	error (nonassociative)
    "<= (T_IS_SMALLER_OR_EQUAL)"	error (nonassociative)
    '>' 	error (nonassociative)
    ">= (T_IS_GREATER_OR_EQUAL)"	error (nonassociative)

    $default	reduce using rule 304 (expr_without_variable)



state 401

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr '>' expr .   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    '<' 	error (nonassociative)
    "<= (T_IS_SMALLER_OR_EQUAL)"	error (nonassociative)
    '>' 	error (nonassociative)
    ">= (T_IS_GREATER_OR_EQUAL)"	error (nonassociative)

    $default	reduce using rule 305 (expr_without_variable)



state 402

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr ">= (T_IS_GREATER_OR_EQUAL)" expr .   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    '<' 	error (nonassociative)
    "<= (T_IS_SMALLER_OR_EQUAL)"	error (nonassociative)
    '>' 	error (nonassociative)
    ">= (T_IS_GREATER_OR_EQUAL)"	error (nonassociative)

    $default	reduce using rule 306 (expr_without_variable)



state 403

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr "<< (T_SL)" expr .   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 293 (expr_without_variable)



state 404

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr ">> (T_SR)" expr .   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 294 (expr_without_variable)



state 405

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr '+' expr .   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 288 (expr_without_variable)



state 406

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr '-' expr .   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 289 (expr_without_variable)



state 407

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr '.' expr .   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 287 (expr_without_variable)



state 408

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr '*' expr .   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 290 (expr_without_variable)



state 409

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr '/' expr .   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 291 (expr_without_variable)



state 410

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr '%' expr .   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 292 (expr_without_variable)



state 411

    expr_without_variable  ->  expr "instanceof (T_INSTANCEOF)" class_name_reference .   (rule 307)

    $default	reduce using rule 307 (expr_without_variable)



state 412

    expr_without_variable  ->  variable '=' '&' . variable   (rule 256)
    expr_without_variable  ->  variable '=' '&' . "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)

    "new (T_NEW)"	shift, and go to state 534
    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 535
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 413

    expr_without_variable  ->  variable '=' expr .   (rule 255)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 255 (expr_without_variable)



state 414

    expr_without_variable  ->  variable "+= (T_PLUS_EQUAL)" expr .   (rule 260)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 260 (expr_without_variable)



state 415

    expr_without_variable  ->  variable "-= (T_MINUS_EQUAL)" expr .   (rule 261)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 261 (expr_without_variable)



state 416

    expr_without_variable  ->  variable "*= (T_MUL_EQUAL)" expr .   (rule 262)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 262 (expr_without_variable)



state 417

    expr_without_variable  ->  variable "/= (T_DIV_EQUAL)" expr .   (rule 263)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 263 (expr_without_variable)



state 418

    expr_without_variable  ->  variable ".= (T_CONCAT_EQUAL)" expr .   (rule 264)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 264 (expr_without_variable)



state 419

    expr_without_variable  ->  variable "%= (T_MOD_EQUAL)" expr .   (rule 265)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 265 (expr_without_variable)



state 420

    expr_without_variable  ->  variable "&= (T_AND_EQUAL)" expr .   (rule 266)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 266 (expr_without_variable)



state 421

    expr_without_variable  ->  variable "|= (T_OR_EQUAL)" expr .   (rule 267)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 267 (expr_without_variable)



state 422

    expr_without_variable  ->  variable "^= (T_XOR_EQUAL)" expr .   (rule 268)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 268 (expr_without_variable)



state 423

    expr_without_variable  ->  variable "<<= (T_SL_EQUAL)" expr .   (rule 269)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 269 (expr_without_variable)



state 424

    expr_without_variable  ->  variable ">>= (T_SR_EQUAL)" expr .   (rule 270)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 270 (expr_without_variable)



state 425

    function_call  ->  variable_without_objects '(' @62 . function_call_parameter_list ')'   (rule 359)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 536
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 426

    variable_name  ->  "identifier (T_STRING)" .   (rule 471)
    class_constant  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)" .   (rule 516)

    '(' 	reduce using rule 471 (variable_name)
    $default	reduce using rule 516 (class_constant)



state 427

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects . '(' @61 function_call_parameter_list ')'   (rule 357)
    static_member  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects .   (rule 447)

    '(' 	shift, and go to state 537

    $default	reduce using rule 447 (static_member)



state 428

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name . '(' @60 function_call_parameter_list ')'   (rule 355)

    '(' 	shift, and go to state 538



state 429

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    dim_offset  ->  expr .   (rule 464)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 464 (dim_offset)



state 430

    array_function_dereference  ->  array_function_dereference '[' dim_offset . ']'   (rule 449)

    ']' 	shift, and go to state 539



state 431

    variable  ->  base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" @65 . object_property @66 method_or_not variable_properties   (rule 431)

    "identifier (T_STRING)"	shift, and go to state 436
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 540
    reference_variable	go to state 382
    compound_variable	go to state 111
    object_property	go to state 541
    object_dim_list	go to state 542
    variable_name	go to state 543
    simple_indirect_reference	go to state 384



state 432

    reference_variable  ->  reference_variable '[' dim_offset . ']'   (rule 458)

    ']' 	shift, and go to state 544



state 433

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    reference_variable  ->  reference_variable '{' expr . '}'   (rule 459)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    '}' 	shift, and go to state 545



state 434

    internal_functions_in_yacc  ->  "eval (T_EVAL)" '(' expr ')' .   (rule 509)

    $default	reduce using rule 509 (internal_functions_in_yacc)



state 435

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name . '(' @56 function_call_parameter_list ')'   (rule 347)
    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 362)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225
    '(' 	shift, and go to state 497

    $default	reduce using rule 362 (class_name)



state 436

    variable_name  ->  "identifier (T_STRING)" .   (rule 471)

    $default	reduce using rule 471 (variable_name)



state 437

    non_empty_array_pair_list  ->  expr "=> (T_DOUBLE_ARROW)" '&' . w_variable   (rule 489)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    w_variable	go to state 546
    variable	go to state 292
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 438

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    non_empty_array_pair_list  ->  expr "=> (T_DOUBLE_ARROW)" expr .   (rule 485)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 485 (non_empty_array_pair_list)



state 439

    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' '&' . w_variable   (rule 488)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    w_variable	go to state 547
    variable	go to state 292
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 440

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr . "=> (T_DOUBLE_ARROW)" expr   (rule 483)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr .   (rule 484)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr . "=> (T_DOUBLE_ARROW)" '&' w_variable   (rule 487)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    "=> (T_DOUBLE_ARROW)"	shift, and go to state 548

    $default	reduce using rule 484 (non_empty_array_pair_list)



state 441

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 362)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 362 (class_name)



state 442

    static_member  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects .   (rule 446)

    $default	reduce using rule 446 (static_member)



state 443

    ctor_arguments  ->  '(' . function_call_parameter_list ')'   (rule 383)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 549
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 444

    new_expr  ->  "new (T_NEW)" class_name_reference @41 ctor_arguments .   (rule 252)

    $default	reduce using rule 252 (new_expr)



state 445

    static_member  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects .   (rule 447)

    $default	reduce using rule 447 (static_member)



state 446

    dynamic_class_name_reference  ->  base_variable "-> (T_OBJECT_OPERATOR)" @63 . object_property @64 dynamic_class_name_variable_properties   (rule 371)

    "identifier (T_STRING)"	shift, and go to state 436
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 540
    reference_variable	go to state 382
    compound_variable	go to state 111
    object_property	go to state 550
    object_dim_list	go to state 542
    variable_name	go to state 543
    simple_indirect_reference	go to state 384



state 447

    exit_expr  ->  '(' expr ')' .   (rule 378)

    $default	reduce using rule 378 (exit_expr)



state 448

    unticked_statement  ->  "if (T_IF)" '(' expr ')' . @5 statement @6 elseif_list else_single   (rule 38)
    unticked_statement  ->  "if (T_IF)" '(' expr ')' . ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    ':' 	shift, and go to state 551

    $default	reduce using rule 36 (@5)

    @5  	go to state 552



state 449

    echo_expr_list  ->  echo_expr_list ',' expr .   (rule 233)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 233 (echo_expr_list)



state 450

    unticked_statement  ->  "do (T_DO)" @11 statement "while (T_WHILE)" . '(' @12 expr ')' ';'   (rule 47)

    '(' 	shift, and go to state 553



state 451

    unticked_statement  ->  "while (T_WHILE)" '(' @9 expr . ')' @10 while_statement   (rule 44)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 554



state 452

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' . @13 for_expr ';' @14 for_expr ')' @15 for_statement   (rule 51)

    $default	reduce using rule 48 (@13)

    @13 	go to state 555



state 453

    non_empty_for_expr  ->  non_empty_for_expr ',' . @38 expr   (rule 238)

    $default	reduce using rule 237 (@38)

    @38 	go to state 556



state 454

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" . @19 variable foreach_optional_arg ')' @20 foreach_statement   (rule 72)

    $default	reduce using rule 70 (@19)

    @19 	go to state 557



state 455

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" . @17 foreach_variable foreach_optional_arg ')' @18 foreach_statement   (rule 69)

    $default	reduce using rule 67 (@17)

    @17 	go to state 558



state 456

    declare_list  ->  "identifier (T_STRING)" . '=' static_scalar   (rule 128)

    '=' 	shift, and go to state 559



state 457

    unticked_statement  ->  "declare (T_DECLARE)" @21 '(' declare_list . ')' declare_statement   (rule 74)
    declare_list  ->  declare_list . ',' "identifier (T_STRING)" '=' static_scalar   (rule 129)

    ',' 	shift, and go to state 560
    ')' 	shift, and go to state 561



state 458

    unticked_statement  ->  "switch (T_SWITCH)" '(' expr ')' . @16 switch_case_list   (rule 53)

    $default	reduce using rule 52 (@16)

    @16 	go to state 562



state 459

    static_scalar  ->  '+' . static_scalar   (rule 400)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 563
    static_class_constant	go to state 471



state 460

    static_scalar  ->  '-' . static_scalar   (rule 401)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 564
    static_class_constant	go to state 471



state 461

    static_scalar  ->  '[' . static_array_pair_list ']'   (rule 403)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    $default	reduce using rule 416 (static_array_pair_list)

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 565
    static_class_constant	go to state 471
    static_array_pair_list	go to state 566
    non_empty_static_array_pair_list	go to state 567



state 462

    static_scalar  ->  "array (T_ARRAY)" . '(' static_array_pair_list ')'   (rule 402)

    '(' 	shift, and go to state 568



state 463

    static_scalar  ->  "__CLASS__ (T_CLASS_C)" .   (rule 405)

    $default	reduce using rule 405 (static_scalar)



state 464

    common_scalar  ->  "heredoc start (T_START_HEREDOC)" . "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" "heredoc end (T_END_HEREDOC)"   (rule 394)
    common_scalar  ->  "heredoc start (T_START_HEREDOC)" . "heredoc end (T_END_HEREDOC)"   (rule 395)

    "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)"	shift, and go to state 569
    "heredoc end (T_END_HEREDOC)"	shift, and go to state 207



state 465

    class_name  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 362)
    static_scalar  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 398)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 570



state 466

    class_name  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 363)
    static_scalar  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 399)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 571



state 467

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    class_name  ->  namespace_name .   (rule 361)
    static_scalar  ->  namespace_name .   (rule 397)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 361 (class_name)
    $default	reduce using rule 397 (static_scalar)



state 468

    static_class_constant  ->  class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"   (rule 406)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 572



state 469

    static_scalar  ->  common_scalar .   (rule 396)

    $default	reduce using rule 396 (static_scalar)



state 470

    constant_declaration  ->  "const (T_CONST)" "identifier (T_STRING)" '=' static_scalar .   (rule 25)

    $default	reduce using rule 25 (constant_declaration)



state 471

    static_scalar  ->  static_class_constant .   (rule 404)

    $default	reduce using rule 404 (static_scalar)



state 472

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list . '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    '}' 	shift, and go to state 573

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 473

    use_declaration  ->  "\\ (T_NS_SEPARATOR)" namespace_name "as (T_AS)" . "identifier (T_STRING)"   (rule 23)

    "identifier (T_STRING)"	shift, and go to state 574



state 474

    use_declaration  ->  namespace_name "as (T_AS)" "identifier (T_STRING)" .   (rule 21)

    $default	reduce using rule 21 (use_declaration)



state 475

    use_declarations  ->  use_declarations ',' use_declaration .   (rule 18)

    $default	reduce using rule 18 (use_declarations)



state 476

    global_var  ->  '$' '{' expr . '}'   (rule 179)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    '}' 	shift, and go to state 575



state 477

    global_var_list  ->  global_var_list ',' global_var .   (rule 175)

    $default	reduce using rule 175 (global_var_list)



state 478

    static_var_list  ->  "variable (T_VARIABLE)" '=' static_scalar .   (rule 183)

    $default	reduce using rule 183 (static_var_list)



state 479

    static_var_list  ->  static_var_list ',' "variable (T_VARIABLE)" .   (rule 180)
    static_var_list  ->  static_var_list ',' "variable (T_VARIABLE)" . '=' static_scalar   (rule 181)

    '=' 	shift, and go to state 576

    $default	reduce using rule 180 (static_var_list)



state 480

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' . @54 parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 336)

    $default	reduce using rule 335 (@54)

    @54 	go to state 577



state 481

    unset_variables  ->  unset_variables ',' . unset_variable   (rule 93)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    unset_variable	go to state 578
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 341
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 482

    unticked_statement  ->  "unset (T_UNSET)" '(' unset_variables ')' . ';'   (rule 66)

    ';' 	shift, and go to state 579



state 483

    isset_variables  ->  isset_variables ',' . @73 variable   (rule 514)

    $default	reduce using rule 513 (@73)

    @73 	go to state 580



state 484

    internal_functions_in_yacc  ->  "isset (T_ISSET)" '(' isset_variables ')' .   (rule 505)

    $default	reduce using rule 505 (internal_functions_in_yacc)



state 485

    internal_functions_in_yacc  ->  "empty (T_EMPTY)" '(' variable ')' .   (rule 506)

    $default	reduce using rule 506 (internal_functions_in_yacc)



state 486

    top_statement  ->  "__halt_compiler (T_HALT_COMPILER)" '(' ')' ';' .   (rule 10)

    $default	reduce using rule 10 (top_statement)



state 487

    assignment_list_element  ->  "list (T_LIST)" . '(' @71 assignment_list ')'   (rule 479)

    '(' 	shift, and go to state 581



state 488

    assignment_list_element  ->  variable .   (rule 477)

    $default	reduce using rule 477 (assignment_list_element)



state 489

    expr_without_variable  ->  "list (T_LIST)" '(' @42 assignment_list . ')' '=' expr   (rule 254)
    assignment_list  ->  assignment_list . ',' assignment_list_element   (rule 475)

    ',' 	shift, and go to state 582
    ')' 	shift, and go to state 583



state 490

    assignment_list  ->  assignment_list_element .   (rule 476)

    $default	reduce using rule 476 (assignment_list)



state 491

    expr_without_variable  ->  "array (T_ARRAY)" '(' array_pair_list ')' .   (rule 329)

    $default	reduce using rule 329 (expr_without_variable)



state 492

    encaps_var  ->  "variable (T_VARIABLE)" '[' @72 . encaps_var_offset ']'   (rule 497)

    "identifier (T_STRING)"	shift, and go to state 584
    "variable (T_VARIABLE)"	shift, and go to state 585
    "number (T_NUM_STRING)"	shift, and go to state 586

    encaps_var_offset	go to state 587



state 493

    encaps_var  ->  "variable (T_VARIABLE)" "-> (T_OBJECT_OPERATOR)" "identifier (T_STRING)" .   (rule 498)

    $default	reduce using rule 498 (encaps_var)



state 494

    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" "variable name (T_STRING_VARNAME)" '[' . expr ']' '}'   (rule 500)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 588
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 495

    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" expr '}' .   (rule 499)

    $default	reduce using rule 499 (encaps_var)



state 496

    encaps_var  ->  "{$ (T_CURLY_OPEN)" variable '}' .   (rule 501)

    $default	reduce using rule 501 (encaps_var)



state 497

    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name '(' . @56 function_call_parameter_list ')'   (rule 347)

    $default	reduce using rule 346 (@56)

    @56 	go to state 589



state 498

    top_statement_list  ->  top_statement_list . @1 top_statement   (rule 3)
    top_statement  ->  "namespace (T_NAMESPACE)" '{' @3 top_statement_list . '}'   (rule 15)

    '}' 	shift, and go to state 590

    $default	reduce using rule 2 (@1)

    @1  	go to state 2



state 499

    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name '{' @2 . top_statement_list '}'   (rule 13)

    $default	reduce using rule 4 (top_statement_list)

    top_statement_list	go to state 591



state 500

    function_call  ->  "\\ (T_NS_SEPARATOR)" namespace_name '(' @57 . function_call_parameter_list ')'   (rule 349)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 592
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 501

    expr_without_variable  ->  '(' new_expr ')' @48 . instance_call   (rule 311)

    '[' 	reduce using rule 249 (@40)
    "-> (T_OBJECT_OPERATOR)"	reduce using rule 249 (@40)
    $default	reduce using rule 248 (instance_call)

    instance_call	go to state 593
    @40 	go to state 594



state 502

    inner_statement  ->  "__halt_compiler (T_HALT_COMPILER)" . '(' ')' ';'   (rule 32)

    '(' 	shift, and go to state 595



state 503

    inner_statement_list  ->  inner_statement_list @4 inner_statement .   (rule 27)

    $default	reduce using rule 27 (inner_statement_list)



state 504

    inner_statement  ->  statement .   (rule 29)

    $default	reduce using rule 29 (inner_statement)



state 505

    inner_statement  ->  function_declaration_statement .   (rule 30)

    $default	reduce using rule 30 (inner_statement)



state 506

    inner_statement  ->  class_declaration_statement .   (rule 31)

    $default	reduce using rule 31 (inner_statement)



state 507

    compound_variable  ->  '$' '{' expr '}' .   (rule 462)

    $default	reduce using rule 462 (compound_variable)



state 508

    non_empty_function_call_parameter_list  ->  '&' . w_variable   (rule 171)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    w_variable	go to state 596
    variable	go to state 292
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 509

    function_call  ->  namespace_name '(' @55 function_call_parameter_list . ')'   (rule 345)

    ')' 	shift, and go to state 597



state 510

    function_call_parameter_list  ->  non_empty_function_call_parameter_list .   (rule 167)
    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list . ',' expr_without_variable   (rule 172)
    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list . ',' variable   (rule 173)
    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list . ',' '&' w_variable   (rule 174)

    ',' 	shift, and go to state 598

    $default	reduce using rule 167 (function_call_parameter_list)



state 511

    non_empty_function_call_parameter_list  ->  expr_without_variable .   (rule 169)
    expr  ->  expr_without_variable .   (rule 425)

    ',' 	reduce using rule 169 (non_empty_function_call_parameter_list)
    ')' 	reduce using rule 169 (non_empty_function_call_parameter_list)
    $default	reduce using rule 425 (expr)



state 512

    non_empty_function_call_parameter_list  ->  variable .   (rule 170)
    expr_without_variable  ->  variable . '=' expr   (rule 255)
    expr_without_variable  ->  variable . '=' '&' variable   (rule 256)
    expr_without_variable  ->  variable . '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)
    expr_without_variable  ->  variable . "+= (T_PLUS_EQUAL)" expr   (rule 260)
    expr_without_variable  ->  variable . "-= (T_MINUS_EQUAL)" expr   (rule 261)
    expr_without_variable  ->  variable . "*= (T_MUL_EQUAL)" expr   (rule 262)
    expr_without_variable  ->  variable . "/= (T_DIV_EQUAL)" expr   (rule 263)
    expr_without_variable  ->  variable . ".= (T_CONCAT_EQUAL)" expr   (rule 264)
    expr_without_variable  ->  variable . "%= (T_MOD_EQUAL)" expr   (rule 265)
    expr_without_variable  ->  variable . "&= (T_AND_EQUAL)" expr   (rule 266)
    expr_without_variable  ->  variable . "|= (T_OR_EQUAL)" expr   (rule 267)
    expr_without_variable  ->  variable . "^= (T_XOR_EQUAL)" expr   (rule 268)
    expr_without_variable  ->  variable . "<<= (T_SL_EQUAL)" expr   (rule 269)
    expr_without_variable  ->  variable . ">>= (T_SR_EQUAL)" expr   (rule 270)
    r_variable  ->  variable .   (rule 426)
    rw_variable  ->  variable .   (rule 428)

    '=' 	shift, and go to state 264
    "+= (T_PLUS_EQUAL)"	shift, and go to state 265
    "-= (T_MINUS_EQUAL)"	shift, and go to state 266
    "*= (T_MUL_EQUAL)"	shift, and go to state 267
    "/= (T_DIV_EQUAL)"	shift, and go to state 268
    ".= (T_CONCAT_EQUAL)"	shift, and go to state 269
    "%= (T_MOD_EQUAL)"	shift, and go to state 270
    "&= (T_AND_EQUAL)"	shift, and go to state 271
    "|= (T_OR_EQUAL)"	shift, and go to state 272
    "^= (T_XOR_EQUAL)"	shift, and go to state 273
    "<<= (T_SL_EQUAL)"	shift, and go to state 274
    ">>= (T_SR_EQUAL)"	shift, and go to state 275

    ',' 	reduce using rule 170 (non_empty_function_call_parameter_list)
    "++ (T_INC)"	reduce using rule 428 (rw_variable)
    "-- (T_DEC)"	reduce using rule 428 (rw_variable)
    ')' 	reduce using rule 170 (non_empty_function_call_parameter_list)
    $default	reduce using rule 426 (r_variable)



state 513

    constant_declaration  ->  constant_declaration ',' "identifier (T_STRING)" '=' . static_scalar   (rule 24)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 599
    static_class_constant	go to state 471



state 514

    fully_qualified_class_name  ->  "namespace (T_NAMESPACE)" . "\\ (T_NS_SEPARATOR)" namespace_name   (rule 365)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 600



state 515

    fully_qualified_class_name  ->  "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 366)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 601



state 516

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    fully_qualified_class_name  ->  namespace_name .   (rule 364)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 364 (fully_qualified_class_name)



state 517

    extends_from  ->  "extends (T_EXTENDS)" fully_qualified_class_name .   (rule 110)

    $default	reduce using rule 110 (extends_from)



state 518

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" extends_from @30 . implements_list '{' class_statement_list '}'   (rule 102)

    "implements (T_IMPLEMENTS)"	shift, and go to state 602

    $default	reduce using rule 114 (implements_list)

    implements_list	go to state 603



state 519

    interface_extends_list  ->  "extends (T_EXTENDS)" . interface_list   (rule 113)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    interface_list	go to state 604
    fully_qualified_class_name	go to state 605



state 520

    unticked_class_declaration_statement  ->  interface_entry "identifier (T_STRING)" @31 interface_extends_list . '{' class_statement_list '}'   (rule 104)

    '{' 	shift, and go to state 606



state 521

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 . '(' parameter_list ')' '{' inner_statement_list '}'   (rule 100)

    '(' 	shift, and go to state 607



state 522

    expr_without_variable  ->  function is_reference '(' @53 . parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    "identifier (T_STRING)"	shift, and go to state 116
    "array (T_ARRAY)"	shift, and go to state 608
    "callable (T_CALLABLE)"	shift, and go to state 609
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    ')' 	reduce using rule 154 (parameter_list)
    $default	reduce using rule 163 (optional_class_type)

    namespace_name	go to state 516
    parameter_list	go to state 610
    non_empty_parameter_list	go to state 611
    optional_class_type	go to state 612
    fully_qualified_class_name	go to state 613



state 523

    array_function_dereference  ->  function_call @69 '[' dim_offset . ']'   (rule 451)

    ']' 	shift, and go to state 614



state 524

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    variable_name  ->  '{' expr . '}'   (rule 472)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    '}' 	shift, and go to state 615



state 525

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' . @59 function_call_parameter_list ')'   (rule 353)

    $default	reduce using rule 352 (@59)

    @59 	go to state 616



state 526

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' . @58 function_call_parameter_list ')'   (rule 351)

    $default	reduce using rule 350 (@58)

    @58 	go to state 617



state 527

    variable_without_objects  ->  simple_indirect_reference reference_variable .   (rule 445)
    reference_variable  ->  reference_variable . '[' dim_offset ']'   (rule 458)
    reference_variable  ->  reference_variable . '{' expr '}'   (rule 459)

    '[' 	shift, and go to state 280
    '{' 	shift, and go to state 281

    $default	reduce using rule 445 (variable_without_objects)



state 528

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr "or (T_LOGICAL_OR)" @46 expr .   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 280 (expr_without_variable)



state 529

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr "and (T_LOGICAL_AND)" @47 expr .   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 282 (expr_without_variable)



state 530

    expr_without_variable  ->  expr '?' ':' @51 . expr   (rule 316)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 618
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 531

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr '?' @49 expr . ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    ':' 	shift, and go to state 619
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260



state 532

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr "|| (T_BOOLEAN_OR)" @44 expr .   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 276 (expr_without_variable)



state 533

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr "&& (T_BOOLEAN_AND)" @45 expr .   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 278 (expr_without_variable)



state 534

    expr_without_variable  ->  variable '=' '&' "new (T_NEW)" . class_name_reference @43 ctor_arguments   (rule 258)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 151
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 152
    '$' 	shift, and go to state 79

    namespace_name	go to state 153
    class_name	go to state 154
    class_name_reference	go to state 620
    dynamic_class_name_reference	go to state 156
    static_member	go to state 105
    variable_class_name	go to state 157
    base_variable	go to state 158
    reference_variable	go to state 159
    compound_variable	go to state 111
    simple_indirect_reference	go to state 160



state 535

    expr_without_variable  ->  variable '=' '&' variable .   (rule 256)

    $default	reduce using rule 256 (expr_without_variable)



state 536

    function_call  ->  variable_without_objects '(' @62 function_call_parameter_list . ')'   (rule 359)

    ')' 	shift, and go to state 621



state 537

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' . @61 function_call_parameter_list ')'   (rule 357)

    $default	reduce using rule 356 (@61)

    @61 	go to state 622



state 538

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' . @60 function_call_parameter_list ')'   (rule 355)

    $default	reduce using rule 354 (@60)

    @60 	go to state 623



state 539

    array_function_dereference  ->  array_function_dereference '[' dim_offset ']' .   (rule 449)

    $default	reduce using rule 449 (array_function_dereference)



state 540

    object_property  ->  variable_without_objects . @70   (rule 467)

    $default	reduce using rule 466 (@70)

    @70 	go to state 624



state 541

    variable  ->  base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" @65 object_property . @66 method_or_not variable_properties   (rule 431)

    $default	reduce using rule 430 (@66)

    @66 	go to state 625



state 542

    object_property  ->  object_dim_list .   (rule 465)
    object_dim_list  ->  object_dim_list . '[' dim_offset ']'   (rule 468)
    object_dim_list  ->  object_dim_list . '{' expr '}'   (rule 469)

    '[' 	shift, and go to state 626
    '{' 	shift, and go to state 627

    $default	reduce using rule 465 (object_property)



state 543

    object_dim_list  ->  variable_name .   (rule 470)

    $default	reduce using rule 470 (object_dim_list)



state 544

    reference_variable  ->  reference_variable '[' dim_offset ']' .   (rule 458)

    $default	reduce using rule 458 (reference_variable)



state 545

    reference_variable  ->  reference_variable '{' expr '}' .   (rule 459)

    $default	reduce using rule 459 (reference_variable)



state 546

    non_empty_array_pair_list  ->  expr "=> (T_DOUBLE_ARROW)" '&' w_variable .   (rule 489)

    $default	reduce using rule 489 (non_empty_array_pair_list)



state 547

    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' '&' w_variable .   (rule 488)

    $default	reduce using rule 488 (non_empty_array_pair_list)



state 548

    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" . expr   (rule 483)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" . '&' w_variable   (rule 487)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 628
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 629
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 549

    ctor_arguments  ->  '(' function_call_parameter_list . ')'   (rule 383)

    ')' 	shift, and go to state 630



state 550

    dynamic_class_name_reference  ->  base_variable "-> (T_OBJECT_OPERATOR)" @63 object_property . @64 dynamic_class_name_variable_properties   (rule 371)

    $default	reduce using rule 370 (@64)

    @64 	go to state 631



state 551

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' . @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    $default	reduce using rule 39 (@7)

    @7  	go to state 632



state 552

    unticked_statement  ->  "if (T_IF)" '(' expr ')' @5 . statement @6 elseif_list else_single   (rule 38)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 633
    unticked_statement	go to state 86
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 553

    unticked_statement  ->  "do (T_DO)" @11 statement "while (T_WHILE)" '(' . @12 expr ')' ';'   (rule 47)

    $default	reduce using rule 46 (@12)

    @12 	go to state 634



state 554

    unticked_statement  ->  "while (T_WHILE)" '(' @9 expr ')' . @10 while_statement   (rule 44)

    $default	reduce using rule 43 (@10)

    @10 	go to state 635



state 555

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 . for_expr ';' @14 for_expr ')' @15 for_statement   (rule 51)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 235 (for_expr)

    namespace_name	go to state 82
    for_expr	go to state 636
    non_empty_for_expr	go to state 312
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 313
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 556

    non_empty_for_expr  ->  non_empty_for_expr ',' @38 . expr   (rule 238)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 637
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 557

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 . variable foreach_optional_arg ')' @20 foreach_statement   (rule 72)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 638
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 558

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 . foreach_variable foreach_optional_arg ')' @18 foreach_statement   (rule 69)

    '&' 	shift, and go to state 639
    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    foreach_variable	go to state 640
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 641
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 559

    declare_list  ->  "identifier (T_STRING)" '=' . static_scalar   (rule 128)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 642
    static_class_constant	go to state 471



state 560

    declare_list  ->  declare_list ',' . "identifier (T_STRING)" '=' static_scalar   (rule 129)

    "identifier (T_STRING)"	shift, and go to state 643



state 561

    unticked_statement  ->  "declare (T_DECLARE)" @21 '(' declare_list ')' . declare_statement   (rule 74)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    ':' 	shift, and go to state 644
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 645
    unticked_statement	go to state 86
    declare_statement	go to state 646
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 562

    unticked_statement  ->  "switch (T_SWITCH)" '(' expr ')' @16 . switch_case_list   (rule 53)

    ':' 	shift, and go to state 647
    '{' 	shift, and go to state 648

    switch_case_list	go to state 649



state 563

    static_scalar  ->  '+' static_scalar .   (rule 400)

    $default	reduce using rule 400 (static_scalar)



state 564

    static_scalar  ->  '-' static_scalar .   (rule 401)

    $default	reduce using rule 401 (static_scalar)



state 565

    non_empty_static_array_pair_list  ->  static_scalar . "=> (T_DOUBLE_ARROW)" static_scalar   (rule 422)
    non_empty_static_array_pair_list  ->  static_scalar .   (rule 423)

    "=> (T_DOUBLE_ARROW)"	shift, and go to state 650

    $default	reduce using rule 423 (non_empty_static_array_pair_list)



state 566

    static_scalar  ->  '[' static_array_pair_list . ']'   (rule 403)

    ']' 	shift, and go to state 651



state 567

    static_array_pair_list  ->  non_empty_static_array_pair_list . possible_comma   (rule 417)
    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list . ',' static_scalar "=> (T_DOUBLE_ARROW)" static_scalar   (rule 420)
    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list . ',' static_scalar   (rule 421)

    ',' 	shift, and go to state 652

    $default	reduce using rule 418 (possible_comma)

    possible_comma	go to state 653



state 568

    static_scalar  ->  "array (T_ARRAY)" '(' . static_array_pair_list ')'   (rule 402)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    $default	reduce using rule 416 (static_array_pair_list)

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 565
    static_class_constant	go to state 471
    static_array_pair_list	go to state 654
    non_empty_static_array_pair_list	go to state 567



state 569

    common_scalar  ->  "heredoc start (T_START_HEREDOC)" "quoted-string and whitespace (T_ENCAPSED_AND_WHITESPACE)" . "heredoc end (T_END_HEREDOC)"   (rule 394)

    "heredoc end (T_END_HEREDOC)"	shift, and go to state 350



state 570

    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 362)
    static_scalar  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 398)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 655



state 571

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    class_name  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 363)
    static_scalar  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 399)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 363 (class_name)
    $default	reduce using rule 399 (static_scalar)



state 572

    static_class_constant  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . "identifier (T_STRING)"   (rule 406)

    "identifier (T_STRING)"	shift, and go to state 656



state 573

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' . "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    "catch (T_CATCH)"	shift, and go to state 657



state 574

    use_declaration  ->  "\\ (T_NS_SEPARATOR)" namespace_name "as (T_AS)" "identifier (T_STRING)" .   (rule 23)

    $default	reduce using rule 23 (use_declaration)



state 575

    global_var  ->  '$' '{' expr '}' .   (rule 179)

    $default	reduce using rule 179 (global_var)



state 576

    static_var_list  ->  static_var_list ',' "variable (T_VARIABLE)" '=' . static_scalar   (rule 181)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 658
    static_class_constant	go to state 471



state 577

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 . parameter_list ')' lexical_vars '{' inner_statement_list '}'   (rule 336)

    "identifier (T_STRING)"	shift, and go to state 116
    "array (T_ARRAY)"	shift, and go to state 608
    "callable (T_CALLABLE)"	shift, and go to state 609
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    ')' 	reduce using rule 154 (parameter_list)
    $default	reduce using rule 163 (optional_class_type)

    namespace_name	go to state 516
    parameter_list	go to state 659
    non_empty_parameter_list	go to state 611
    optional_class_type	go to state 612
    fully_qualified_class_name	go to state 613



state 578

    unset_variables  ->  unset_variables ',' unset_variable .   (rule 93)

    $default	reduce using rule 93 (unset_variables)



state 579

    unticked_statement  ->  "unset (T_UNSET)" '(' unset_variables ')' ';' .   (rule 66)

    $default	reduce using rule 66 (unticked_statement)



state 580

    isset_variables  ->  isset_variables ',' @73 . variable   (rule 514)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 660
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 581

    assignment_list_element  ->  "list (T_LIST)" '(' . @71 assignment_list ')'   (rule 479)

    $default	reduce using rule 478 (@71)

    @71 	go to state 661



state 582

    assignment_list  ->  assignment_list ',' . assignment_list_element   (rule 475)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "list (T_LIST)"	shift, and go to state 487
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    $default	reduce using rule 480 (assignment_list_element)

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 488
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    assignment_list_element	go to state 662



state 583

    expr_without_variable  ->  "list (T_LIST)" '(' @42 assignment_list ')' . '=' expr   (rule 254)

    '=' 	shift, and go to state 663



state 584

    encaps_var_offset  ->  "identifier (T_STRING)" .   (rule 502)

    $default	reduce using rule 502 (encaps_var_offset)



state 585

    encaps_var_offset  ->  "variable (T_VARIABLE)" .   (rule 504)

    $default	reduce using rule 504 (encaps_var_offset)



state 586

    encaps_var_offset  ->  "number (T_NUM_STRING)" .   (rule 503)

    $default	reduce using rule 503 (encaps_var_offset)



state 587

    encaps_var  ->  "variable (T_VARIABLE)" '[' @72 encaps_var_offset . ']'   (rule 497)

    ']' 	shift, and go to state 664



state 588

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" "variable name (T_STRING_VARNAME)" '[' expr . ']' '}'   (rule 500)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ']' 	shift, and go to state 665



state 589

    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 . function_call_parameter_list ')'   (rule 347)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 666
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 590

    top_statement  ->  "namespace (T_NAMESPACE)" '{' @3 top_statement_list '}' .   (rule 15)

    $default	reduce using rule 15 (top_statement)



state 591

    top_statement_list  ->  top_statement_list . @1 top_statement   (rule 3)
    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name '{' @2 top_statement_list . '}'   (rule 13)

    '}' 	shift, and go to state 667

    $default	reduce using rule 2 (@1)

    @1  	go to state 2



state 592

    function_call  ->  "\\ (T_NS_SEPARATOR)" namespace_name '(' @57 function_call_parameter_list . ')'   (rule 349)

    ')' 	shift, and go to state 668



state 593

    expr_without_variable  ->  '(' new_expr ')' @48 instance_call .   (rule 311)

    $default	reduce using rule 311 (expr_without_variable)



state 594

    instance_call  ->  @40 . chaining_instance_call   (rule 250)

    '[' 	shift, and go to state 669
    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 670

    chaining_method_or_property	go to state 671
    chaining_dereference	go to state 672
    chaining_instance_call	go to state 673
    variable_property	go to state 674



state 595

    inner_statement  ->  "__halt_compiler (T_HALT_COMPILER)" '(' . ')' ';'   (rule 32)

    ')' 	shift, and go to state 675



state 596

    non_empty_function_call_parameter_list  ->  '&' w_variable .   (rule 171)

    $default	reduce using rule 171 (non_empty_function_call_parameter_list)



state 597

    function_call  ->  namespace_name '(' @55 function_call_parameter_list ')' .   (rule 345)

    $default	reduce using rule 345 (function_call)



state 598

    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' . expr_without_variable   (rule 172)
    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' . variable   (rule 173)
    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' . '&' w_variable   (rule 174)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 676
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 677
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 678
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 599

    constant_declaration  ->  constant_declaration ',' "identifier (T_STRING)" '=' static_scalar .   (rule 24)

    $default	reduce using rule 24 (constant_declaration)



state 600

    fully_qualified_class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" . namespace_name   (rule 365)

    "identifier (T_STRING)"	shift, and go to state 116

    namespace_name	go to state 679



state 601

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    fully_qualified_class_name  ->  "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 366)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 366 (fully_qualified_class_name)



state 602

    implements_list  ->  "implements (T_IMPLEMENTS)" . interface_list   (rule 115)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    interface_list	go to state 680
    fully_qualified_class_name	go to state 605



state 603

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" extends_from @30 implements_list . '{' class_statement_list '}'   (rule 102)

    '{' 	shift, and go to state 681



state 604

    interface_extends_list  ->  "extends (T_EXTENDS)" interface_list .   (rule 113)
    interface_list  ->  interface_list . ',' fully_qualified_class_name   (rule 117)

    ',' 	shift, and go to state 682

    $default	reduce using rule 113 (interface_extends_list)



state 605

    interface_list  ->  fully_qualified_class_name .   (rule 116)

    $default	reduce using rule 116 (interface_list)



state 606

    unticked_class_declaration_statement  ->  interface_entry "identifier (T_STRING)" @31 interface_extends_list '{' . class_statement_list '}'   (rule 104)

    $default	reduce using rule 185 (class_statement_list)

    class_statement_list	go to state 683



state 607

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 '(' . parameter_list ')' '{' inner_statement_list '}'   (rule 100)

    "identifier (T_STRING)"	shift, and go to state 116
    "array (T_ARRAY)"	shift, and go to state 608
    "callable (T_CALLABLE)"	shift, and go to state 609
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    ')' 	reduce using rule 154 (parameter_list)
    $default	reduce using rule 163 (optional_class_type)

    namespace_name	go to state 516
    parameter_list	go to state 684
    non_empty_parameter_list	go to state 611
    optional_class_type	go to state 612
    fully_qualified_class_name	go to state 613



state 608

    optional_class_type  ->  "array (T_ARRAY)" .   (rule 164)

    $default	reduce using rule 164 (optional_class_type)



state 609

    optional_class_type  ->  "callable (T_CALLABLE)" .   (rule 165)

    $default	reduce using rule 165 (optional_class_type)



state 610

    expr_without_variable  ->  function is_reference '(' @53 parameter_list . ')' lexical_vars '{' inner_statement_list '}'   (rule 334)

    ')' 	shift, and go to state 685



state 611

    parameter_list  ->  non_empty_parameter_list .   (rule 153)
    non_empty_parameter_list  ->  non_empty_parameter_list . ',' optional_class_type "variable (T_VARIABLE)"   (rule 159)
    non_empty_parameter_list  ->  non_empty_parameter_list . ',' optional_class_type '&' "variable (T_VARIABLE)"   (rule 160)
    non_empty_parameter_list  ->  non_empty_parameter_list . ',' optional_class_type '&' "variable (T_VARIABLE)" '=' static_scalar   (rule 161)
    non_empty_parameter_list  ->  non_empty_parameter_list . ',' optional_class_type "variable (T_VARIABLE)" '=' static_scalar   (rule 162)

    ',' 	shift, and go to state 686

    $default	reduce using rule 153 (parameter_list)



state 612

    non_empty_parameter_list  ->  optional_class_type . "variable (T_VARIABLE)"   (rule 155)
    non_empty_parameter_list  ->  optional_class_type . '&' "variable (T_VARIABLE)"   (rule 156)
    non_empty_parameter_list  ->  optional_class_type . '&' "variable (T_VARIABLE)" '=' static_scalar   (rule 157)
    non_empty_parameter_list  ->  optional_class_type . "variable (T_VARIABLE)" '=' static_scalar   (rule 158)

    '&' 	shift, and go to state 687
    "variable (T_VARIABLE)"	shift, and go to state 688



state 613

    optional_class_type  ->  fully_qualified_class_name .   (rule 166)

    $default	reduce using rule 166 (optional_class_type)



state 614

    array_function_dereference  ->  function_call @69 '[' dim_offset ']' .   (rule 451)

    $default	reduce using rule 451 (array_function_dereference)



state 615

    variable_name  ->  '{' expr '}' .   (rule 472)

    $default	reduce using rule 472 (variable_name)



state 616

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @59 . function_call_parameter_list ')'   (rule 353)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 689
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 617

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @58 . function_call_parameter_list ')'   (rule 351)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 690
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 618

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    expr_without_variable  ->  expr '?' ':' @51 expr .   (rule 316)

    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 316 (expr_without_variable)



state 619

    expr_without_variable  ->  expr '?' @49 expr ':' . @50 expr   (rule 314)

    $default	reduce using rule 313 (@50)

    @50 	go to state 691



state 620

    expr_without_variable  ->  variable '=' '&' "new (T_NEW)" class_name_reference . @43 ctor_arguments   (rule 258)

    $default	reduce using rule 257 (@43)

    @43 	go to state 692



state 621

    function_call  ->  variable_without_objects '(' @62 function_call_parameter_list ')' .   (rule 359)

    $default	reduce using rule 359 (function_call)



state 622

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @61 . function_call_parameter_list ')'   (rule 357)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 693
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 623

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @60 . function_call_parameter_list ')'   (rule 355)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 694
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 624

    object_property  ->  variable_without_objects @70 .   (rule 467)

    $default	reduce using rule 467 (object_property)



state 625

    variable  ->  base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" @65 object_property @66 . method_or_not variable_properties   (rule 431)

    '(' 	shift, and go to state 695

    $default	reduce using rule 443 (method_or_not)

    array_method_dereference	go to state 696
    method	go to state 697
    method_or_not	go to state 698



state 626

    object_dim_list  ->  object_dim_list '[' . dim_offset ']'   (rule 468)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 699
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 627

    object_dim_list  ->  object_dim_list '{' . expr '}'   (rule 469)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 700
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 628

    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" '&' . w_variable   (rule 487)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    w_variable	go to state 701
    variable	go to state 292
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 629

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" expr .   (rule 483)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 483 (non_empty_array_pair_list)



state 630

    ctor_arguments  ->  '(' function_call_parameter_list ')' .   (rule 383)

    $default	reduce using rule 383 (ctor_arguments)



state 631

    dynamic_class_name_reference  ->  base_variable "-> (T_OBJECT_OPERATOR)" @63 object_property @64 . dynamic_class_name_variable_properties   (rule 371)

    $default	reduce using rule 374 (dynamic_class_name_variable_properties)

    dynamic_class_name_variable_properties	go to state 702



state 632

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 . inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 703



state 633

    unticked_statement  ->  "if (T_IF)" '(' expr ')' @5 statement . @6 elseif_list else_single   (rule 38)

    $default	reduce using rule 37 (@6)

    @6  	go to state 704



state 634

    unticked_statement  ->  "do (T_DO)" @11 statement "while (T_WHILE)" '(' @12 . expr ')' ';'   (rule 47)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 705
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 635

    unticked_statement  ->  "while (T_WHILE)" '(' @9 expr ')' @10 . while_statement   (rule 44)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    ':' 	shift, and go to state 706
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 707
    unticked_statement	go to state 86
    while_statement	go to state 708
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 636

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr . ';' @14 for_expr ')' @15 for_statement   (rule 51)

    ';' 	shift, and go to state 709



state 637

    non_empty_for_expr  ->  non_empty_for_expr ',' @38 expr .   (rule 238)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 238 (non_empty_for_expr)



state 638

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 variable . foreach_optional_arg ')' @20 foreach_statement   (rule 72)

    "=> (T_DOUBLE_ARROW)"	shift, and go to state 710

    $default	reduce using rule 118 (foreach_optional_arg)

    foreach_optional_arg	go to state 711



state 639

    foreach_variable  ->  '&' . variable   (rule 121)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 712
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 640

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 foreach_variable . foreach_optional_arg ')' @18 foreach_statement   (rule 69)

    "=> (T_DOUBLE_ARROW)"	shift, and go to state 710

    $default	reduce using rule 118 (foreach_optional_arg)

    foreach_optional_arg	go to state 713



state 641

    foreach_variable  ->  variable .   (rule 120)

    $default	reduce using rule 120 (foreach_variable)



state 642

    declare_list  ->  "identifier (T_STRING)" '=' static_scalar .   (rule 128)

    $default	reduce using rule 128 (declare_list)



state 643

    declare_list  ->  declare_list ',' "identifier (T_STRING)" . '=' static_scalar   (rule 129)

    '=' 	shift, and go to state 714



state 644

    declare_statement  ->  ':' . inner_statement_list "enddeclare (T_ENDDECLARE)" ';'   (rule 127)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 715



state 645

    declare_statement  ->  statement .   (rule 126)

    $default	reduce using rule 126 (declare_statement)



state 646

    unticked_statement  ->  "declare (T_DECLARE)" @21 '(' declare_list ')' declare_statement .   (rule 74)

    $default	reduce using rule 74 (unticked_statement)



state 647

    switch_case_list  ->  ':' . case_list "endswitch (T_ENDSWITCH)" ';'   (rule 132)
    switch_case_list  ->  ':' . ';' case_list "endswitch (T_ENDSWITCH)" ';'   (rule 133)

    ';' 	shift, and go to state 716

    $default	reduce using rule 134 (case_list)

    case_list	go to state 717



state 648

    switch_case_list  ->  '{' . case_list '}'   (rule 130)
    switch_case_list  ->  '{' . ';' case_list '}'   (rule 131)

    ';' 	shift, and go to state 718

    $default	reduce using rule 134 (case_list)

    case_list	go to state 719



state 649

    unticked_statement  ->  "switch (T_SWITCH)" '(' expr ')' @16 switch_case_list .   (rule 53)

    $default	reduce using rule 53 (unticked_statement)



state 650

    non_empty_static_array_pair_list  ->  static_scalar "=> (T_DOUBLE_ARROW)" . static_scalar   (rule 422)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 720
    static_class_constant	go to state 471



state 651

    static_scalar  ->  '[' static_array_pair_list ']' .   (rule 403)

    $default	reduce using rule 403 (static_scalar)



state 652

    possible_comma  ->  ',' .   (rule 419)
    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list ',' . static_scalar "=> (T_DOUBLE_ARROW)" static_scalar   (rule 420)
    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list ',' . static_scalar   (rule 421)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    $default	reduce using rule 419 (possible_comma)

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 721
    static_class_constant	go to state 471



state 653

    static_array_pair_list  ->  non_empty_static_array_pair_list possible_comma .   (rule 417)

    $default	reduce using rule 417 (static_array_pair_list)



state 654

    static_scalar  ->  "array (T_ARRAY)" '(' static_array_pair_list . ')'   (rule 402)

    ')' 	shift, and go to state 722



state 655

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 362)
    static_scalar  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 398)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	reduce using rule 362 (class_name)
    $default	reduce using rule 398 (static_scalar)



state 656

    static_class_constant  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)" .   (rule 406)

    $default	reduce using rule 406 (static_class_constant)



state 657

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" . '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    '(' 	shift, and go to state 723



state 658

    static_var_list  ->  static_var_list ',' "variable (T_VARIABLE)" '=' static_scalar .   (rule 181)

    $default	reduce using rule 181 (static_var_list)



state 659

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 parameter_list . ')' lexical_vars '{' inner_statement_list '}'   (rule 336)

    ')' 	shift, and go to state 724



state 660

    isset_variables  ->  isset_variables ',' @73 variable .   (rule 514)

    $default	reduce using rule 514 (isset_variables)



state 661

    assignment_list_element  ->  "list (T_LIST)" '(' @71 . assignment_list ')'   (rule 479)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "list (T_LIST)"	shift, and go to state 487
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    $default	reduce using rule 480 (assignment_list_element)

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 488
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    assignment_list	go to state 725
    assignment_list_element	go to state 490



state 662

    assignment_list  ->  assignment_list ',' assignment_list_element .   (rule 475)

    $default	reduce using rule 475 (assignment_list)



state 663

    expr_without_variable  ->  "list (T_LIST)" '(' @42 assignment_list ')' '=' . expr   (rule 254)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 726
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 664

    encaps_var  ->  "variable (T_VARIABLE)" '[' @72 encaps_var_offset ']' .   (rule 497)

    $default	reduce using rule 497 (encaps_var)



state 665

    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" "variable name (T_STRING_VARNAME)" '[' expr ']' . '}'   (rule 500)

    '}' 	shift, and go to state 727



state 666

    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 function_call_parameter_list . ')'   (rule 347)

    ')' 	shift, and go to state 728



state 667

    top_statement  ->  "namespace (T_NAMESPACE)" namespace_name '{' @2 top_statement_list '}' .   (rule 13)

    $default	reduce using rule 13 (top_statement)



state 668

    function_call  ->  "\\ (T_NS_SEPARATOR)" namespace_name '(' @57 function_call_parameter_list ')' .   (rule 349)

    $default	reduce using rule 349 (function_call)



state 669

    chaining_dereference  ->  '[' . dim_offset ']'   (rule 243)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 729
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 670

    variable_property  ->  "-> (T_OBJECT_OPERATOR)" . object_property @67 method_or_not   (rule 436)

    "identifier (T_STRING)"	shift, and go to state 436
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 540
    reference_variable	go to state 382
    compound_variable	go to state 111
    object_property	go to state 730
    object_dim_list	go to state 542
    variable_name	go to state 543
    simple_indirect_reference	go to state 384



state 671

    chaining_method_or_property  ->  chaining_method_or_property . variable_property   (rule 240)
    chaining_instance_call  ->  chaining_method_or_property .   (rule 247)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 670

    $default	reduce using rule 247 (chaining_instance_call)

    variable_property	go to state 731



state 672

    chaining_dereference  ->  chaining_dereference . '[' dim_offset ']'   (rule 242)
    chaining_instance_call  ->  chaining_dereference . @39 chaining_method_or_property   (rule 245)
    chaining_instance_call  ->  chaining_dereference .   (rule 246)

    '[' 	shift, and go to state 732

    "-> (T_OBJECT_OPERATOR)"	reduce using rule 244 (@39)
    $default	reduce using rule 246 (chaining_instance_call)

    @39 	go to state 733



state 673

    instance_call  ->  @40 chaining_instance_call .   (rule 250)

    $default	reduce using rule 250 (instance_call)



state 674

    chaining_method_or_property  ->  variable_property .   (rule 241)

    $default	reduce using rule 241 (chaining_method_or_property)



state 675

    inner_statement  ->  "__halt_compiler (T_HALT_COMPILER)" '(' ')' . ';'   (rule 32)

    ';' 	shift, and go to state 734



state 676

    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' '&' . w_variable   (rule 174)

    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    function_call	go to state 96
    class_name	go to state 134
    w_variable	go to state 735
    variable	go to state 292
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 677

    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' expr_without_variable .   (rule 172)
    expr  ->  expr_without_variable .   (rule 425)

    ',' 	reduce using rule 172 (non_empty_function_call_parameter_list)
    ')' 	reduce using rule 172 (non_empty_function_call_parameter_list)
    $default	reduce using rule 425 (expr)



state 678

    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' variable .   (rule 173)
    expr_without_variable  ->  variable . '=' expr   (rule 255)
    expr_without_variable  ->  variable . '=' '&' variable   (rule 256)
    expr_without_variable  ->  variable . '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments   (rule 258)
    expr_without_variable  ->  variable . "+= (T_PLUS_EQUAL)" expr   (rule 260)
    expr_without_variable  ->  variable . "-= (T_MINUS_EQUAL)" expr   (rule 261)
    expr_without_variable  ->  variable . "*= (T_MUL_EQUAL)" expr   (rule 262)
    expr_without_variable  ->  variable . "/= (T_DIV_EQUAL)" expr   (rule 263)
    expr_without_variable  ->  variable . ".= (T_CONCAT_EQUAL)" expr   (rule 264)
    expr_without_variable  ->  variable . "%= (T_MOD_EQUAL)" expr   (rule 265)
    expr_without_variable  ->  variable . "&= (T_AND_EQUAL)" expr   (rule 266)
    expr_without_variable  ->  variable . "|= (T_OR_EQUAL)" expr   (rule 267)
    expr_without_variable  ->  variable . "^= (T_XOR_EQUAL)" expr   (rule 268)
    expr_without_variable  ->  variable . "<<= (T_SL_EQUAL)" expr   (rule 269)
    expr_without_variable  ->  variable . ">>= (T_SR_EQUAL)" expr   (rule 270)
    r_variable  ->  variable .   (rule 426)
    rw_variable  ->  variable .   (rule 428)

    '=' 	shift, and go to state 264
    "+= (T_PLUS_EQUAL)"	shift, and go to state 265
    "-= (T_MINUS_EQUAL)"	shift, and go to state 266
    "*= (T_MUL_EQUAL)"	shift, and go to state 267
    "/= (T_DIV_EQUAL)"	shift, and go to state 268
    ".= (T_CONCAT_EQUAL)"	shift, and go to state 269
    "%= (T_MOD_EQUAL)"	shift, and go to state 270
    "&= (T_AND_EQUAL)"	shift, and go to state 271
    "|= (T_OR_EQUAL)"	shift, and go to state 272
    "^= (T_XOR_EQUAL)"	shift, and go to state 273
    "<<= (T_SL_EQUAL)"	shift, and go to state 274
    ">>= (T_SR_EQUAL)"	shift, and go to state 275

    ',' 	reduce using rule 173 (non_empty_function_call_parameter_list)
    "++ (T_INC)"	reduce using rule 428 (rw_variable)
    "-- (T_DEC)"	reduce using rule 428 (rw_variable)
    ')' 	reduce using rule 173 (non_empty_function_call_parameter_list)
    $default	reduce using rule 426 (r_variable)



state 679

    namespace_name  ->  namespace_name . "\\ (T_NS_SEPARATOR)" "identifier (T_STRING)"   (rule 6)
    fully_qualified_class_name  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name .   (rule 365)

    "\\ (T_NS_SEPARATOR)"	shift, and go to state 225

    $default	reduce using rule 365 (fully_qualified_class_name)



state 680

    implements_list  ->  "implements (T_IMPLEMENTS)" interface_list .   (rule 115)
    interface_list  ->  interface_list . ',' fully_qualified_class_name   (rule 117)

    ',' 	shift, and go to state 682

    $default	reduce using rule 115 (implements_list)



state 681

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" extends_from @30 implements_list '{' . class_statement_list '}'   (rule 102)

    $default	reduce using rule 185 (class_statement_list)

    class_statement_list	go to state 736



state 682

    interface_list  ->  interface_list ',' . fully_qualified_class_name   (rule 117)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    fully_qualified_class_name	go to state 737



state 683

    unticked_class_declaration_statement  ->  interface_entry "identifier (T_STRING)" @31 interface_extends_list '{' class_statement_list . '}'   (rule 104)
    class_statement_list  ->  class_statement_list . class_statement   (rule 184)

    "const (T_CONST)"	shift, and go to state 738
    "use (T_USE)"	shift, and go to state 739
    "static (T_STATIC)"	shift, and go to state 740
    "abstract (T_ABSTRACT)"	shift, and go to state 741
    "final (T_FINAL)"	shift, and go to state 742
    "private (T_PRIVATE)"	shift, and go to state 743
    "protected (T_PROTECTED)"	shift, and go to state 744
    "public (T_PUBLIC)"	shift, and go to state 745
    "var (T_VAR)"	shift, and go to state 746
    '}' 	shift, and go to state 747

    $default	reduce using rule 217 (method_modifiers)

    class_statement	go to state 748
    trait_use_statement	go to state 749
    variable_modifiers	go to state 750
    method_modifiers	go to state 751
    non_empty_member_modifiers	go to state 752
    member_modifier	go to state 753
    class_constant_declaration	go to state 754



state 684

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 '(' parameter_list . ')' '{' inner_statement_list '}'   (rule 100)

    ')' 	shift, and go to state 755



state 685

    expr_without_variable  ->  function is_reference '(' @53 parameter_list ')' . lexical_vars '{' inner_statement_list '}'   (rule 334)

    "use (T_USE)"	shift, and go to state 756

    $default	reduce using rule 338 (lexical_vars)

    lexical_vars	go to state 757



state 686

    non_empty_parameter_list  ->  non_empty_parameter_list ',' . optional_class_type "variable (T_VARIABLE)"   (rule 159)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' . optional_class_type '&' "variable (T_VARIABLE)"   (rule 160)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' . optional_class_type '&' "variable (T_VARIABLE)" '=' static_scalar   (rule 161)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' . optional_class_type "variable (T_VARIABLE)" '=' static_scalar   (rule 162)

    "identifier (T_STRING)"	shift, and go to state 116
    "array (T_ARRAY)"	shift, and go to state 608
    "callable (T_CALLABLE)"	shift, and go to state 609
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    $default	reduce using rule 163 (optional_class_type)

    namespace_name	go to state 516
    optional_class_type	go to state 758
    fully_qualified_class_name	go to state 613



state 687

    non_empty_parameter_list  ->  optional_class_type '&' . "variable (T_VARIABLE)"   (rule 156)
    non_empty_parameter_list  ->  optional_class_type '&' . "variable (T_VARIABLE)" '=' static_scalar   (rule 157)

    "variable (T_VARIABLE)"	shift, and go to state 759



state 688

    non_empty_parameter_list  ->  optional_class_type "variable (T_VARIABLE)" .   (rule 155)
    non_empty_parameter_list  ->  optional_class_type "variable (T_VARIABLE)" . '=' static_scalar   (rule 158)

    '=' 	shift, and go to state 760

    $default	reduce using rule 155 (non_empty_parameter_list)



state 689

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @59 function_call_parameter_list . ')'   (rule 353)

    ')' 	shift, and go to state 761



state 690

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @58 function_call_parameter_list . ')'   (rule 351)

    ')' 	shift, and go to state 762



state 691

    expr_without_variable  ->  expr '?' @49 expr ':' @50 . expr   (rule 314)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 763
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 692

    expr_without_variable  ->  variable '=' '&' "new (T_NEW)" class_name_reference @43 . ctor_arguments   (rule 258)

    '(' 	shift, and go to state 443

    $default	reduce using rule 382 (ctor_arguments)

    ctor_arguments	go to state 764



state 693

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @61 function_call_parameter_list . ')'   (rule 357)

    ')' 	shift, and go to state 765



state 694

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @60 function_call_parameter_list . ')'   (rule 355)

    ')' 	shift, and go to state 766



state 695

    method  ->  '(' . @68 function_call_parameter_list ')'   (rule 440)

    $default	reduce using rule 439 (@68)

    @68 	go to state 767



state 696

    array_method_dereference  ->  array_method_dereference . '[' dim_offset ']'   (rule 437)
    method_or_not  ->  array_method_dereference .   (rule 442)

    '[' 	shift, and go to state 768

    $default	reduce using rule 442 (method_or_not)



state 697

    array_method_dereference  ->  method . '[' dim_offset ']'   (rule 438)
    method_or_not  ->  method .   (rule 441)

    '[' 	shift, and go to state 769

    $default	reduce using rule 441 (method_or_not)



state 698

    variable  ->  base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" @65 object_property @66 method_or_not . variable_properties   (rule 431)

    $default	reduce using rule 434 (variable_properties)

    variable_properties	go to state 770



state 699

    object_dim_list  ->  object_dim_list '[' dim_offset . ']'   (rule 468)

    ']' 	shift, and go to state 771



state 700

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)
    object_dim_list  ->  object_dim_list '{' expr . '}'   (rule 469)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    '}' 	shift, and go to state 772



state 701

    non_empty_array_pair_list  ->  non_empty_array_pair_list ',' expr "=> (T_DOUBLE_ARROW)" '&' w_variable .   (rule 487)

    $default	reduce using rule 487 (non_empty_array_pair_list)



state 702

    dynamic_class_name_reference  ->  base_variable "-> (T_OBJECT_OPERATOR)" @63 object_property @64 dynamic_class_name_variable_properties .   (rule 371)
    dynamic_class_name_variable_properties  ->  dynamic_class_name_variable_properties . dynamic_class_name_variable_property   (rule 373)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 773

    $default	reduce using rule 371 (dynamic_class_name_reference)

    dynamic_class_name_variable_property	go to state 774



state 703

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list . @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    "elseif (T_ELSEIF)"	reduce using rule 40 (@8)
    "else (T_ELSE)"	reduce using rule 40 (@8)
    "endif (T_ENDIF)"	reduce using rule 40 (@8)
    $default	reduce using rule 26 (@4)

    @4  	go to state 366
    @8  	go to state 775



state 704

    unticked_statement  ->  "if (T_IF)" '(' expr ')' @5 statement @6 . elseif_list else_single   (rule 38)

    $default	reduce using rule 143 (elseif_list)

    elseif_list	go to state 776



state 705

    unticked_statement  ->  "do (T_DO)" @11 statement "while (T_WHILE)" '(' @12 expr . ')' ';'   (rule 47)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 777



state 706

    while_statement  ->  ':' . inner_statement_list "endwhile (T_ENDWHILE)" ';'   (rule 142)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 778



state 707

    while_statement  ->  statement .   (rule 141)

    $default	reduce using rule 141 (while_statement)



state 708

    unticked_statement  ->  "while (T_WHILE)" '(' @9 expr ')' @10 while_statement .   (rule 44)

    $default	reduce using rule 44 (unticked_statement)



state 709

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' . @14 for_expr ')' @15 for_statement   (rule 51)

    $default	reduce using rule 49 (@14)

    @14 	go to state 779



state 710

    foreach_optional_arg  ->  "=> (T_DOUBLE_ARROW)" . foreach_variable   (rule 119)

    '&' 	shift, and go to state 639
    "identifier (T_STRING)"	shift, and go to state 116
    "variable (T_VARIABLE)"	shift, and go to state 33
    "static (T_STATIC)"	shift, and go to state 130
    "namespace (T_NAMESPACE)"	shift, and go to state 131
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 132
    '$' 	shift, and go to state 79

    namespace_name	go to state 133
    foreach_variable	go to state 780
    function_call	go to state 96
    class_name	go to state 134
    variable	go to state 641
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 137
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112



state 711

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg . ')' @20 foreach_statement   (rule 72)

    ')' 	shift, and go to state 781



state 712

    foreach_variable  ->  '&' variable .   (rule 121)

    $default	reduce using rule 121 (foreach_variable)



state 713

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 foreach_variable foreach_optional_arg . ')' @18 foreach_statement   (rule 69)

    ')' 	shift, and go to state 782



state 714

    declare_list  ->  declare_list ',' "identifier (T_STRING)" '=' . static_scalar   (rule 129)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 783
    static_class_constant	go to state 471



state 715

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    declare_statement  ->  ':' inner_statement_list . "enddeclare (T_ENDDECLARE)" ';'   (rule 127)

    "enddeclare (T_ENDDECLARE)"	shift, and go to state 784

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 716

    switch_case_list  ->  ':' ';' . case_list "endswitch (T_ENDSWITCH)" ';'   (rule 133)

    $default	reduce using rule 134 (case_list)

    case_list	go to state 785



state 717

    switch_case_list  ->  ':' case_list . "endswitch (T_ENDSWITCH)" ';'   (rule 132)
    case_list  ->  case_list . "case (T_CASE)" expr case_separator @32 inner_statement_list   (rule 136)
    case_list  ->  case_list . "default (T_DEFAULT)" case_separator @33 inner_statement_list   (rule 138)

    "endswitch (T_ENDSWITCH)"	shift, and go to state 786
    "case (T_CASE)"	shift, and go to state 787
    "default (T_DEFAULT)"	shift, and go to state 788



state 718

    switch_case_list  ->  '{' ';' . case_list '}'   (rule 131)

    $default	reduce using rule 134 (case_list)

    case_list	go to state 789



state 719

    switch_case_list  ->  '{' case_list . '}'   (rule 130)
    case_list  ->  case_list . "case (T_CASE)" expr case_separator @32 inner_statement_list   (rule 136)
    case_list  ->  case_list . "default (T_DEFAULT)" case_separator @33 inner_statement_list   (rule 138)

    "case (T_CASE)"	shift, and go to state 787
    "default (T_DEFAULT)"	shift, and go to state 788
    '}' 	shift, and go to state 790



state 720

    non_empty_static_array_pair_list  ->  static_scalar "=> (T_DOUBLE_ARROW)" static_scalar .   (rule 422)

    $default	reduce using rule 422 (non_empty_static_array_pair_list)



state 721

    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list ',' static_scalar . "=> (T_DOUBLE_ARROW)" static_scalar   (rule 420)
    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list ',' static_scalar .   (rule 421)

    "=> (T_DOUBLE_ARROW)"	shift, and go to state 791

    $default	reduce using rule 421 (non_empty_static_array_pair_list)



state 722

    static_scalar  ->  "array (T_ARRAY)" '(' static_array_pair_list ')' .   (rule 402)

    $default	reduce using rule 402 (static_scalar)



state 723

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' . @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    $default	reduce using rule 77 (@23)

    @23 	go to state 792



state 724

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 parameter_list ')' . lexical_vars '{' inner_statement_list '}'   (rule 336)

    "use (T_USE)"	shift, and go to state 756

    $default	reduce using rule 338 (lexical_vars)

    lexical_vars	go to state 793



state 725

    assignment_list  ->  assignment_list . ',' assignment_list_element   (rule 475)
    assignment_list_element  ->  "list (T_LIST)" '(' @71 assignment_list . ')'   (rule 479)

    ',' 	shift, and go to state 582
    ')' 	shift, and go to state 794



state 726

    expr_without_variable  ->  "list (T_LIST)" '(' @42 assignment_list ')' '=' expr .   (rule 254)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 254 (expr_without_variable)



state 727

    encaps_var  ->  "${ (T_DOLLAR_OPEN_CURLY_BRACES)" "variable name (T_STRING_VARNAME)" '[' expr ']' '}' .   (rule 500)

    $default	reduce using rule 500 (encaps_var)



state 728

    function_call  ->  "namespace (T_NAMESPACE)" "\\ (T_NS_SEPARATOR)" namespace_name '(' @56 function_call_parameter_list ')' .   (rule 347)

    $default	reduce using rule 347 (function_call)



state 729

    chaining_dereference  ->  '[' dim_offset . ']'   (rule 243)

    ']' 	shift, and go to state 795



state 730

    variable_property  ->  "-> (T_OBJECT_OPERATOR)" object_property . @67 method_or_not   (rule 436)

    $default	reduce using rule 435 (@67)

    @67 	go to state 796



state 731

    chaining_method_or_property  ->  chaining_method_or_property variable_property .   (rule 240)

    $default	reduce using rule 240 (chaining_method_or_property)



state 732

    chaining_dereference  ->  chaining_dereference '[' . dim_offset ']'   (rule 242)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 797
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 733

    chaining_instance_call  ->  chaining_dereference @39 . chaining_method_or_property   (rule 245)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 670

    chaining_method_or_property	go to state 798
    variable_property	go to state 674



state 734

    inner_statement  ->  "__halt_compiler (T_HALT_COMPILER)" '(' ')' ';' .   (rule 32)

    $default	reduce using rule 32 (inner_statement)



state 735

    non_empty_function_call_parameter_list  ->  non_empty_function_call_parameter_list ',' '&' w_variable .   (rule 174)

    $default	reduce using rule 174 (non_empty_function_call_parameter_list)



state 736

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" extends_from @30 implements_list '{' class_statement_list . '}'   (rule 102)
    class_statement_list  ->  class_statement_list . class_statement   (rule 184)

    "const (T_CONST)"	shift, and go to state 738
    "use (T_USE)"	shift, and go to state 739
    "static (T_STATIC)"	shift, and go to state 740
    "abstract (T_ABSTRACT)"	shift, and go to state 741
    "final (T_FINAL)"	shift, and go to state 742
    "private (T_PRIVATE)"	shift, and go to state 743
    "protected (T_PROTECTED)"	shift, and go to state 744
    "public (T_PUBLIC)"	shift, and go to state 745
    "var (T_VAR)"	shift, and go to state 746
    '}' 	shift, and go to state 799

    $default	reduce using rule 217 (method_modifiers)

    class_statement	go to state 748
    trait_use_statement	go to state 749
    variable_modifiers	go to state 750
    method_modifiers	go to state 751
    non_empty_member_modifiers	go to state 752
    member_modifier	go to state 753
    class_constant_declaration	go to state 754



state 737

    interface_list  ->  interface_list ',' fully_qualified_class_name .   (rule 117)

    $default	reduce using rule 117 (interface_list)



state 738

    class_constant_declaration  ->  "const (T_CONST)" . "identifier (T_STRING)" '=' static_scalar   (rule 232)

    "identifier (T_STRING)"	shift, and go to state 800



state 739

    trait_use_statement  ->  "use (T_USE)" . trait_list trait_adaptations   (rule 192)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    trait_list	go to state 801
    fully_qualified_class_name	go to state 802



state 740

    member_modifier  ->  "static (T_STATIC)" .   (rule 224)

    $default	reduce using rule 224 (member_modifier)



state 741

    member_modifier  ->  "abstract (T_ABSTRACT)" .   (rule 225)

    $default	reduce using rule 225 (member_modifier)



state 742

    member_modifier  ->  "final (T_FINAL)" .   (rule 226)

    $default	reduce using rule 226 (member_modifier)



state 743

    member_modifier  ->  "private (T_PRIVATE)" .   (rule 223)

    $default	reduce using rule 223 (member_modifier)



state 744

    member_modifier  ->  "protected (T_PROTECTED)" .   (rule 222)

    $default	reduce using rule 222 (member_modifier)



state 745

    member_modifier  ->  "public (T_PUBLIC)" .   (rule 221)

    $default	reduce using rule 221 (member_modifier)



state 746

    variable_modifiers  ->  "var (T_VAR)" .   (rule 216)

    $default	reduce using rule 216 (variable_modifiers)



state 747

    unticked_class_declaration_statement  ->  interface_entry "identifier (T_STRING)" @31 interface_extends_list '{' class_statement_list '}' .   (rule 104)

    $default	reduce using rule 104 (unticked_class_declaration_statement)



state 748

    class_statement_list  ->  class_statement_list class_statement .   (rule 184)

    $default	reduce using rule 184 (class_statement_list)



state 749

    class_statement  ->  trait_use_statement .   (rule 189)

    $default	reduce using rule 189 (class_statement)



state 750

    class_statement  ->  variable_modifiers . @36 class_variable_declaration ';'   (rule 187)

    $default	reduce using rule 186 (@36)

    @36 	go to state 803



state 751

    class_statement  ->  method_modifiers . function is_reference "identifier (T_STRING)" @37 '(' parameter_list ')' method_body   (rule 191)

    "function (T_FUNCTION)"	shift, and go to state 46

    function	go to state 804



state 752

    variable_modifiers  ->  non_empty_member_modifiers .   (rule 215)
    method_modifiers  ->  non_empty_member_modifiers .   (rule 218)
    non_empty_member_modifiers  ->  non_empty_member_modifiers . member_modifier   (rule 220)

    "static (T_STATIC)"	shift, and go to state 740
    "abstract (T_ABSTRACT)"	shift, and go to state 741
    "final (T_FINAL)"	shift, and go to state 742
    "private (T_PRIVATE)"	shift, and go to state 743
    "protected (T_PROTECTED)"	shift, and go to state 744
    "public (T_PUBLIC)"	shift, and go to state 745

    "function (T_FUNCTION)"	reduce using rule 218 (method_modifiers)
    $default	reduce using rule 215 (variable_modifiers)

    member_modifier	go to state 805



state 753

    non_empty_member_modifiers  ->  member_modifier .   (rule 219)

    $default	reduce using rule 219 (non_empty_member_modifiers)



state 754

    class_statement  ->  class_constant_declaration . ';'   (rule 188)
    class_constant_declaration  ->  class_constant_declaration . ',' "identifier (T_STRING)" '=' static_scalar   (rule 231)

    ',' 	shift, and go to state 806
    ';' 	shift, and go to state 807



state 755

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 '(' parameter_list ')' . '{' inner_statement_list '}'   (rule 100)

    '{' 	shift, and go to state 808



state 756

    lexical_vars  ->  "use (T_USE)" . '(' lexical_var_list ')'   (rule 339)

    '(' 	shift, and go to state 809



state 757

    expr_without_variable  ->  function is_reference '(' @53 parameter_list ')' lexical_vars . '{' inner_statement_list '}'   (rule 334)

    '{' 	shift, and go to state 810



state 758

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type . "variable (T_VARIABLE)"   (rule 159)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type . '&' "variable (T_VARIABLE)"   (rule 160)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type . '&' "variable (T_VARIABLE)" '=' static_scalar   (rule 161)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type . "variable (T_VARIABLE)" '=' static_scalar   (rule 162)

    '&' 	shift, and go to state 811
    "variable (T_VARIABLE)"	shift, and go to state 812



state 759

    non_empty_parameter_list  ->  optional_class_type '&' "variable (T_VARIABLE)" .   (rule 156)
    non_empty_parameter_list  ->  optional_class_type '&' "variable (T_VARIABLE)" . '=' static_scalar   (rule 157)

    '=' 	shift, and go to state 813

    $default	reduce using rule 156 (non_empty_parameter_list)



state 760

    non_empty_parameter_list  ->  optional_class_type "variable (T_VARIABLE)" '=' . static_scalar   (rule 158)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 814
    static_class_constant	go to state 471



state 761

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @59 function_call_parameter_list ')' .   (rule 353)

    $default	reduce using rule 353 (function_call)



state 762

    function_call  ->  class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @58 function_call_parameter_list ')' .   (rule 351)

    $default	reduce using rule 351 (function_call)



state 763

    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr '?' @49 expr ':' @50 expr .   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260

    $default	reduce using rule 314 (expr_without_variable)



state 764

    expr_without_variable  ->  variable '=' '&' "new (T_NEW)" class_name_reference @43 ctor_arguments .   (rule 258)

    $default	reduce using rule 258 (expr_without_variable)



state 765

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_without_objects '(' @61 function_call_parameter_list ')' .   (rule 357)

    $default	reduce using rule 357 (function_call)



state 766

    function_call  ->  variable_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" variable_name '(' @60 function_call_parameter_list ')' .   (rule 355)

    $default	reduce using rule 355 (function_call)



state 767

    method  ->  '(' @68 . function_call_parameter_list ')'   (rule 440)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '&' 	shift, and go to state 508
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 168 (function_call_parameter_list)

    namespace_name	go to state 82
    function_call_parameter_list	go to state 815
    non_empty_function_call_parameter_list	go to state 510
    new_expr	go to state 93
    expr_without_variable	go to state 511
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 182
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 512
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 768

    array_method_dereference  ->  array_method_dereference '[' . dim_offset ']'   (rule 437)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 816
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 769

    array_method_dereference  ->  method '[' . dim_offset ']'   (rule 438)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 463 (dim_offset)

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 429
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    dim_offset	go to state 817
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 770

    variable  ->  base_variable_with_function_calls "-> (T_OBJECT_OPERATOR)" @65 object_property @66 method_or_not variable_properties .   (rule 431)
    variable_properties  ->  variable_properties . variable_property   (rule 433)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 670

    $default	reduce using rule 431 (variable)

    variable_property	go to state 818



state 771

    object_dim_list  ->  object_dim_list '[' dim_offset ']' .   (rule 468)

    $default	reduce using rule 468 (object_dim_list)



state 772

    object_dim_list  ->  object_dim_list '{' expr '}' .   (rule 469)

    $default	reduce using rule 469 (object_dim_list)



state 773

    dynamic_class_name_variable_property  ->  "-> (T_OBJECT_OPERATOR)" . object_property   (rule 375)

    "identifier (T_STRING)"	shift, and go to state 436
    "variable (T_VARIABLE)"	shift, and go to state 33
    '{' 	shift, and go to state 380
    '$' 	shift, and go to state 79

    variable_without_objects	go to state 540
    reference_variable	go to state 382
    compound_variable	go to state 111
    object_property	go to state 819
    object_dim_list	go to state 542
    variable_name	go to state 543
    simple_indirect_reference	go to state 384



state 774

    dynamic_class_name_variable_properties  ->  dynamic_class_name_variable_properties dynamic_class_name_variable_property .   (rule 373)

    $default	reduce using rule 373 (dynamic_class_name_variable_properties)



state 775

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list @8 . new_elseif_list new_else_single "endif (T_ENDIF)" ';'   (rule 41)

    $default	reduce using rule 146 (new_elseif_list)

    new_elseif_list	go to state 820



state 776

    unticked_statement  ->  "if (T_IF)" '(' expr ')' @5 statement @6 elseif_list . else_single   (rule 38)
    elseif_list  ->  elseif_list . "elseif (T_ELSEIF)" '(' expr ')' @34 statement   (rule 145)

    "elseif (T_ELSEIF)"	shift, and go to state 821
    "else (T_ELSE)"	shift, and go to state 822

    "elseif (T_ELSEIF)"	[reduce using rule 149 (else_single)]
    "else (T_ELSE)"	[reduce using rule 149 (else_single)]
    $default	reduce using rule 149 (else_single)

    else_single	go to state 823



state 777

    unticked_statement  ->  "do (T_DO)" @11 statement "while (T_WHILE)" '(' @12 expr ')' . ';'   (rule 47)

    ';' 	shift, and go to state 824



state 778

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    while_statement  ->  ':' inner_statement_list . "endwhile (T_ENDWHILE)" ';'   (rule 142)

    "endwhile (T_ENDWHILE)"	shift, and go to state 825

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 779

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' @14 . for_expr ')' @15 for_statement   (rule 51)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    $default	reduce using rule 235 (for_expr)

    namespace_name	go to state 82
    for_expr	go to state 826
    non_empty_for_expr	go to state 312
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 313
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 780

    foreach_optional_arg  ->  "=> (T_DOUBLE_ARROW)" foreach_variable .   (rule 119)

    $default	reduce using rule 119 (foreach_optional_arg)



state 781

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg ')' . @20 foreach_statement   (rule 72)

    $default	reduce using rule 71 (@20)

    @20 	go to state 827



state 782

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' . @18 foreach_statement   (rule 69)

    $default	reduce using rule 68 (@18)

    @18 	go to state 828



state 783

    declare_list  ->  declare_list ',' "identifier (T_STRING)" '=' static_scalar .   (rule 129)

    $default	reduce using rule 129 (declare_list)



state 784

    declare_statement  ->  ':' inner_statement_list "enddeclare (T_ENDDECLARE)" . ';'   (rule 127)

    ';' 	shift, and go to state 829



state 785

    switch_case_list  ->  ':' ';' case_list . "endswitch (T_ENDSWITCH)" ';'   (rule 133)
    case_list  ->  case_list . "case (T_CASE)" expr case_separator @32 inner_statement_list   (rule 136)
    case_list  ->  case_list . "default (T_DEFAULT)" case_separator @33 inner_statement_list   (rule 138)

    "endswitch (T_ENDSWITCH)"	shift, and go to state 830
    "case (T_CASE)"	shift, and go to state 787
    "default (T_DEFAULT)"	shift, and go to state 788



state 786

    switch_case_list  ->  ':' case_list "endswitch (T_ENDSWITCH)" . ';'   (rule 132)

    ';' 	shift, and go to state 831



state 787

    case_list  ->  case_list "case (T_CASE)" . expr case_separator @32 inner_statement_list   (rule 136)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 832
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 788

    case_list  ->  case_list "default (T_DEFAULT)" . case_separator @33 inner_statement_list   (rule 138)

    ':' 	shift, and go to state 833
    ';' 	shift, and go to state 834

    case_separator	go to state 835



state 789

    switch_case_list  ->  '{' ';' case_list . '}'   (rule 131)
    case_list  ->  case_list . "case (T_CASE)" expr case_separator @32 inner_statement_list   (rule 136)
    case_list  ->  case_list . "default (T_DEFAULT)" case_separator @33 inner_statement_list   (rule 138)

    "case (T_CASE)"	shift, and go to state 787
    "default (T_DEFAULT)"	shift, and go to state 788
    '}' 	shift, and go to state 836



state 790

    switch_case_list  ->  '{' case_list '}' .   (rule 130)

    $default	reduce using rule 130 (switch_case_list)



state 791

    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list ',' static_scalar "=> (T_DOUBLE_ARROW)" . static_scalar   (rule 420)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 837
    static_class_constant	go to state 471



state 792

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 . fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    fully_qualified_class_name	go to state 838



state 793

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 parameter_list ')' lexical_vars . '{' inner_statement_list '}'   (rule 336)

    '{' 	shift, and go to state 839



state 794

    assignment_list_element  ->  "list (T_LIST)" '(' @71 assignment_list ')' .   (rule 479)

    $default	reduce using rule 479 (assignment_list_element)



state 795

    chaining_dereference  ->  '[' dim_offset ']' .   (rule 243)

    $default	reduce using rule 243 (chaining_dereference)



state 796

    variable_property  ->  "-> (T_OBJECT_OPERATOR)" object_property @67 . method_or_not   (rule 436)

    '(' 	shift, and go to state 695

    $default	reduce using rule 443 (method_or_not)

    array_method_dereference	go to state 696
    method	go to state 697
    method_or_not	go to state 840



state 797

    chaining_dereference  ->  chaining_dereference '[' dim_offset . ']'   (rule 242)

    ']' 	shift, and go to state 841



state 798

    chaining_method_or_property  ->  chaining_method_or_property . variable_property   (rule 240)
    chaining_instance_call  ->  chaining_dereference @39 chaining_method_or_property .   (rule 245)

    "-> (T_OBJECT_OPERATOR)"	shift, and go to state 670

    $default	reduce using rule 245 (chaining_instance_call)

    variable_property	go to state 731



state 799

    unticked_class_declaration_statement  ->  class_entry_type "identifier (T_STRING)" extends_from @30 implements_list '{' class_statement_list '}' .   (rule 102)

    $default	reduce using rule 102 (unticked_class_declaration_statement)



state 800

    class_constant_declaration  ->  "const (T_CONST)" "identifier (T_STRING)" . '=' static_scalar   (rule 232)

    '=' 	shift, and go to state 842



state 801

    trait_use_statement  ->  "use (T_USE)" trait_list . trait_adaptations   (rule 192)
    trait_list  ->  trait_list . ',' fully_qualified_class_name   (rule 194)

    ',' 	shift, and go to state 843
    ';' 	shift, and go to state 844
    '{' 	shift, and go to state 845

    trait_adaptations	go to state 846



state 802

    trait_list  ->  fully_qualified_class_name .   (rule 193)

    $default	reduce using rule 193 (trait_list)



state 803

    class_statement  ->  variable_modifiers @36 . class_variable_declaration ';'   (rule 187)

    "variable (T_VARIABLE)"	shift, and go to state 847

    class_variable_declaration	go to state 848



state 804

    class_statement  ->  method_modifiers function . is_reference "identifier (T_STRING)" @37 '(' parameter_list ')' method_body   (rule 191)

    '&' 	shift, and go to state 231

    $default	reduce using rule 97 (is_reference)

    is_reference	go to state 849



state 805

    non_empty_member_modifiers  ->  non_empty_member_modifiers member_modifier .   (rule 220)

    $default	reduce using rule 220 (non_empty_member_modifiers)



state 806

    class_constant_declaration  ->  class_constant_declaration ',' . "identifier (T_STRING)" '=' static_scalar   (rule 231)

    "identifier (T_STRING)"	shift, and go to state 850



state 807

    class_statement  ->  class_constant_declaration ';' .   (rule 188)

    $default	reduce using rule 188 (class_statement)



state 808

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 '(' parameter_list ')' '{' . inner_statement_list '}'   (rule 100)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 851



state 809

    lexical_vars  ->  "use (T_USE)" '(' . lexical_var_list ')'   (rule 339)

    '&' 	shift, and go to state 852
    "variable (T_VARIABLE)"	shift, and go to state 853

    lexical_var_list	go to state 854



state 810

    expr_without_variable  ->  function is_reference '(' @53 parameter_list ')' lexical_vars '{' . inner_statement_list '}'   (rule 334)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 855



state 811

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type '&' . "variable (T_VARIABLE)"   (rule 160)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type '&' . "variable (T_VARIABLE)" '=' static_scalar   (rule 161)

    "variable (T_VARIABLE)"	shift, and go to state 856



state 812

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type "variable (T_VARIABLE)" .   (rule 159)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type "variable (T_VARIABLE)" . '=' static_scalar   (rule 162)

    '=' 	shift, and go to state 857

    $default	reduce using rule 159 (non_empty_parameter_list)



state 813

    non_empty_parameter_list  ->  optional_class_type '&' "variable (T_VARIABLE)" '=' . static_scalar   (rule 157)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 858
    static_class_constant	go to state 471



state 814

    non_empty_parameter_list  ->  optional_class_type "variable (T_VARIABLE)" '=' static_scalar .   (rule 158)

    $default	reduce using rule 158 (non_empty_parameter_list)



state 815

    method  ->  '(' @68 function_call_parameter_list . ')'   (rule 440)

    ')' 	shift, and go to state 859



state 816

    array_method_dereference  ->  array_method_dereference '[' dim_offset . ']'   (rule 437)

    ']' 	shift, and go to state 860



state 817

    array_method_dereference  ->  method '[' dim_offset . ']'   (rule 438)

    ']' 	shift, and go to state 861



state 818

    variable_properties  ->  variable_properties variable_property .   (rule 433)

    $default	reduce using rule 433 (variable_properties)



state 819

    dynamic_class_name_variable_property  ->  "-> (T_OBJECT_OPERATOR)" object_property .   (rule 375)

    $default	reduce using rule 375 (dynamic_class_name_variable_property)



state 820

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list @8 new_elseif_list . new_else_single "endif (T_ENDIF)" ';'   (rule 41)
    new_elseif_list  ->  new_elseif_list . "elseif (T_ELSEIF)" '(' expr ')' ':' @35 inner_statement_list   (rule 148)

    "elseif (T_ELSEIF)"	shift, and go to state 862
    "else (T_ELSE)"	shift, and go to state 863

    $default	reduce using rule 151 (new_else_single)

    new_else_single	go to state 864



state 821

    elseif_list  ->  elseif_list "elseif (T_ELSEIF)" . '(' expr ')' @34 statement   (rule 145)

    '(' 	shift, and go to state 865



state 822

    else_single  ->  "else (T_ELSE)" . statement   (rule 150)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 866
    unticked_statement	go to state 86
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 823

    unticked_statement  ->  "if (T_IF)" '(' expr ')' @5 statement @6 elseif_list else_single .   (rule 38)

    $default	reduce using rule 38 (unticked_statement)



state 824

    unticked_statement  ->  "do (T_DO)" @11 statement "while (T_WHILE)" '(' @12 expr ')' ';' .   (rule 47)

    $default	reduce using rule 47 (unticked_statement)



state 825

    while_statement  ->  ':' inner_statement_list "endwhile (T_ENDWHILE)" . ';'   (rule 142)

    ';' 	shift, and go to state 867



state 826

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' @14 for_expr . ')' @15 for_statement   (rule 51)

    ')' 	shift, and go to state 868



state 827

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg ')' @20 . foreach_statement   (rule 72)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    ':' 	shift, and go to state 869
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 870
    unticked_statement	go to state 86
    foreach_statement	go to state 871
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 828

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' @18 . foreach_statement   (rule 69)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    ':' 	shift, and go to state 869
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 870
    unticked_statement	go to state 86
    foreach_statement	go to state 872
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 829

    declare_statement  ->  ':' inner_statement_list "enddeclare (T_ENDDECLARE)" ';' .   (rule 127)

    $default	reduce using rule 127 (declare_statement)



state 830

    switch_case_list  ->  ':' ';' case_list "endswitch (T_ENDSWITCH)" . ';'   (rule 133)

    ';' 	shift, and go to state 873



state 831

    switch_case_list  ->  ':' case_list "endswitch (T_ENDSWITCH)" ';' .   (rule 132)

    $default	reduce using rule 132 (switch_case_list)



state 832

    case_list  ->  case_list "case (T_CASE)" expr . case_separator @32 inner_statement_list   (rule 136)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    ':' 	shift, and go to state 833
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ';' 	shift, and go to state 834

    case_separator	go to state 874



state 833

    case_separator  ->  ':' .   (rule 139)

    $default	reduce using rule 139 (case_separator)



state 834

    case_separator  ->  ';' .   (rule 140)

    $default	reduce using rule 140 (case_separator)



state 835

    case_list  ->  case_list "default (T_DEFAULT)" case_separator . @33 inner_statement_list   (rule 138)

    $default	reduce using rule 137 (@33)

    @33 	go to state 875



state 836

    switch_case_list  ->  '{' ';' case_list '}' .   (rule 131)

    $default	reduce using rule 131 (switch_case_list)



state 837

    non_empty_static_array_pair_list  ->  non_empty_static_array_pair_list ',' static_scalar "=> (T_DOUBLE_ARROW)" static_scalar .   (rule 420)

    $default	reduce using rule 420 (non_empty_static_array_pair_list)



state 838

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name . @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    $default	reduce using rule 78 (@24)

    @24 	go to state 876



state 839

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 parameter_list ')' lexical_vars '{' . inner_statement_list '}'   (rule 336)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 877



state 840

    variable_property  ->  "-> (T_OBJECT_OPERATOR)" object_property @67 method_or_not .   (rule 436)

    $default	reduce using rule 436 (variable_property)



state 841

    chaining_dereference  ->  chaining_dereference '[' dim_offset ']' .   (rule 242)

    $default	reduce using rule 242 (chaining_dereference)



state 842

    class_constant_declaration  ->  "const (T_CONST)" "identifier (T_STRING)" '=' . static_scalar   (rule 232)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 878
    static_class_constant	go to state 471



state 843

    trait_list  ->  trait_list ',' . fully_qualified_class_name   (rule 194)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    fully_qualified_class_name	go to state 879



state 844

    trait_adaptations  ->  ';' .   (rule 195)

    $default	reduce using rule 195 (trait_adaptations)



state 845

    trait_adaptations  ->  '{' . trait_adaptation_list '}'   (rule 196)

    "identifier (T_STRING)"	shift, and go to state 880
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    $default	reduce using rule 197 (trait_adaptation_list)

    namespace_name	go to state 516
    trait_adaptation_list	go to state 881
    non_empty_trait_adaptation_list	go to state 882
    trait_adaptation_statement	go to state 883
    trait_precedence	go to state 884
    trait_method_reference	go to state 885
    trait_method_reference_fully_qualified	go to state 886
    trait_alias	go to state 887
    fully_qualified_class_name	go to state 888



state 846

    trait_use_statement  ->  "use (T_USE)" trait_list trait_adaptations .   (rule 192)

    $default	reduce using rule 192 (trait_use_statement)



state 847

    class_variable_declaration  ->  "variable (T_VARIABLE)" .   (rule 229)
    class_variable_declaration  ->  "variable (T_VARIABLE)" . '=' static_scalar   (rule 230)

    '=' 	shift, and go to state 889

    $default	reduce using rule 229 (class_variable_declaration)



state 848

    class_statement  ->  variable_modifiers @36 class_variable_declaration . ';'   (rule 187)
    class_variable_declaration  ->  class_variable_declaration . ',' "variable (T_VARIABLE)"   (rule 227)
    class_variable_declaration  ->  class_variable_declaration . ',' "variable (T_VARIABLE)" '=' static_scalar   (rule 228)

    ',' 	shift, and go to state 890
    ';' 	shift, and go to state 891



state 849

    class_statement  ->  method_modifiers function is_reference . "identifier (T_STRING)" @37 '(' parameter_list ')' method_body   (rule 191)

    "identifier (T_STRING)"	shift, and go to state 892



state 850

    class_constant_declaration  ->  class_constant_declaration ',' "identifier (T_STRING)" . '=' static_scalar   (rule 231)

    '=' 	shift, and go to state 893



state 851

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 '(' parameter_list ')' '{' inner_statement_list . '}'   (rule 100)

    '}' 	shift, and go to state 894

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 852

    lexical_var_list  ->  '&' . "variable (T_VARIABLE)"   (rule 343)

    "variable (T_VARIABLE)"	shift, and go to state 895



state 853

    lexical_var_list  ->  "variable (T_VARIABLE)" .   (rule 342)

    $default	reduce using rule 342 (lexical_var_list)



state 854

    lexical_vars  ->  "use (T_USE)" '(' lexical_var_list . ')'   (rule 339)
    lexical_var_list  ->  lexical_var_list . ',' "variable (T_VARIABLE)"   (rule 340)
    lexical_var_list  ->  lexical_var_list . ',' '&' "variable (T_VARIABLE)"   (rule 341)

    ',' 	shift, and go to state 896
    ')' 	shift, and go to state 897



state 855

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    expr_without_variable  ->  function is_reference '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list . '}'   (rule 334)

    '}' 	shift, and go to state 898

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 856

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type '&' "variable (T_VARIABLE)" .   (rule 160)
    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type '&' "variable (T_VARIABLE)" . '=' static_scalar   (rule 161)

    '=' 	shift, and go to state 899

    $default	reduce using rule 160 (non_empty_parameter_list)



state 857

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type "variable (T_VARIABLE)" '=' . static_scalar   (rule 162)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 900
    static_class_constant	go to state 471



state 858

    non_empty_parameter_list  ->  optional_class_type '&' "variable (T_VARIABLE)" '=' static_scalar .   (rule 157)

    $default	reduce using rule 157 (non_empty_parameter_list)



state 859

    method  ->  '(' @68 function_call_parameter_list ')' .   (rule 440)

    $default	reduce using rule 440 (method)



state 860

    array_method_dereference  ->  array_method_dereference '[' dim_offset ']' .   (rule 437)

    $default	reduce using rule 437 (array_method_dereference)



state 861

    array_method_dereference  ->  method '[' dim_offset ']' .   (rule 438)

    $default	reduce using rule 438 (array_method_dereference)



state 862

    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" . '(' expr ')' ':' @35 inner_statement_list   (rule 148)

    '(' 	shift, and go to state 901



state 863

    new_else_single  ->  "else (T_ELSE)" . ':' inner_statement_list   (rule 152)

    ':' 	shift, and go to state 902



state 864

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single . "endif (T_ENDIF)" ';'   (rule 41)

    "endif (T_ENDIF)"	shift, and go to state 903



state 865

    elseif_list  ->  elseif_list "elseif (T_ELSEIF)" '(' . expr ')' @34 statement   (rule 145)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 904
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 866

    else_single  ->  "else (T_ELSE)" statement .   (rule 150)

    $default	reduce using rule 150 (else_single)



state 867

    while_statement  ->  ':' inner_statement_list "endwhile (T_ENDWHILE)" ';' .   (rule 142)

    $default	reduce using rule 142 (while_statement)



state 868

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' @14 for_expr ')' . @15 for_statement   (rule 51)

    $default	reduce using rule 50 (@15)

    @15 	go to state 905



state 869

    foreach_statement  ->  ':' . inner_statement_list "endforeach (T_ENDFOREACH)" ';'   (rule 125)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 906



state 870

    foreach_statement  ->  statement .   (rule 124)

    $default	reduce using rule 124 (foreach_statement)



state 871

    unticked_statement  ->  "foreach (T_FOREACH)" '(' expr_without_variable "as (T_AS)" @19 variable foreach_optional_arg ')' @20 foreach_statement .   (rule 72)

    $default	reduce using rule 72 (unticked_statement)



state 872

    unticked_statement  ->  "foreach (T_FOREACH)" '(' variable "as (T_AS)" @17 foreach_variable foreach_optional_arg ')' @18 foreach_statement .   (rule 69)

    $default	reduce using rule 69 (unticked_statement)



state 873

    switch_case_list  ->  ':' ';' case_list "endswitch (T_ENDSWITCH)" ';' .   (rule 133)

    $default	reduce using rule 133 (switch_case_list)



state 874

    case_list  ->  case_list "case (T_CASE)" expr case_separator . @32 inner_statement_list   (rule 136)

    $default	reduce using rule 135 (@32)

    @32 	go to state 907



state 875

    case_list  ->  case_list "default (T_DEFAULT)" case_separator @33 . inner_statement_list   (rule 138)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 908



state 876

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 . "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    "variable (T_VARIABLE)"	shift, and go to state 909



state 877

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list . '}'   (rule 336)

    '}' 	shift, and go to state 910

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 878

    class_constant_declaration  ->  "const (T_CONST)" "identifier (T_STRING)" '=' static_scalar .   (rule 232)

    $default	reduce using rule 232 (class_constant_declaration)



state 879

    trait_list  ->  trait_list ',' fully_qualified_class_name .   (rule 194)

    $default	reduce using rule 194 (trait_list)



state 880

    namespace_name  ->  "identifier (T_STRING)" .   (rule 5)
    trait_method_reference  ->  "identifier (T_STRING)" .   (rule 206)

    "as (T_AS)"	reduce using rule 206 (trait_method_reference)
    $default	reduce using rule 5 (namespace_name)



state 881

    trait_adaptations  ->  '{' trait_adaptation_list . '}'   (rule 196)

    '}' 	shift, and go to state 911



state 882

    trait_adaptation_list  ->  non_empty_trait_adaptation_list .   (rule 198)
    non_empty_trait_adaptation_list  ->  non_empty_trait_adaptation_list . trait_adaptation_statement   (rule 200)

    "identifier (T_STRING)"	shift, and go to state 880
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    $default	reduce using rule 198 (trait_adaptation_list)

    namespace_name	go to state 516
    trait_adaptation_statement	go to state 912
    trait_precedence	go to state 884
    trait_method_reference	go to state 885
    trait_method_reference_fully_qualified	go to state 886
    trait_alias	go to state 887
    fully_qualified_class_name	go to state 888



state 883

    non_empty_trait_adaptation_list  ->  trait_adaptation_statement .   (rule 199)

    $default	reduce using rule 199 (non_empty_trait_adaptation_list)



state 884

    trait_adaptation_statement  ->  trait_precedence . ';'   (rule 201)

    ';' 	shift, and go to state 913



state 885

    trait_alias  ->  trait_method_reference . "as (T_AS)" trait_modifiers "identifier (T_STRING)"   (rule 209)
    trait_alias  ->  trait_method_reference . "as (T_AS)" member_modifier   (rule 210)

    "as (T_AS)"	shift, and go to state 914



state 886

    trait_precedence  ->  trait_method_reference_fully_qualified . "insteadof (T_INSTEADOF)" trait_reference_list   (rule 203)
    trait_method_reference  ->  trait_method_reference_fully_qualified .   (rule 207)

    "insteadof (T_INSTEADOF)"	shift, and go to state 915

    $default	reduce using rule 207 (trait_method_reference)



state 887

    trait_adaptation_statement  ->  trait_alias . ';'   (rule 202)

    ';' 	shift, and go to state 916



state 888

    trait_method_reference_fully_qualified  ->  fully_qualified_class_name . ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)"   (rule 208)

    ":: (T_PAAMAYIM_NEKUDOTAYIM)"	shift, and go to state 917



state 889

    class_variable_declaration  ->  "variable (T_VARIABLE)" '=' . static_scalar   (rule 230)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 918
    static_class_constant	go to state 471



state 890

    class_variable_declaration  ->  class_variable_declaration ',' . "variable (T_VARIABLE)"   (rule 227)
    class_variable_declaration  ->  class_variable_declaration ',' . "variable (T_VARIABLE)" '=' static_scalar   (rule 228)

    "variable (T_VARIABLE)"	shift, and go to state 919



state 891

    class_statement  ->  variable_modifiers @36 class_variable_declaration ';' .   (rule 187)

    $default	reduce using rule 187 (class_statement)



state 892

    class_statement  ->  method_modifiers function is_reference "identifier (T_STRING)" . @37 '(' parameter_list ')' method_body   (rule 191)

    $default	reduce using rule 190 (@37)

    @37 	go to state 920



state 893

    class_constant_declaration  ->  class_constant_declaration ',' "identifier (T_STRING)" '=' . static_scalar   (rule 231)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 921
    static_class_constant	go to state 471



state 894

    unticked_function_declaration_statement  ->  function is_reference "identifier (T_STRING)" @29 '(' parameter_list ')' '{' inner_statement_list '}' .   (rule 100)

    $default	reduce using rule 100 (unticked_function_declaration_statement)



state 895

    lexical_var_list  ->  '&' "variable (T_VARIABLE)" .   (rule 343)

    $default	reduce using rule 343 (lexical_var_list)



state 896

    lexical_var_list  ->  lexical_var_list ',' . "variable (T_VARIABLE)"   (rule 340)
    lexical_var_list  ->  lexical_var_list ',' . '&' "variable (T_VARIABLE)"   (rule 341)

    '&' 	shift, and go to state 922
    "variable (T_VARIABLE)"	shift, and go to state 923



state 897

    lexical_vars  ->  "use (T_USE)" '(' lexical_var_list ')' .   (rule 339)

    $default	reduce using rule 339 (lexical_vars)



state 898

    expr_without_variable  ->  function is_reference '(' @53 parameter_list ')' lexical_vars '{' inner_statement_list '}' .   (rule 334)

    $default	reduce using rule 334 (expr_without_variable)



state 899

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type '&' "variable (T_VARIABLE)" '=' . static_scalar   (rule 161)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 924
    static_class_constant	go to state 471



state 900

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type "variable (T_VARIABLE)" '=' static_scalar .   (rule 162)

    $default	reduce using rule 162 (non_empty_parameter_list)



state 901

    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" '(' . expr ')' ':' @35 inner_statement_list   (rule 148)

    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "function (T_FUNCTION)"	shift, and go to state 46
    "static (T_STATIC)"	shift, and go to state 117
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 925
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 902

    new_else_single  ->  "else (T_ELSE)" ':' . inner_statement_list   (rule 152)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 926



state 903

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" . ';'   (rule 41)

    ';' 	shift, and go to state 927



state 904

    elseif_list  ->  elseif_list "elseif (T_ELSEIF)" '(' expr . ')' @34 statement   (rule 145)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 928



state 905

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' @14 for_expr ')' @15 . for_statement   (rule 51)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    ':' 	shift, and go to state 929
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 930
    unticked_statement	go to state 86
    for_statement	go to state 931
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 906

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    foreach_statement  ->  ':' inner_statement_list . "endforeach (T_ENDFOREACH)" ';'   (rule 125)

    "endforeach (T_ENDFOREACH)"	shift, and go to state 932

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 907

    case_list  ->  case_list "case (T_CASE)" expr case_separator @32 . inner_statement_list   (rule 136)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 933



state 908

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    case_list  ->  case_list "default (T_DEFAULT)" case_separator @33 inner_statement_list .   (rule 138)

    "endswitch (T_ENDSWITCH)"	reduce using rule 138 (case_list)
    "case (T_CASE)"	reduce using rule 138 (case_list)
    "default (T_DEFAULT)"	reduce using rule 138 (case_list)
    '}' 	reduce using rule 138 (case_list)
    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 909

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" . ')' @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    ')' 	shift, and go to state 934



state 910

    expr_without_variable  ->  "static (T_STATIC)" function is_reference '(' @54 parameter_list ')' lexical_vars '{' inner_statement_list '}' .   (rule 336)

    $default	reduce using rule 336 (expr_without_variable)



state 911

    trait_adaptations  ->  '{' trait_adaptation_list '}' .   (rule 196)

    $default	reduce using rule 196 (trait_adaptations)



state 912

    non_empty_trait_adaptation_list  ->  non_empty_trait_adaptation_list trait_adaptation_statement .   (rule 200)

    $default	reduce using rule 200 (non_empty_trait_adaptation_list)



state 913

    trait_adaptation_statement  ->  trait_precedence ';' .   (rule 201)

    $default	reduce using rule 201 (trait_adaptation_statement)



state 914

    trait_alias  ->  trait_method_reference "as (T_AS)" . trait_modifiers "identifier (T_STRING)"   (rule 209)
    trait_alias  ->  trait_method_reference "as (T_AS)" . member_modifier   (rule 210)

    "static (T_STATIC)"	shift, and go to state 740
    "abstract (T_ABSTRACT)"	shift, and go to state 741
    "final (T_FINAL)"	shift, and go to state 742
    "private (T_PRIVATE)"	shift, and go to state 743
    "protected (T_PROTECTED)"	shift, and go to state 744
    "public (T_PUBLIC)"	shift, and go to state 745

    $default	reduce using rule 211 (trait_modifiers)

    trait_modifiers	go to state 935
    member_modifier	go to state 936



state 915

    trait_precedence  ->  trait_method_reference_fully_qualified "insteadof (T_INSTEADOF)" . trait_reference_list   (rule 203)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    trait_reference_list	go to state 937
    fully_qualified_class_name	go to state 938



state 916

    trait_adaptation_statement  ->  trait_alias ';' .   (rule 202)

    $default	reduce using rule 202 (trait_adaptation_statement)



state 917

    trait_method_reference_fully_qualified  ->  fully_qualified_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" . "identifier (T_STRING)"   (rule 208)

    "identifier (T_STRING)"	shift, and go to state 939



state 918

    class_variable_declaration  ->  "variable (T_VARIABLE)" '=' static_scalar .   (rule 230)

    $default	reduce using rule 230 (class_variable_declaration)



state 919

    class_variable_declaration  ->  class_variable_declaration ',' "variable (T_VARIABLE)" .   (rule 227)
    class_variable_declaration  ->  class_variable_declaration ',' "variable (T_VARIABLE)" . '=' static_scalar   (rule 228)

    '=' 	shift, and go to state 940

    $default	reduce using rule 227 (class_variable_declaration)



state 920

    class_statement  ->  method_modifiers function is_reference "identifier (T_STRING)" @37 . '(' parameter_list ')' method_body   (rule 191)

    '(' 	shift, and go to state 941



state 921

    class_constant_declaration  ->  class_constant_declaration ',' "identifier (T_STRING)" '=' static_scalar .   (rule 231)

    $default	reduce using rule 231 (class_constant_declaration)



state 922

    lexical_var_list  ->  lexical_var_list ',' '&' . "variable (T_VARIABLE)"   (rule 341)

    "variable (T_VARIABLE)"	shift, and go to state 942



state 923

    lexical_var_list  ->  lexical_var_list ',' "variable (T_VARIABLE)" .   (rule 340)

    $default	reduce using rule 340 (lexical_var_list)



state 924

    non_empty_parameter_list  ->  non_empty_parameter_list ',' optional_class_type '&' "variable (T_VARIABLE)" '=' static_scalar .   (rule 161)

    $default	reduce using rule 161 (non_empty_parameter_list)



state 925

    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" '(' expr . ')' ':' @35 inner_statement_list   (rule 148)
    expr_without_variable  ->  expr . "|| (T_BOOLEAN_OR)" @44 expr   (rule 276)
    expr_without_variable  ->  expr . "&& (T_BOOLEAN_AND)" @45 expr   (rule 278)
    expr_without_variable  ->  expr . "or (T_LOGICAL_OR)" @46 expr   (rule 280)
    expr_without_variable  ->  expr . "and (T_LOGICAL_AND)" @47 expr   (rule 282)
    expr_without_variable  ->  expr . "xor (T_LOGICAL_XOR)" expr   (rule 283)
    expr_without_variable  ->  expr . '|' expr   (rule 284)
    expr_without_variable  ->  expr . '&' expr   (rule 285)
    expr_without_variable  ->  expr . '^' expr   (rule 286)
    expr_without_variable  ->  expr . '.' expr   (rule 287)
    expr_without_variable  ->  expr . '+' expr   (rule 288)
    expr_without_variable  ->  expr . '-' expr   (rule 289)
    expr_without_variable  ->  expr . '*' expr   (rule 290)
    expr_without_variable  ->  expr . '/' expr   (rule 291)
    expr_without_variable  ->  expr . '%' expr   (rule 292)
    expr_without_variable  ->  expr . "<< (T_SL)" expr   (rule 293)
    expr_without_variable  ->  expr . ">> (T_SR)" expr   (rule 294)
    expr_without_variable  ->  expr . "=== (T_IS_IDENTICAL)" expr   (rule 299)
    expr_without_variable  ->  expr . "!== (T_IS_NOT_IDENTICAL)" expr   (rule 300)
    expr_without_variable  ->  expr . "== (T_IS_EQUAL)" expr   (rule 301)
    expr_without_variable  ->  expr . "!= (T_IS_NOT_EQUAL)" expr   (rule 302)
    expr_without_variable  ->  expr . '<' expr   (rule 303)
    expr_without_variable  ->  expr . "<= (T_IS_SMALLER_OR_EQUAL)" expr   (rule 304)
    expr_without_variable  ->  expr . '>' expr   (rule 305)
    expr_without_variable  ->  expr . ">= (T_IS_GREATER_OR_EQUAL)" expr   (rule 306)
    expr_without_variable  ->  expr . "instanceof (T_INSTANCEOF)" class_name_reference   (rule 307)
    expr_without_variable  ->  expr . '?' @49 expr ':' @50 expr   (rule 314)
    expr_without_variable  ->  expr . '?' ':' @51 expr   (rule 316)

    "or (T_LOGICAL_OR)"	shift, and go to state 235
    "xor (T_LOGICAL_XOR)"	shift, and go to state 236
    "and (T_LOGICAL_AND)"	shift, and go to state 237
    '?' 	shift, and go to state 238
    "|| (T_BOOLEAN_OR)"	shift, and go to state 239
    "&& (T_BOOLEAN_AND)"	shift, and go to state 240
    '|' 	shift, and go to state 241
    '^' 	shift, and go to state 242
    '&' 	shift, and go to state 243
    "== (T_IS_EQUAL)"	shift, and go to state 244
    "!= (T_IS_NOT_EQUAL)"	shift, and go to state 245
    "=== (T_IS_IDENTICAL)"	shift, and go to state 246
    "!== (T_IS_NOT_IDENTICAL)"	shift, and go to state 247
    '<' 	shift, and go to state 248
    "<= (T_IS_SMALLER_OR_EQUAL)"	shift, and go to state 249
    '>' 	shift, and go to state 250
    ">= (T_IS_GREATER_OR_EQUAL)"	shift, and go to state 251
    "<< (T_SL)"	shift, and go to state 252
    ">> (T_SR)"	shift, and go to state 253
    '+' 	shift, and go to state 254
    '-' 	shift, and go to state 255
    '.' 	shift, and go to state 256
    '*' 	shift, and go to state 257
    '/' 	shift, and go to state 258
    '%' 	shift, and go to state 259
    "instanceof (T_INSTANCEOF)"	shift, and go to state 260
    ')' 	shift, and go to state 943



state 926

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    new_else_single  ->  "else (T_ELSE)" ':' inner_statement_list .   (rule 152)

    "endif (T_ENDIF)"	reduce using rule 152 (new_else_single)
    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 927

    unticked_statement  ->  "if (T_IF)" '(' expr ')' ':' @7 inner_statement_list @8 new_elseif_list new_else_single "endif (T_ENDIF)" ';' .   (rule 41)

    $default	reduce using rule 41 (unticked_statement)



state 928

    elseif_list  ->  elseif_list "elseif (T_ELSEIF)" '(' expr ')' . @34 statement   (rule 145)

    $default	reduce using rule 144 (@34)

    @34 	go to state 944



state 929

    for_statement  ->  ':' . inner_statement_list "endfor (T_ENDFOR)" ';'   (rule 123)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 945



state 930

    for_statement  ->  statement .   (rule 122)

    $default	reduce using rule 122 (for_statement)



state 931

    unticked_statement  ->  "for (T_FOR)" '(' for_expr ';' @13 for_expr ';' @14 for_expr ')' @15 for_statement .   (rule 51)

    $default	reduce using rule 51 (unticked_statement)



state 932

    foreach_statement  ->  ':' inner_statement_list "endforeach (T_ENDFOREACH)" . ';'   (rule 125)

    ';' 	shift, and go to state 946



state 933

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    case_list  ->  case_list "case (T_CASE)" expr case_separator @32 inner_statement_list .   (rule 136)

    "endswitch (T_ENDSWITCH)"	reduce using rule 136 (case_list)
    "case (T_CASE)"	reduce using rule 136 (case_list)
    "default (T_DEFAULT)"	reduce using rule 136 (case_list)
    '}' 	reduce using rule 136 (case_list)
    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 934

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' . @25 '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    $default	reduce using rule 79 (@25)

    @25 	go to state 947



state 935

    trait_alias  ->  trait_method_reference "as (T_AS)" trait_modifiers . "identifier (T_STRING)"   (rule 209)

    "identifier (T_STRING)"	shift, and go to state 948



state 936

    trait_alias  ->  trait_method_reference "as (T_AS)" member_modifier .   (rule 210)
    trait_modifiers  ->  member_modifier .   (rule 212)

    "identifier (T_STRING)"	reduce using rule 212 (trait_modifiers)
    $default	reduce using rule 210 (trait_alias)



state 937

    trait_precedence  ->  trait_method_reference_fully_qualified "insteadof (T_INSTEADOF)" trait_reference_list .   (rule 203)
    trait_reference_list  ->  trait_reference_list . ',' fully_qualified_class_name   (rule 205)

    ',' 	shift, and go to state 949

    $default	reduce using rule 203 (trait_precedence)



state 938

    trait_reference_list  ->  fully_qualified_class_name .   (rule 204)

    $default	reduce using rule 204 (trait_reference_list)



state 939

    trait_method_reference_fully_qualified  ->  fully_qualified_class_name ":: (T_PAAMAYIM_NEKUDOTAYIM)" "identifier (T_STRING)" .   (rule 208)

    $default	reduce using rule 208 (trait_method_reference_fully_qualified)



state 940

    class_variable_declaration  ->  class_variable_declaration ',' "variable (T_VARIABLE)" '=' . static_scalar   (rule 228)

    '+' 	shift, and go to state 459
    '-' 	shift, and go to state 460
    '[' 	shift, and go to state 461
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 116
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "static (T_STATIC)"	shift, and go to state 130
    "array (T_ARRAY)"	shift, and go to state 462
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 463
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 464
    "namespace (T_NAMESPACE)"	shift, and go to state 465
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 466

    namespace_name	go to state 467
    class_name	go to state 468
    common_scalar	go to state 469
    static_scalar	go to state 950
    static_class_constant	go to state 471



state 941

    class_statement  ->  method_modifiers function is_reference "identifier (T_STRING)" @37 '(' . parameter_list ')' method_body   (rule 191)

    "identifier (T_STRING)"	shift, and go to state 116
    "array (T_ARRAY)"	shift, and go to state 608
    "callable (T_CALLABLE)"	shift, and go to state 609
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    ')' 	reduce using rule 154 (parameter_list)
    $default	reduce using rule 163 (optional_class_type)

    namespace_name	go to state 516
    parameter_list	go to state 951
    non_empty_parameter_list	go to state 611
    optional_class_type	go to state 612
    fully_qualified_class_name	go to state 613



state 942

    lexical_var_list  ->  lexical_var_list ',' '&' "variable (T_VARIABLE)" .   (rule 341)

    $default	reduce using rule 341 (lexical_var_list)



state 943

    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" '(' expr ')' . ':' @35 inner_statement_list   (rule 148)

    ':' 	shift, and go to state 952



state 944

    elseif_list  ->  elseif_list "elseif (T_ELSEIF)" '(' expr ')' @34 . statement   (rule 145)

    "hellowork (T_HELLOWORK)"	shift, and go to state 3
    "include (T_INCLUDE)"	shift, and go to state 4
    "include_once (T_INCLUDE_ONCE)"	shift, and go to state 5
    "eval (T_EVAL)"	shift, and go to state 6
    "require (T_REQUIRE)"	shift, and go to state 7
    "require_once (T_REQUIRE_ONCE)"	shift, and go to state 8
    "print (T_PRINT)"	shift, and go to state 9
    '+' 	shift, and go to state 10
    '-' 	shift, and go to state 11
    '!' 	shift, and go to state 12
    '~' 	shift, and go to state 13
    "++ (T_INC)"	shift, and go to state 14
    "-- (T_DEC)"	shift, and go to state 15
    "(int) (T_INT_CAST)"	shift, and go to state 16
    "(double) (T_DOUBLE_CAST)"	shift, and go to state 17
    "(string) (T_STRING_CAST)"	shift, and go to state 18
    "(array) (T_ARRAY_CAST)"	shift, and go to state 19
    "(object) (T_OBJECT_CAST)"	shift, and go to state 20
    "(bool) (T_BOOL_CAST)"	shift, and go to state 21
    "(unset) (T_UNSET_CAST)"	shift, and go to state 22
    '@' 	shift, and go to state 23
    '[' 	shift, and go to state 24
    "new (T_NEW)"	shift, and go to state 25
    "clone (T_CLONE)"	shift, and go to state 26
    "exit (T_EXIT)"	shift, and go to state 27
    "if (T_IF)"	shift, and go to state 28
    "integer number (T_LNUMBER)"	shift, and go to state 29
    "floating-point number (T_DNUMBER)"	shift, and go to state 30
    "identifier (T_STRING)"	shift, and go to state 31
    "variable name (T_STRING_VARNAME)"	shift, and go to state 32
    "variable (T_VARIABLE)"	shift, and go to state 33
    T_INLINE_HTML	shift, and go to state 34
    "quoted-string (T_CONSTANT_ENCAPSED_STRING)"	shift, and go to state 35
    "echo (T_ECHO)"	shift, and go to state 36
    "do (T_DO)"	shift, and go to state 37
    "while (T_WHILE)"	shift, and go to state 38
    "for (T_FOR)"	shift, and go to state 39
    "foreach (T_FOREACH)"	shift, and go to state 40
    "declare (T_DECLARE)"	shift, and go to state 41
    "switch (T_SWITCH)"	shift, and go to state 42
    "break (T_BREAK)"	shift, and go to state 43
    "continue (T_CONTINUE)"	shift, and go to state 44
    "goto (T_GOTO)"	shift, and go to state 45
    "function (T_FUNCTION)"	shift, and go to state 46
    "return (T_RETURN)"	shift, and go to state 48
    "try (T_TRY)"	shift, and go to state 49
    "throw (T_THROW)"	shift, and go to state 50
    "global (T_GLOBAL)"	shift, and go to state 52
    "static (T_STATIC)"	shift, and go to state 53
    "unset (T_UNSET)"	shift, and go to state 56
    "isset (T_ISSET)"	shift, and go to state 57
    "empty (T_EMPTY)"	shift, and go to state 58
    "list (T_LIST)"	shift, and go to state 63
    "array (T_ARRAY)"	shift, and go to state 64
    "__CLASS__ (T_CLASS_C)"	shift, and go to state 65
    "__TRAIT__ (T_TRAIT_C)"	shift, and go to state 66
    "__METHOD__ (T_METHOD_C)"	shift, and go to state 67
    "__FUNCTION__ (T_FUNC_C)"	shift, and go to state 68
    "__LINE__ (T_LINE)"	shift, and go to state 69
    "__FILE__ (T_FILE)"	shift, and go to state 70
    "heredoc start (T_START_HEREDOC)"	shift, and go to state 71
    "namespace (T_NAMESPACE)"	shift, and go to state 118
    "__NAMESPACE__ (T_NS_C)"	shift, and go to state 73
    "__DIR__ (T_DIR)"	shift, and go to state 74
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 75
    '(' 	shift, and go to state 76
    ';' 	shift, and go to state 77
    '{' 	shift, and go to state 78
    '$' 	shift, and go to state 79
    '`' 	shift, and go to state 80
    '\"'	shift, and go to state 81

    namespace_name	go to state 82
    statement	go to state 953
    unticked_statement	go to state 86
    new_expr	go to state 93
    expr_without_variable	go to state 94
    function	go to state 119
    function_call	go to state 96
    class_name	go to state 97
    common_scalar	go to state 98
    scalar	go to state 99
    expr	go to state 100
    r_variable	go to state 101
    rw_variable	go to state 102
    variable	go to state 103
    variable_without_objects	go to state 104
    static_member	go to state 105
    variable_class_name	go to state 106
    array_function_dereference	go to state 107
    base_variable_with_function_calls	go to state 108
    base_variable	go to state 109
    reference_variable	go to state 110
    compound_variable	go to state 111
    simple_indirect_reference	go to state 112
    internal_functions_in_yacc	go to state 113
    class_constant	go to state 114



state 945

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    for_statement  ->  ':' inner_statement_list . "endfor (T_ENDFOR)" ';'   (rule 123)

    "endfor (T_ENDFOR)"	shift, and go to state 954

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 946

    foreach_statement  ->  ':' inner_statement_list "endforeach (T_ENDFOREACH)" ';' .   (rule 125)

    $default	reduce using rule 125 (foreach_statement)



state 947

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 . '{' inner_statement_list '}' @26 additional_catches   (rule 81)

    '{' 	shift, and go to state 955



state 948

    trait_alias  ->  trait_method_reference "as (T_AS)" trait_modifiers "identifier (T_STRING)" .   (rule 209)

    $default	reduce using rule 209 (trait_alias)



state 949

    trait_reference_list  ->  trait_reference_list ',' . fully_qualified_class_name   (rule 205)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    fully_qualified_class_name	go to state 956



state 950

    class_variable_declaration  ->  class_variable_declaration ',' "variable (T_VARIABLE)" '=' static_scalar .   (rule 228)

    $default	reduce using rule 228 (class_variable_declaration)



state 951

    class_statement  ->  method_modifiers function is_reference "identifier (T_STRING)" @37 '(' parameter_list . ')' method_body   (rule 191)

    ')' 	shift, and go to state 957



state 952

    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" '(' expr ')' ':' . @35 inner_statement_list   (rule 148)

    $default	reduce using rule 147 (@35)

    @35 	go to state 958



state 953

    elseif_list  ->  elseif_list "elseif (T_ELSEIF)" '(' expr ')' @34 statement .   (rule 145)

    $default	reduce using rule 145 (elseif_list)



state 954

    for_statement  ->  ':' inner_statement_list "endfor (T_ENDFOR)" . ';'   (rule 123)

    ';' 	shift, and go to state 959



state 955

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' . inner_statement_list '}' @26 additional_catches   (rule 81)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 960



state 956

    trait_reference_list  ->  trait_reference_list ',' fully_qualified_class_name .   (rule 205)

    $default	reduce using rule 205 (trait_reference_list)



state 957

    class_statement  ->  method_modifiers function is_reference "identifier (T_STRING)" @37 '(' parameter_list ')' . method_body   (rule 191)

    ';' 	shift, and go to state 961
    '{' 	shift, and go to state 962

    method_body	go to state 963



state 958

    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" '(' expr ')' ':' @35 . inner_statement_list   (rule 148)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 964



state 959

    for_statement  ->  ':' inner_statement_list "endfor (T_ENDFOR)" ';' .   (rule 123)

    $default	reduce using rule 123 (for_statement)



state 960

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list . '}' @26 additional_catches   (rule 81)

    '}' 	shift, and go to state 965

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 961

    method_body  ->  ';' .   (rule 213)

    $default	reduce using rule 213 (method_body)



state 962

    method_body  ->  '{' . inner_statement_list '}'   (rule 214)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 966



state 963

    class_statement  ->  method_modifiers function is_reference "identifier (T_STRING)" @37 '(' parameter_list ')' method_body .   (rule 191)

    $default	reduce using rule 191 (class_statement)



state 964

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    new_elseif_list  ->  new_elseif_list "elseif (T_ELSEIF)" '(' expr ')' ':' @35 inner_statement_list .   (rule 148)

    "elseif (T_ELSEIF)"	reduce using rule 148 (new_elseif_list)
    "else (T_ELSE)"	reduce using rule 148 (new_elseif_list)
    "endif (T_ENDIF)"	reduce using rule 148 (new_elseif_list)
    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 965

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' . @26 additional_catches   (rule 81)

    $default	reduce using rule 80 (@26)

    @26 	go to state 967



state 966

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    method_body  ->  '{' inner_statement_list . '}'   (rule 214)

    '}' 	shift, and go to state 968

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 967

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 . additional_catches   (rule 81)

    "catch (T_CATCH)"	shift, and go to state 969

    $default	reduce using rule 86 (additional_catches)

    additional_catches	go to state 970
    non_empty_additional_catches	go to state 971
    additional_catch	go to state 972



state 968

    method_body  ->  '{' inner_statement_list '}' .   (rule 214)

    $default	reduce using rule 214 (method_body)



state 969

    additional_catch  ->  "catch (T_CATCH)" . '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list '}'   (rule 91)

    '(' 	shift, and go to state 973



state 970

    unticked_statement  ->  "try (T_TRY)" @22 '{' inner_statement_list '}' "catch (T_CATCH)" '(' @23 fully_qualified_class_name @24 "variable (T_VARIABLE)" ')' @25 '{' inner_statement_list '}' @26 additional_catches .   (rule 81)

    $default	reduce using rule 81 (unticked_statement)



state 971

    additional_catches  ->  non_empty_additional_catches .   (rule 85)
    non_empty_additional_catches  ->  non_empty_additional_catches . additional_catch   (rule 88)

    "catch (T_CATCH)"	shift, and go to state 969

    $default	reduce using rule 85 (additional_catches)

    additional_catch	go to state 974



state 972

    non_empty_additional_catches  ->  additional_catch .   (rule 87)

    $default	reduce using rule 87 (non_empty_additional_catches)



state 973

    additional_catch  ->  "catch (T_CATCH)" '(' . fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list '}'   (rule 91)

    "identifier (T_STRING)"	shift, and go to state 116
    "namespace (T_NAMESPACE)"	shift, and go to state 514
    "\\ (T_NS_SEPARATOR)"	shift, and go to state 515

    namespace_name	go to state 516
    fully_qualified_class_name	go to state 975



state 974

    non_empty_additional_catches  ->  non_empty_additional_catches additional_catch .   (rule 88)

    $default	reduce using rule 88 (non_empty_additional_catches)



state 975

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name . @27 "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list '}'   (rule 91)

    $default	reduce using rule 89 (@27)

    @27 	go to state 976



state 976

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 . "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list '}'   (rule 91)

    "variable (T_VARIABLE)"	shift, and go to state 977



state 977

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" . ')' @28 '{' inner_statement_list '}'   (rule 91)

    ')' 	shift, and go to state 978



state 978

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' . @28 '{' inner_statement_list '}'   (rule 91)

    $default	reduce using rule 90 (@28)

    @28 	go to state 979



state 979

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 . '{' inner_statement_list '}'   (rule 91)

    '{' 	shift, and go to state 980



state 980

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 '{' . inner_statement_list '}'   (rule 91)

    $default	reduce using rule 28 (inner_statement_list)

    inner_statement_list	go to state 981



state 981

    inner_statement_list  ->  inner_statement_list . @4 inner_statement   (rule 27)
    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list . '}'   (rule 91)

    '}' 	shift, and go to state 982

    $default	reduce using rule 26 (@4)

    @4  	go to state 366



state 982

    additional_catch  ->  "catch (T_CATCH)" '(' fully_qualified_class_name @27 "variable (T_VARIABLE)" ')' @28 '{' inner_statement_list '}' .   (rule 91)

    $default	reduce using rule 91 (additional_catch)



state 983

    $   	go to state 984



state 984

    $   	go to state 985



state 985

    $default	accept
